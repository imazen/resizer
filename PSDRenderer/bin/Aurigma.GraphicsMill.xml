<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Aurigma.GraphicsMill</name>
        <version>5.5.1.0</version>
        <fullname>Aurigma.GraphicsMill, Version=5.5.1.0, Culture=neutral, PublicKeyToken=af7154c50c505858</fullname>
    </assembly>
    <members>
        <member name="N:Aurigma.GraphicsMill" draft="yes">
            <summary>The <see cref="N:Aurigma.GraphicsMill" /> is a root namespace of the Graphics Mill for .NET.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.AbortedException">
            <summary>The exception which is thrown when user aborts the operation.</summary>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="M:Aurigma.GraphicsMill.AbortedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.AbortedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.AbortedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.AbortedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.AbortedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.AbortedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.AbortedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.AbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Bitmap" draft="yes">
            <summary>This class represents bitmap, i.e. object which stores raster data.</summary>
            <remarks><para>This is the most essential class of Graphics Mill for .NET. It incapsulates raster image and stores bitmap as well as other related data.</para><para>To load bitmap, you can either format reader returned from <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, or just pass filename into <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> or <see cref="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.String)">constructor</see>. Also you create new empty bitmap with <see cref="M:Aurigma.GraphicsMill.Bitmap.Create(System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat)" /> method. </para><para>Using appropriate properties you can get such details about loaded image as <see cref="P:Aurigma.GraphicsMill.Bitmap.Width" />, <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" />, <see cref="P:Aurigma.GraphicsMill.Bitmap.PixelFormat" />, <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorSpace" />, <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsPerPixel" />, etc.</para><para>To apply some effect or transform, you should pass this bitmap into <see cref="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)" /> method of appropriate <see cref="T:Aurigma.GraphicsMill.Transforms.BitmapTransform" /> class descendant. Alternatively you can use methods exposed in <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorAdjustment" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Transforms" /> properties. It is less flexible, but has shorter syntax. You can undo or redo any operation with <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" />/<see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> methods.</para><para>Let's assume you need to work with bitmap channels: split channels into several grayscale bitmaps, replace some channel with grayscale image, swap channels, add/remove alpha channel, etc. In this case you should use methods exposed by <see cref="P:Aurigma.GraphicsMill.Bitmap.Channels" /> property.</para><para>
              If standard imaging features of Graphics Mill for .NET are not enough to you, you can use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits" /> method which returns a <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object. This object gives you direct access to the bitmap pixels. If you need just get/set the single pixel value, you can use easy-to-use pair of methods <see cref="M:Aurigma.GraphicsMill.Bitmap.GetPixel(System.Int32,System.Int32)" />/<see cref="M:Aurigma.GraphicsMill.Bitmap.SetPixel(System.Int32,System.Int32,Aurigma.GraphicsMill.Color)" />.</para><para>To save result to file you also can either use format writers or the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String)" /> method.</para><para>This class also provides a number of useful events.  Event <see cref="E:Aurigma.GraphicsMill.Bitmap.Progress" /> allows you creating progress bar. Using events <see cref="E:Aurigma.GraphicsMill.Bitmap.Undone" /> and <see cref="E:Aurigma.GraphicsMill.Bitmap.Redone" /> you can enable or disable appropriate menu items. Event <see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /> fires when some operation has changed the bitmap. In event <see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" /> you can cancel the operation which is going to modify the bitmap. The similar pair of events is available for bitmap saving: <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> fires before the bitmap is saved, <see cref="E:Aurigma.GraphicsMill.Bitmap.Saved" /> - after. <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event is convenient to set encoder parameters at: it passes <see cref="T:Aurigma.GraphicsMill.Codecs.EncoderOptions" /> object which you can initialize and these settings will be applied during encoding. Therefore it is convenient place to put a save parameters dialogs at. </para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Loading4"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Loading4"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Abort">
            <summary>Aborts currently running operation.</summary>
            <remarks>After you stop the operation with this method, the operation throws <see cref="T:Aurigma.GraphicsMill.AbortedException" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.BitsLocked">
            <summary>Indicates if pixels are locked with <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" />.</summary>
            <value>Value specifying if <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> without sequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> was called.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.BitsPerPixel">
            <summary>Returns number of bits per pixel.</summary>
            <value>Number of bits per pixel of current pixel format.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#BitsPerPixel"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#BitsPerPixel"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.CanRedo">
            <summary>Indicates if last reverted action can be redone.</summary>
            <value>Value specifying if last reverted action can be redone.</value>
            <remarks><para>
              Graphics Mill for .NET has internal bitmap changes stack. If current position of this stack is a stack top, no actions to redo are available and this property returns <b>false</b>. If you try to call <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> method, you will get an exception. If the current stack position is below of the stack top, this property returns <b>true</b> and you can call <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> method to restore the bitmap state.
</para><para>
If undo/redo functionality is disabled (when <see cref="P:Aurigma.GraphicsMill.Bitmap.UndoRedoEnabled" /> is set to <b>false</b>), this property always returns <b>false</b>. 
</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Bitmap.UndoRedoEnabled" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.CanUndo" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.Redo" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.RedoStepCount" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.MaxUndoStepCount" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.CanUndo">
            <summary>Indicates if last bitmap modification can be undone.</summary>
            <value>Value specifying if last bitmap modification can be undone.</value>
            <remarks><para>
              Graphics Mill for .NET has internal bitmap changes stack. If current position of this stack is a stack bottom, no actions to undo are available and this property returns <b>false</b>. If you try to call <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method, you will get an exception. If the current stack position is above of the stack bottom, this property returns <b>true</b> and you can call <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method to revert the bitmap state.
</para><para>
If undo/redo functionality is disabled (when <see cref="P:Aurigma.GraphicsMill.Bitmap.UndoRedoEnabled" /> is set to <b>false</b>), this property always returns <b>false</b>. 
</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Bitmap.UndoRedoEnabled" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.CanRedo" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.Undo" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.UndoStepCount" />
<seealso cref="P:Aurigma.GraphicsMill.Bitmap.MaxUndoStepCount" />
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Changed">
            <summary>Fires when the bitmap was modified (after the end of an operation).</summary>
            <remarks><para>
This event is fired only if you run the operations through build-in methods or properties. If you create external transform or codec and run it, this event will not fire (in this case you should use <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Stopped" /> event of the transform or codec you create).
</para></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Changing">
            <summary>Fires before an image is being modified (before the start of an operation).</summary>
            <remarks><para>
This event is fired only if you run the operations through build-in methods or properties. If you create external transform or codec and run it, this event will not fire (in this case you should use <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Starting" /> event of the transform or codec you create).
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Channels">
            <summary>Returns object which provides access to various operations with bitmap channels.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ChannelsProvider" /> object containing methods which allow operating bitmap channels.</value>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AddAlpha"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AddAlpha"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Clear(Aurigma.GraphicsMill.Color)">
            <summary>Clears the image and sets all pixels to the specified color.</summary>
            <param name="color">The color value which should fill the image. It is recommended to make sure that this object has the same color space as the bitmap itself. If color spaces are not match (e.g. bitmap is CMYK and this color is RGB), color will be automatically converted, but no color management will be applied.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.ClearHistory" draft="yes">
            <summary>Discards both undo and redo history.</summary>
            <remarks><para>This method removes all temporary files which keep undo and redo history.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearRedoHistory" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearUndoHistory" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.ClearRedoHistory">
            <summary>Discards redo history.</summary>
            <remarks><para>This method removes all temporary files which keep redo history. Undo history is not removed.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearHistory" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearUndoHistory" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.ClearUndoHistory">
            <summary>Discards undo history.</summary>
            <remarks><para>This method removes all temporary files which keep undo history. Redo history is not removed.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearHistory" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.ClearRedoHistory" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Clone">
            <summary>Creates a full copy of bitmap. All the bitmap data and object properties are copied.</summary>
            <returns>Bitmap object containing full copy of the current object.</returns>
            <example><code language="VB" source="ColorConversionVB/form1.vb#BitmapClone"></code><code language="CS" source="ColorConversionCS/form1.cs#BitmapClone"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.ColorAdjustment">
            <summary>Returns object providing methods which are responsible for color adjustment and tone correction (brightness/contrast, levels, hue/saturation/lightness adjustment, etc.).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorAdjustmentProvider" /> class instance containing methods which apply color adjustment and tone correction algorithms on the current bitmap.</value>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslColorAdjustment"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.ColorManagement">
            <summary>Returns object providing methods which are responsible for color management.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorManagementProvider" /> class instance providing methods which are responsible for color management.</value>
            <example><code language="VB" source="ColorConversionVB/form1.vb#CMYKtoRGBWithCM"></code><code language="CS" source="ColorConversionCS/form1.cs#CMYKtoRGBWithCM"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.ColorProfile">
            <summary>Gets/sets color profile associated with the bitmap.</summary>
            <value>Color profile associated with the bitmap.</value>
            <remarks>If no color profile was loaded from file (e.g. file has no embedded profile) this property returns <b>null</b>.</remarks>
            <example><para>ColorProfile property can be also used to embed another profile into the image:</para><code language="VB" source="ColorConversionVB/form1.vb#LoadICCProfile"></code><code language="CS" source="ColorConversionCS/form1.cs#SaveICCProfile"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.ColorSpace">
            <summary>Indicates color space of the current bitmap.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value specifying color space of the current bitmap.</value>
            <seealso cref="P:Aurigma.GraphicsMill.Bitmap.PixelFormat" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.CompressSerializedData">
            <summary>Gets/sets a value that specifies whether to compress data during serialization.</summary>
            <value>A <see cref="T:System.Boolean" /> value which specifies whether to compress serialized data. Default value is <b>false</b>.</value>
            <remarks><para>Compression reduces the serialized data size, however it takes more CPU resources. That's why it is recommended to use compression only when the size is an actual bottleneck, for example, if you transfer this data through the slow network connection. If the serialization speed is more important that the size (e.g. on the local machine), it is better to disable the compression. </para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Bitmap.Serialize(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Discards old bitmap data and creates new bitmap from another bitmap.</summary>
            <param name="bitmap">Bitmap from which all data is copied to the current bitmap.</param>
            <overloads><summary>Discards old bitmap data and creates new bitmap</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(Aurigma.GraphicsMill.Color,System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat)">
            <summary>Discards old bitmap data and creates new bitmap of given dimensions and pixel format. Background color is specified.</summary>
            <param name="background">Background color to fill the bitmap with.</param>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If you specify indexed pixel format, uninitialized palette will be generated. You must fill entries yourself. Palette will have maximum possible for given pixel format colors number (2 colors for 1-bit images, 16 colors for 4-bit images, and 256 colors for 8-bit images).</param>
            <remarks>If color space of the color does not fit color space of the pixel format, color is converted to necessary color space.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(Aurigma.GraphicsMill.Color,System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Discards old bitmap data and creates new bitmap of given dimensions and pixel format. Background color is specified.</summary>
            <param name="background">Background color to fill the bitmap with.</param>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, <i>palette</i> is ignored.</param>
            <param name="palette">Palette attached to new bitmap. <note type="caution">This palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</note></param>
            <remarks>If color space of the color does not fit color space of the pixel format, color is converted to necessary color space.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat)">
            <summary>Discards old bitmap data and creates new bitmap of given dimensions and pixel format.</summary>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If you specify indexed pixel format, uninitialized palette will be generated. You must fill entries yourself. Palette will have maximum possible for given pixel format colors number (2 colors for 1-bit images, 16 colors for 4-bit images, and 256 colors for 8-bit images).</param>
            <remarks>Bitmap data is stuffed with zeros. So if pixel format:
<list type="bullet"><item><term>
supports alpha channel
    </term><description>
image is fully transparent
    </description></item><item><term>
is RGB
    </term><description>
image is filled with black color
    </description></item><item><term>
is CMYK
    </term><description>
image is filled with white color
    </description></item><item><term>
is indexed
    </term><description>
image has color of the first palette entry
    </description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Discards old bitmap data and creates new bitmap of given dimensions, pixel format and palette.</summary>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, <i>palette</i> is ignored.</param>
            <param name="palette">Palette attached to new bitmap. <note type="caution">This palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</note></param>
            <remarks>Bitmap data is stuffed with zeros. So if pixel format:
<list type="bullet"><item><term>
supports alpha channel
    </term><description>
image is fully transparent
    </description></item><item><term>
is RGB
    </term><description>
image is filled with black color
    </description></item><item><term>
is CMYK
    </term><description>
image is filled with white color
    </description></item><item><term>
is indexed
    </term><description>
image has color of the first palette entry
    </description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Create(System.Drawing.Bitmap)">
            <summary>Creates new bitmap from System.Drawing.Bitmap (standard .NET class representing bitmap) instance.</summary>
            <param name="bitmap">System.Drawing.Bitmap from which bitmap data is copied.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Deserialize(System.IO.Stream)">
            <summary>Deserializes the bitmap object.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> containing the serialization data.</param>
            <seealso cref="M:Aurigma.GraphicsMill.Bitmap.Serialize(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <example><code language="VB" source="CodeSnippets/DisplayingImageinBitmapViewerWindowsControl2.vb"></code><code language="CS" source="CodeSnippets/DisplayingImageinBitmapViewerWindowsControl2.cs"></code></example>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode)" draft="yes">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap with destination dimensions equal to the dimensions of the source bitmap.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
            <overloads><summary>Draws a bitmap on various surfaces as <see cref="T:Aurigma.GraphicsMill.Bitmap" />, <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> classes, or Windows GDI device context.</summary><seealso href="OverlayingImages.htm">Overlaying Images</seealso></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single)" draft="yes">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap with destination dimensions equal to the dimensions of the source bitmap.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that  current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the target bitmap. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#OverlayingImages"></code><code language="CS" source="DrawingCS/form1.cs#OverlayingImages"></code></example>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the target bitmap. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the target bitmap. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the target bitmap. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on another bitmap.</summary>
            <param name="destinationBitmap">Target (destination) bitmap (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the target bitmap. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If pixel formats of bitmaps are different, the method may fail (for some pairs of pixel formats). So it is recommended to make sure that current bitmap pixel format is compatible with target bitmap (or, ideally, the same).</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Drawing.GdiGraphics,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <param name="destinationGraphics">Target <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.Drawing.Graphics,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (standard .NET class for drawing).</summary>
            <param name="destinationGraphics">Target <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC with dimensions equal to the dimensions of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given HDC. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given HDC. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given HDC. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on the given HDC. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Draw(System.IntPtr,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws current bitmap on given Windows GDI device context (represented as handle to device context, i.e. HDC).</summary>
            <param name="hdc">Target handle to device context (on which current bitmap should be drawn).</param>
            <param name="destinationRectangle">Destination rectangle (see <b>Remarks</b> section).</param>
            <param name="sourceRectangle">Source rectangle (see <b>Remarks</b> section).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Pixels from source rectangle of current bitmap are drawn to destination rectangle on the given HDC. If source rectangle dimensions differ from dimensions of destination rectangle, pixels are resized to have the same size as destination rectangle.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth (both for source and destination rectangles) are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Export">
            <summary>Returns pixels of bitmap as 3D array.</summary>
            <returns>Array of image pixels returned in the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.FromClipboard">
            <summary>Extracts the image data from the clipboard and creates the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance containing this image data.</summary>
            <returns>The <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which contains the image data from the clipboard.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.FromHdc(System.IntPtr,System.Drawing.Rectangle)">
            <summary>Extracts the image data from the specified device context and creates the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance containing this image data.</summary>
            <param name="hdc">The handle to device context to get the bitmap from.</param>
            <param name="rectangle">The rectangle of which specifies a viewport to get the bitmap from.</param>
            <returns>The <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which contains the image data from the device context.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetEmptyMask">
            <summary>Returns grayscale image of the same size as current bitmap filled with black color. It can be used as mask template for transforms.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object which can be used as a template for a mask for using transforms on current bitmap.</returns>
            <remarks>Using this method you can get a template for a mask. Initially it is filled with black pixels (i.e. mask is absolutely transparent). After that you draw something on this mask (white color means opaque areas) and use it with transforms derived from <see cref="T:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform" /> class.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetGdiGraphics">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</returns>
            <remarks><para>Several calls of this method will return the same object.</para><para>You can freely dispose the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> returned with this method, although it is not necessary. If you dispose this graphics object, next call of the <see cref="M:Aurigma.GraphicsMill.Bitmap.GetGdiGraphics" /> method will create new instance of this class.</para><note>GDI cannot handle bitmaps with an alpha channel when it draws anything on it. As the high byte of 4-byte color must be zero in GDI, each pixel drawn with GDI becomes transparent. So now, if you try to call any drawing methods for the bitmaps with an alpha channel when using GDI, the <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> exception will be thrown.</note></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetGdiplusGraphics">
            <summary>Returns <see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object associated with this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <returns><see cref="T:System.Drawing.Graphics">System.Drawing.Graphics</see> object associated with this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</returns>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiplus"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiplus"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetPixel(System.Int32,System.Int32)">
            <summary>Returns pixel value at specified coordinates.</summary>
            <param name="x">Horizontal position of the pixel.</param>
            <param name="y">Vertical position of the pixel.</param>
            <returns>Pixel value at the specified position. The actual type of the returned object depends on color space of the bitmap. E.g. if bitmap is in RGB color space, actual type will be <see cref="T:Aurigma.GraphicsMill.RgbColor" />, etc.</returns>
            <remarks><para>This method was implemented for easy but slow access to pixels. It works ideally if you need to get one pixel value, for example, when you implement color picker. However if you need iterate each pixel in bitmap, it will work too slow. In this case you should consider using <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits" /> method instead. It will provide you a direct access to pixels.</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Pixels"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Pixels"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.GetVerticalResolution">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Handle">
            <summary>Gets a GDI handle to the bitmap (HBITMAP).</summary>
            <value>Handle to bitmap.</value>
            <remarks><para>Handle to bitmap (HBITMAP) is often needed when it is necessary to use GDI functions to deal with the bitmap (as well as certain WinAPI functions which are responsible for the user interface rendering). </para><note>HBITMAP is available only if the bitmap is GDI-compatible, i.e. it has a pixel format which is supported by GDI. In other words, it will work for indexed bitmaps, as well as for 24-bit and 32-bit RGB bitmaps. If you have, say, CMYK bitmap, you should convert it to some GDI-compatible pixel format before using this property.  </note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.HasAlpha">
            <summary>Specifies whether current pixel format supports alpha channel (information about opacity of pixels).</summary>
            <value>If true, current pixel format supports alpha channel, if false, no transparency information can be stored in current bitmap.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#HasAlphaChannel"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#HasAlphaChannel"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Height">
            <summary>Returns current bitmap height in pixels.</summary>
            <value>Height of the bitmap in pixels.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#WidthHeight"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#WidthHeight"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Import(System.Int32[0:,0:,0:])">
            <summary>Fills pixels of the current bitmap from given 3D array.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. <note type="caution">Array width, height, and channel number must conform current bitmap dimensions and pixel format.</note></param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsCmyk">
            <summary>Indicates if color space of current bitmap is CMYK.</summary>
            <value>If true, color space is CMYK, otherwise it is some other color space.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsEmpty">
            <summary>Indicates if bitmap is empty (no bitmap data loaded).</summary>
            <value>If true, no data is loaded into bitmap, otherwise bitmap contains valid image.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsExtended">
            <summary>Indicates if current pixel format is extended (i.e. 16 bits per channel).</summary>
            <value>If true, 16 bits per channel are used, otherwise - 8 bits per channel.</value>
            <remarks>Indexed bitmaps are always non-indexed.</remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsGrayScale">
            <summary>Indicates if color space of current bitmap is grayscale.</summary>
            <value>If true, color space is grayscale, otherwise it is some other color space.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsIndexed">
            <summary>Indicates if current bitmap is indexed (palette-based).</summary>
            <value>If true, the image is indexed (each pixel is an index in palette rather than color value).</value>
            <remarks>If the bitmap is indexed, it is guarantied that <see cref="P:Aurigma.GraphicsMill.Bitmap.Palette" /> property, contains valid <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> object.</remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.IsRgb">
            <summary>Indicates if color space of current bitmap is RGB.</summary>
            <value>If true, color space is RGB, otherwise it is some other color space.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Load(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat)">
            <summary>Loads the bitmap from given 3D array of pixels.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels.</param>
            <param name="format">Pixel format of new bitmap.</param>
            <overloads><summary>Loads the bitmap from some external source.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Load(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Loads the bitmap from given 3D array of pixels and palette.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. Indexed pixel formats are treated as having single channel.</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, argument <i>palette</i> will be ignored. <note type="caution"><b>Format1bppIndexed</b> and <b>Format4bppIndexed</b> pixel formats are not supported as well as any other pixel format which is not aligned on byte.</note></param>
            <param name="palette">Palette attached to new bitmap. Note, this palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)">
            <summary>Loads the bitmap from specified file.</summary>
            <param name="fileName">Name of the file to load.</param>
            <remarks>If multiframe file is loaded, first frame is taken.</remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Loading3"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Loading3"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Load(System.IO.Stream)">
            <summary>Loads the bitmap from specified <see cref="T:System.IO.Stream" />.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> containing file to load.</param>
            <example><code language="VB" source="ColorConversionVB/form1.vb#BitmapLoadFromStream"></code><code language="CS" source="ColorConversionCS/form1.cs#BitmapLoadFromStream"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LoadFromClipboard">
            <summary>Loads the bitmap from the clipboard.</summary>
            <remarks><para>If no bitmap is available in the bitmap, throws an exception.</para><para>To put the bitmap into the clipboard, you can use the <see cref="M:Aurigma.GraphicsMill.Bitmap.SaveToClipboard" /> method.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LoadFromHdc(System.IntPtr,System.Drawing.Rectangle)">
            <summary>Captures a bitmap from the specified device context.</summary>
            <param name="hdc">The handle to device context to grab the bitmap from.</param>
            <param name="rectangle">The rectangle on the window associated with this device context to grab from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LoadThumbnail(System.String,System.Int32,System.Int32)">
            <summary>Loads the thumbnail from specified file on-the-fly.</summary>
            <param name="fileName">Name of the file to load.</param>
            <param name="width">Width of the thumbnail bounding rectangle. You can pass 0 if you want method to find it automatically (see <b>Remarks</b> section for more details).</param>
            <param name="height">Height of the thumbnail bounding rectangle. You can pass 0 if you want method to find it automatically (see <b>Remarks</b> section for more details).</param>
            <remarks><para>
If multiframe file is loaded, thumbnail for the first frame is taken.
</para><para><i>Width</i> and <i>height</i> arguments specify a rectangle to fit the thumbnail in. If you omit one of these arguments (set to 0) it will be calculated automatically to preserve aspect ratio. You cannot specify both arguments to 0 at once.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#LoadingThumbnail1"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#LoadingThumbnail1"></code></example>
            <overloads><summary>Loads the thumbnail from specified file on-the-fly.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LoadThumbnail(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Loads the thumbnail from specified <see cref="T:System.IO.Stream" /> on-the-fly.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> containing file to load.</param>
            <param name="width">Width of the thumbnail bounding rectangle. You can pass 0 if you want method to find it automatically (see <b>Remarks</b> section for more details).</param>
            <param name="height">Height of the thumbnail bounding rectangle. You can pass 0 if you want method to find it automatically (see <b>Remarks</b> section for more details).</param>
            <remarks><para>
If multiframe file is loaded, thumbnail for the first frame is taken.
</para><para><i>Width</i> and <i>height</i> arguments specify a rectangle to fit the thumbnail in. If you omit one of these arguments (set to 0) it will be calculated automatically to preserve aspect ratio. You cannot specify both arguments to 0 at once.
</para></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#BitmapLoadThumbnailFromStream"></code><code language="CS" source="ColorConversionCS/form1.cs#BitmapLoadThumbnailFromStream"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LockBits" draft="yes">
            <summary>Locks a entire bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels.</returns>
            <remarks>This method returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> for all pixels of this bitmap. If you need to work only with a part of bitmap, you should use some overloaded method which takes a rectangle coordinates as arguments.</remarks>
            <example><code language="CS" source="LoadingAndSavingCS/form1.cs#DirectDataAccess"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" draft="yes">
            <summary>Locks a rectangular area of the bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary>
            <param name="left">X-coordinate of the top left corner of the rectangular area to lock.</param>
            <param name="top">Y-coordinate of the top left corner of the rectangular area to lock.</param>
            <param name="width">Width of the rectangular area to lock.</param>
            <param name="height">Height of the rectangular area to lock.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels.</returns>
            <remarks><para>
Each call of this method should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.
</para><para>
Rectangle parameters are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para><para>
If you want to load all pixels of the bitmap, you can use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits">overloaded version without arguments</see>.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#FullImageInfo"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#FullImageInfo"></code></example>
            <overloads><summary>Locks a rectangular area of the bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary><remarks><para>
Each call of this method should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.</para><note>If the specified rectangular area excides the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> dimensions you will get the <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object with the same dimensions as an initial <see cref="T:Aurigma.GraphicsMill.Bitmap" />. Therefore, to avoid further errors, you should use the <see cref="P:Aurigma.GraphicsMill.BitmapData.Width" /> and <see cref="P:Aurigma.GraphicsMill.BitmapData.Height" /> properties of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object instead of the specified rectangle dimensions.</note></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Single,System.Single,System.Single,System.Single)">
            <summary>Locks a rectangular area of the bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary>
            <param name="left">X-coordinate of the top left corner of the rectangular area to lock.</param>
            <param name="top">Y-coordinate of the top left corner of the rectangular area to lock.</param>
            <param name="width">Width of the rectangular area to lock.</param>
            <param name="height">Height of the rectangular area to lock.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels.</returns>
            <remarks><para>
Each call of this method should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.
</para><para>
Rectangle parameters are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para><para>
If you want to load all pixels of the bitmap, you can use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits">overloaded version without arguments</see>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Drawing.Rectangle)">
            <summary>Locks a rectangular area of the bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary>
            <param name="rectangle">The rectangular area to lock.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels.</returns>
            <remarks><para>
Each call of this method should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.
</para><para>
Rectangle parameters are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para><para>
If you want to load all pixels of the bitmap, you can use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits">overloaded version without arguments</see>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Drawing.RectangleF)">
            <summary>Locks a rectangular area of the bitmap and returns <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels (without copying).</summary>
            <param name="rectangle">The rectangular area to lock.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object which provides direct access to pixels.</returns>
            <remarks><para>
Each call of this method should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.
</para><para>
Rectangle parameters are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the source bitmap.
</para><para>
If you want to load all pixels of the bitmap, you can use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits">overloaded version without arguments</see>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.LogicalHeight">
            <summary>Returns current bitmap height in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</summary>
            <value>Height of the bitmap in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#ScaleWidthHeight"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#ScaleWidthHeight"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.LogicalWidth">
            <summary>Returns current bitmap width in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</summary>
            <value>Width of the bitmap in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#ScaleWidthHeight"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#ScaleWidthHeight"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.MaxUndoStepCount">
            <summary>Gets/sets maximum number of available undo steps (levels).</summary>
            <value>Maximum number of available undo steps (levels).</value>
            <remarks><para>Graphics Mill for .NET has internal bitmap changes stack. This property return maximum depth of this stack. Default value is 10.</para><note>
It is not recommended to specify too large values for this property until it is necessary indeed. Each stored bitmap state consumes a number of system resources (file handles, disk space), that's why if you specify large value and user make a big number of actions, it will take too much resources.</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.MemoryUsed">
            <summary>Returns a number of bytes occupied with pixels of this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <value>A number of bytes occupied with pixels of this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</value>
            <remarks>You can use this value to allocate a buffer which should hold a copy of pixels of this <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#MemoryUsed"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#MemoryUsed"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Modified">
            <summary>Indicates if the bitmap was changed since last saving.</summary>
            <value>Value indicating if the bitmap was changed since last saving.</value>
            <remarks><para>
It is set to <b>true</b> each time when <see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /> event fires.
</para><note>
This property is never set to <b>false</b> automatically. You should reset it to <b>false</b> yourself when necessary. You can do it for example, in <see cref="E:Aurigma.GraphicsMill.Bitmap.Saved" /> event handler.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance.</summary>
            <overloads><summary>Creates empty <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(Aurigma.GraphicsMill.Color,System.Int32,System.Int32,Aurigma.GraphicsMill.PixelFormat)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance of given dimensions and pixel format. Background  color is specified.</summary>
            <param name="background">Background color to fill the bitmap with.</param>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If you specify indexed pixel format, uninitialized palette will be generated. You must fill entries yourself. Palette will have maximum possible for given pixel format colors number (2 colors for 1-bit images, 16 colors for 4-bit images, and 256 colors for 8-bit images).</param>
            <remarks>If color space of the color does not fit color space of the pixel format, color is converted to necessary color space.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(Aurigma.GraphicsMill.Color,System.Int32,System.Int32,Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance of given dimensions and pixel format. Background  color is specified.</summary>
            <param name="background">Background color to fill the bitmap with.</param>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, <i>palette</i> is ignored.</param>
            <param name="palette">Palette attached to new bitmap. Note, this palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</param>
            <remarks>If color space of the color does not fit color space of the pixel format, color is converted to necessary color space.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance from 3D array of pixels.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels.</param>
            <param name="format">Pixel format of new bitmap.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance from 3D array of pixels and palette.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. Indexed pixel formats are treated as having single channel.</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, argument <i>palette</i> will be ignored. <note type="caution"><b>Format1bppIndexed</b> and <b>Format4bppIndexed</b> pixel formats are not supported as well as any other pixel format which is not aligned on byte.</note></param>
            <param name="palette">Palette attached to new bitmap. Note, this palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.PixelFormat)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance of given dimensions and pixel format.</summary>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If you specify indexed pixel format, uninitialized palette will be generated. You must fill entries yourself. Palette will have maximum possible for given pixel format colors number (2 colors for 1-bit images, 16 colors for 4-bit images, and 256 colors for 8-bit images).</param>
            <remarks>All pixel data are filled with 0. So if pixel format:
<list type="bullet"><item><term>
supports alpha channel
    </term><description>
image is fully transparent
    </description></item><item><term>
is RGB
    </term><description>
image is filled with black color
    </description></item><item><term>
is CMYK
    </term><description>
image is filled with white color
    </description></item><item><term>
is indexed
    </term><description>
image has color of the first palette entry
    </description></item></list></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#TextWithEffects1"></code><code language="CS" source="DrawingCS/form1.cs#TextWithEffects1"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance of given dimensions, pixel format and palette.</summary>
            <param name="width">Width of new bitmap (in pixels).</param>
            <param name="height">Height of new bitmap (in pixels).</param>
            <param name="format">Pixel format of new bitmap. If pixel format is not indexed, <i>palette</i> is ignored.</param>
            <param name="palette">Palette attached to new bitmap. <note type="caution">This palette object is binded to bitmap, not copied. It means that if you later change anything in palette object, changes will be reflected in the palette of bitmap.</note></param>
            <remarks>All pixel data are filled with 0. So if pixel format:
<list type="bullet"><item><term>
supports alpha channel
    </term><description>
image is fully transparent
    </description></item><item><term>
is RGB
    </term><description>
image is filled with black color
    </description></item><item><term>
is CMYK
    </term><description>
image is filled with white color
    </description></item><item><term>
is indexed
    </term><description>
image has color of the first palette entry
    </description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.String)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance and loads image from specified file.</summary>
            <param name="fileName">Name of the file to load.</param>
            <remarks>If multiframe file is loaded, first frame is taken.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Drawing.Bitmap)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance instance and initializes it by copying bitmap data of specified <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> object.</summary>
            <param name="bitmap"><see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> class instance which is being copied into current <see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see>.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.IO.Stream)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance instance and loads image from specified <see cref="T:System.IO.Stream" />.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> containing file to load.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.op_Implicit(Aurigma.GraphicsMill.Bitmap)~System.Drawing.Bitmap" draft="yes">
            <summary>Cast this instance of the <see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see> to <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see>.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see> instance to cast.</param>
            <returns>Brush casted to <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see>.</returns>
            <overloads><summary>Cast this instance of the <see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see> to <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.op_Implicit(System.Drawing.Bitmap)~Aurigma.GraphicsMill.Bitmap" draft="yes">
            <summary>Cast an instance of the <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> to <see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see>.</summary>
            <param name="bitmap"><see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> instance to cast.</param>
            <returns>Brush casted to <see cref="T:Aurigma.GraphicsMill.Bitmap">Aurigma.GraphicsMill.Bitmap</see>.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Palette">
            <summary>Returns palette accosiated with bitmap.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> associated with bitmap.</value>
            <remarks>Palette makes sense only for indexed bitmaps. No palette is returned if pixel format of the bitmap is not indexed.
<para>
Once palette is attached to the bitmap (either in constructor or during color conversion), you cannot change entries number as well as attach another palette. In this case you need to initiate color conversion one more time. However it is not necessary if you need just modify values of palette entries.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.PixelFormat">
            <summary>Returns pixel format of the current bitmap.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value specifying the pixel format of the current bitmap.</value>
            <remarks>You can use the following properties to get more detailed information about current pixel format:
<list type="table"><listheader><term>Property</term><description>Description</description></listheader><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.BitsPerPixel" /></term><description>Number of bits per pixel used by this pixel format.</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.ColorSpace" /></term><description>Color space of pixels represented with current pixel format.</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.HasAlpha" /></term><description>Whether current pixel format supports alpha channel (transparency information).</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.IsCmyk" /></term><description>Whether color space of pixels represented with current pixel format is CMYK.</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.IsRgb" /></term><description>Whether color space of pixels represented with current pixel format is RGB.</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.IsGrayScale" /></term><description>Whether color space of pixels represented with current pixel format is grayscale.</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.IsExtended" /></term><description>Whether current pixel format is extended (16 bits per channel).</description></item><item><term><see cref="P:Aurigma.GraphicsMill.Bitmap.IsIndexed" /></term><description>Whether current pixel format is indexed (palette-based).</description></item></list></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Progress">
            <summary>Fires on progress notifications of the currently applied operation.</summary>
            <remarks><para>
This event is fired only if you run the operations through build-in methods or properties. If you create external transform or codec and run it, this event will not fire (in this case you should use <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Progress" /> event of the transform or codec you create).
</para><para>
As all operation which run through built-in methods and properties of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> are working in synchronous mode, you can safely use <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Current" /> and <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum" /> arguments to update progress bar.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Changed(System.Object,Aurigma.GraphicsMill.BitmapChangedEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Changing(System.Object,Aurigma.GraphicsMill.BitmapChangingEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Progress(System.Object,Aurigma.GraphicsMill.ProgressEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Redoing(System.Object,Aurigma.GraphicsMill.StateRestoringEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Redone(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Saved(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Saving(System.Object,Aurigma.GraphicsMill.BitmapSavingEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_StateRestored(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Undoing(System.Object,Aurigma.GraphicsMill.StateRestoringEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.raise_Undone(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Redo" draft="yes">
            <summary>Redoes last undone change.</summary>
            <remarks>This method can be used only if you already called <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method. If no undone states are available this method will fail. You can check this with <see cref="P:Aurigma.GraphicsMill.Bitmap.CanRedo" /> property.
<note>
When you call this method, events <see cref="E:Aurigma.GraphicsMill.Bitmap.Redoing" />/<see cref="E:Aurigma.GraphicsMill.Bitmap.Redone" /> fires instead of <see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" />/<see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" />.
</note></remarks>
            <overloads><summary>Redoes last undone change.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Redo(System.Int32)">
            <summary>Redoes specified number of last undone actions.</summary>
            <param name="redoSteps">Number of steps to redo.</param>
            <remarks>If <i>steps</i> argument is larger than number of steps available to redo, method will fail. To avoid this, use <see cref="P:Aurigma.GraphicsMill.Bitmap.RedoStepCount" /> property to check how much steps are left.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Redoing">
            <summary>Fires when image is being redone (before starting).</summary>
            <remarks>You can cancel redoing from this event by setting <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Cancel" /> argument to <b>false</b>. To get information what action is redone, use argument <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Change" />.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Redone">
            <summary>Fires when operation has been redone (after finishing).</summary>
            <remarks>To get information what action has been redone, use argument <see cref="P:Aurigma.GraphicsMill.BitmapChangedEventArgs.Change" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.RedoStepCount">
            <summary>Returns number of available redo levels (i.e. how much time method <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> can be called).</summary>
            <value>Number of available redo steps (levels).</value>
            <remarks><para>Graphics Mill for .NET has internal bitmap changes stack. This property return the distance from the current stack position to the stack top.</para><para>If you try to pass to <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo(System.Int32)" /> method value which is larger than this property, exception will be raised.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Save(System.String)">
            <summary>Saves the bitmap into specified file.</summary>
            <param name="fileName">The name of the target file.</param>
            <remarks><para>
This method analyzes a file extension to determine what file format to save to. If extention is unknown, method fails (exception is thrown). 
</para><para>
This method does not support retrieving any encoder settings. If you need retrieve any settings, use <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)">this overloaded method</see> instead. 
</para><para>
Using this method is the same as creating appropriate writer derived from <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> and running it in synchronous mode.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Saving1"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Saving1"></code></example>
            <overloads><summary>Saves the bitmap into specified file.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Saves the bitmap into specified file.</summary>
            <param name="fileName">The name of the target file.</param>
            <param name="options">An object containing encoder settings.</param>
            <remarks><para>
This method determines from encoder options (regardless to the file extension). 
</para><para>
Using this method is the same as creating appropriate writer derived from <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> and running it in synchronous mode.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Saving2"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Saving2"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Save(System.IO.Stream,Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Saves the bitmap into specified <see cref="T:System.IO.Stream" />.</summary>
            <param name="stream">The target <see cref="T:System.IO.Stream" />.</param>
            <param name="options">An object containing encoder settings.</param>
            <remarks><para>
Using this method is the same as creating appropriate writer derived from <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> and running it in synchronous mode.
</para></remarks>
            <example><code language="VB" source="GraphicsMillVB/WorkWithStreams1.aspx"></code><code language="CS" source="GraphicsMillCS/WorkWithStreams1.aspx"></code></example>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Saved">
            <summary>Fires when the image has been saved (after finishing).</summary>
            <remarks><para>
This event is fired only if you run the operations through build-in methods or properties. If you create external <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> descendant class and run it, this event will not fire (in this case you should use <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Stopped" /> event of this writer).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.SaveState">
            <summary>Saves state of the object.</summary>
            <remarks>After you save the object state, you can revert to it using <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.SaveToClipboard">
            <summary>Saves the bitmap into the clipboard.</summary>
            <remarks><para>To load the bitmap from the clipboard, use the <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadFromClipboard" /> method.</para><note>The copy of the bitmap is converted into the format which is supported by Windows so that other applications (e.g. MS PaintBrush) could load it. It means that if the bitmap has some non-standard pixel format (e.g. CMYK), it is automatically converted to 24-bit RGB. Therefore when you load the bitmap back from buffer using <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadFromClipboard" /> method, it may have another pixel format.</note></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Saving">
            <summary>Fires when image is being saved (before starting).</summary>
            <remarks><para>
This event can be used to place encoder options initialization at the single place. For example, here you can display encoder options dialog and then initialize encoder options using <see cref="P:Aurigma.GraphicsMill.BitmapSavingEventArgs.Options" /> argument passed to this event. You also can cancel saving by setting <see cref="P:Aurigma.GraphicsMill.BitmapSavingEventArgs.Cancel" /> argument to <b>false</b>.
</para><para>
This event is fired only if you run the operations through build-in methods or properties. If you create external <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> descendant class and run it, this event will not fire (in this case you should use <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Starting" /> event of this writer).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Serialize(System.IO.Stream)">
            <summary>Serializes the bitmap object.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> which will keep the serialized data.</param>
            <remarks><para>To restore the bitmap object from the serialization data, use the <see cref="M:Aurigma.GraphicsMill.Bitmap.Deserialize(System.IO.Stream)" /> method.</para><para>You can enable or disable the compression of the serialization data by using the <see cref="P:Aurigma.GraphicsMill.Bitmap.CompressSerializedData" /> property. It is recommended to use compression only if you transfer the serialization data through the network (or if the size is critical for any other reason). Otherwise it can noticeable reduce the serialization/deserialization process performance.</para><note>This method closes the specified <see cref="T:System.IO.Stream" /> after serialization.</note></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Bitmap.CompressSerializedData" />
<seealso cref="M:Aurigma.GraphicsMill.Bitmap.Deserialize(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.SetHorizontalResolution(System.Single)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.SetPixel(System.Int32,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Sets pixel value at the specified coordinates.</summary>
            <param name="x">Horizontal position of the pixel.</param>
            <param name="y">Vertical position of the pixel.</param>
            <param name="color">Color value to put into the bitmap at specified coordinates. It is recommended to make sure that this object has the same color space as the bitmap itself. If color spaces are not match (e.g. bitmap is CMYK and this color is RGB), color will be automatically converted, but no color management will be applied.</param>
            <remarks><para>This method was implemented for easy but slow access to pixels. It works ideally if you need to set one pixel value, for example, when you implement pencil tool. However if you need iterate each pixel in bitmap, it will work too slow. In this case you should consider using <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits" /> method instead. <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits" /> will provide you a direct access to pixels.</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#Pixels"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Pixels"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.SetVerticalResolution(System.Single)">
            <exclude />
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.StateRestored">
            <summary>Fires when the bitmap state is restored (redone or undone).</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Statistics">
            <summary>Returns an object providing methods which retrieves bitmap stats (like histogram, etc).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.BitmapStatisticsProvider" /> object providing methods which retrieves bitmap stats.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.ToGdiplusBitmap">
            <summary>Returns <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> containing a copy of the image stored in current <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance.</summary>
            <returns><see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> containing a copy of the image stored in current <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance.</returns>
            <remarks>This method returns a copy of the image. If you need to have a <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> which references to the same bitmap data as the current <see cref="T:Aurigma.GraphicsMill.Bitmap" />, you should use <see cref="M:Aurigma.GraphicsMill.Bitmap.ToGdiplusBitmapDirectly" /> method instead.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.ToGdiplusBitmapDirectly">
            <summary>Returns <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> which references to the same bitmap data as the current <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance.</summary>
            <returns><see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> which references to the same bitmap data as the current <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance.</returns>
            <remarks>If you need to get a copy of current <see cref="T:System.Drawing.Bitmap">System.Drawing.Bitmap</see> (which is detached from the bitmap data of this image), use <see cref="M:Aurigma.GraphicsMill.Bitmap.ToGdiplusBitmap" /> method instead.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Transforms">
            <summary>Returns object providing methods which are responsible for geometric transformations of the bitmap (resize, rotate, crop, swirl, etc).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.TransformsProvider" /> class instance containing methods which are responsible for geometric transformations of the bitmap.</value>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Resize1Bitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Resize1Bitmap"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Undo" draft="yes">
            <summary>Undoes last made change.</summary>
            <remarks>This method can be used only if you have saved object state at least once (using method <see cref="M:Aurigma.GraphicsMill.Bitmap.SaveState" />). If no states to undo are available, method will fail. You can check this with <see cref="P:Aurigma.GraphicsMill.Bitmap.CanUndo" /> property.
<note>
When you call this method, events <see cref="E:Aurigma.GraphicsMill.Bitmap.Undoing" />/<see cref="E:Aurigma.GraphicsMill.Bitmap.Undone" /> fires instead of <see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" />/<see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" />.
</note></remarks>
            <overloads><summary>Undoes last made change.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Undo(System.Int32)">
            <summary>Undoes specified number of last changes.</summary>
            <param name="undoSteps">Number of steps to undo.</param>
            <remarks>If <i>steps</i> argument is larger than number of steps available to undo, method will fail. To avoid this, use <see cref="P:Aurigma.GraphicsMill.Bitmap.UndoStepCount" /> property to check how much steps are left.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Undoing">
            <summary>Fires when image is being undone (before starting).</summary>
            <remarks>You can cancel undoing from this event by setting <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Cancel" /> argument to <b>false</b>. To get information what action is being undone, use argument <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Change" />.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.Bitmap.Undone">
            <summary>Fires when operation has been undone (after finishing).</summary>
            <remarks>To get information what action has been undone, use argument <see cref="P:Aurigma.GraphicsMill.BitmapChangedEventArgs.Change" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.UndoRedoEnabled">
            <summary>Enables or disables undo/redo functionality.</summary>
            <value>Value specifying if to enable undo/redo functionality.</value>
            <remarks><para>
You can use this property to disable undo/redo functionality for some time. It is useful when, for example, you apply some set of effects or draw a number of shapes as single atomic operation. In this case you likely do not want to undo sub-operations, but need to undo entire operation at once. For example, you draw a star (with several calls of <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" /> method). Your actions should be the following:
</para><list type="number"><item><description>Set this property to <b>false</b>.</description></item><item><description>Draw a star by attaching this <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. Draw attention, although event <see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /> fires, bitmap state is not stored.</description></item><item><description>After you finish, set this property back to <b>true</b>.</description></item><item><description>Save the result state with <see cref="M:Aurigma.GraphicsMill.Bitmap.SaveState" /> method. </description></item></list><para>
After this you can call <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method and entire star is erased instead of single line you draw last time.
</para><para>
By default this property is <b>true</b>. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.UndoRedoTrackingEnabled" draft="yes">
            <summary>Enables or disables the automatic change tracking.</summary>
            <value>A value specifying whether the automatic change tracking should be enabled or not.</value>
            <remarks><para>If this property is set to <b>false</b>, the undo/redo functionality will be available, but you will have to manually save states to which the content can be reverted (using the <see cref="M:Aurigma.GraphicsMill.Bitmap.SaveState" /> method).</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.UndoStepCount">
            <summary>Returns number of available undo levels (i.e. how much time method <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> can be called).</summary>
            <value>Number of available undo steps (levels).</value>
            <remarks><para>Graphics Mill for .NET has internal bitmap changes stack. This property return the distance from the current stack position to the stack bottom.</para><para>If you try to pass to <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo(System.Int32)" /> method value which is larger than this property, exception will be raised.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.Unload">
            <summary>Unloads bitmap data.</summary>
            <remarks>May be used to reduce memory burden without destroying Bitmap instance.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)">
            <summary>Unlocks previously locked area of bitmap with <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> object previously returned with <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</param>
            <remarks><para>
Each call of <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> should be followed with subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method call. You cannot lock bits one more time until you unlock them with this method. You can check if bits are locked with <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> property.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Bitmap.Width">
            <summary>Returns current bitmap width in pixels.</summary>
            <value>Width of the bitmap in pixels.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#WidthHeight"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#WidthHeight"></code></example>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapChange">
            <summary>Contains possible values that describe a reason of bitmap change in <see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /> and <see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" /> events.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.AddNoise">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.AdjustHsl">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ApplyLut">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ApplyMatrixTransform">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Blur">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Brightness">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.BrightnessContrast">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Buttonize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ChannelBalance">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ColorSpace">
            <summary>Bitmap changed due pixel format conversion (using <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> transform).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Combine">
            <summary>Bitmap changed due combining with another bitmap (using <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> transform).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Contrast">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.CreateNew">
            <summary>Bitmap was emptied and created anew (with <see cref="M:Aurigma.GraphicsMill.Bitmap.Create(System.Single,System.Single,Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Crop">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Curves">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Custom">
            <summary>Bitmap was changed because of some custom effect. You can use this value when you implement your own effect and raise the <see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /> and <see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" /> events.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Cylindrize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Deserialize">
            <summary>Bitmap has been deserialized.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Draw">
            <summary>Something was drawn on the bitmap (e.g. line, rectangle, etc).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.EdgeDetect">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Emboss">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.FloodFill">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Glow">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.HistogramEqualize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ImportData">
            <summary>Bitmap data was imported from array (using <see cref="M:Aurigma.GraphicsMill.Bitmap.Import(System.Int32[0:,0:,0:])" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Invert">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Invert" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Levels">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Load">
            <summary>Bitmap data was loaded from file or any other source (using <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.LoadThumbnail">
            <summary>Thumbnail was loaded from file or any other source (using <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadThumbnail(System.String,System.Int32,System.Int32)" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.MaximumFilter">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.MedianFilter">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.MinimumFilter">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Mosaic">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.PageCurl">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Redo">
            <summary>Previously undone bitmap modification was redone (using <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.ReplaceChannel">
            <summary>Some bitmap channel was replaced.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Resize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Rotate">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.RotateAndFlip">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Shadow">
            <summary>Bitmap changed by <see cref="M:Aurigma.GraphicsMill.Bitmap.Redo" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Sharpen">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Solarize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Solarize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Spray">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.SwapChannels">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Swirl">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Texturize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Transparentize">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Undo">
            <summary>Bitmap modification was undone (using <see cref="M:Aurigma.GraphicsMill.Bitmap.Undo" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Unload">
            <summary>Bitmap data has been unloaded with  <see cref="M:Aurigma.GraphicsMill.Bitmap.Unload" /> method.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.UnsharpMask">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Waddle">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.WaterDrop">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.BitmapChange.Wave">
            <summary>Bitmap changed by <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> transform.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapChangedEventArgs">
            <summary>Provides data for post-changing events of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.</summary>
            <remarks><para>
This class is used by such events as:
</para><list type="bullet"><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Redone" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Undone" /></description></item></list><para>
This class contains single property <see cref="P:Aurigma.GraphicsMill.BitmapChangedEventArgs.Change" /> which specifies what action did change the bitmap. All possible change actions are described with <see cref="T:Aurigma.GraphicsMill.BitmapChange" /> enumeration.
</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapChangedEventArgs.Change">
            <summary>Indicates an action which caused bitmap changing.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.BitmapChange" /> value indicating an action which caused bitmap changing.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapChangedEventArgs.#ctor(Aurigma.GraphicsMill.BitmapChange)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.BitmapChangedEventArgs" /> object.</summary>
            <param name="change"><see cref="T:Aurigma.GraphicsMill.BitmapChange" /> value indicating an action which caused bitmap changing.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapChangedEventHandler" draft="yes">
            <summary>This delegate represents the method that will handle <see cref="T:Aurigma.GraphicsMill.Bitmap" /> post-changing events.</summary>
            <remarks><para>
This delegate is used with such events as:
</para><list type="bullet"><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Changed" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Redone" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Undone" /></description></item></list><para>
This class contains single property <see cref="P:Aurigma.GraphicsMill.BitmapChangedEventArgs.Change" /> which specifies what action did change the bitmap. All possible change actions are described with <see cref="T:Aurigma.GraphicsMill.BitmapChange" /> enumeration.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapChangingEventArgs">
            <summary>Provides data for pre-changing events of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.</summary>
            <remarks><para>
This class is used by such events as:
</para><list type="bullet"><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Redoing" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Undoing" /></description></item></list><para>
This class contains property <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Change" /> which specifies what action did change the bitmap. All possible change actions are described with <see cref="T:Aurigma.GraphicsMill.BitmapChange" /> enumeration. Using property <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Cancel" /> you can cancel operation before it is being started.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Cancel">
            <summary>Sets a value specifying if to cancel the operation before it will be started.</summary>
            <value>Value specifying if to cancel the operation before it will be started.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Change">
            <summary>Indicates an action which caused bitmap changing.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.BitmapChange" /> value indicating an action which caused bitmap changing.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapChangingEventArgs.#ctor(Aurigma.GraphicsMill.BitmapChange)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.BitmapChangingEventArgs" /> object.</summary>
            <param name="change"><see cref="T:Aurigma.GraphicsMill.BitmapChange" /> value indicating an action which caused bitmap changing.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapChangingEventHandler">
            <summary>This delegate represents the method that will handle <see cref="T:Aurigma.GraphicsMill.Bitmap" /> pre-changing events.</summary>
            <remarks><para>
This class is used with such events as:
</para><list type="bullet"><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Changing" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Redoing" /></description></item><item><description><see cref="E:Aurigma.GraphicsMill.Bitmap.Undoing" /></description></item></list><para>
This class contains property <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Change" /> which specifies what action did change the bitmap. All possible change actions are described with <see cref="T:Aurigma.GraphicsMill.BitmapChange" /> enumeration. Using property <see cref="P:Aurigma.GraphicsMill.BitmapChangingEventArgs.Cancel" /> you can cancel operation before it is being started.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapData">
            <summary>This class provides direct access to the bitmap pixels.</summary>
            <remarks><para>
To get this class instance you should use <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> method. After you get it, you can work with this bitmap bits directly. Property <see cref="P:Aurigma.GraphicsMill.BitmapData.Scan0" /> returns an address to the beginning of the bitmap (the very first pixel). Property <see cref="P:Aurigma.GraphicsMill.BitmapData.Stride" /> holds the offset from the beginning of the row (scan line) to the next row. Property <see cref="P:Aurigma.GraphicsMill.BitmapData.Height" /> contains number of scan lines in the section you lock. Using <see cref="P:Aurigma.GraphicsMill.BitmapData.PixelFormat" /> you can get pixel-specific information. If you need to know how much bytes is taken by the captured area (for example, if you need to allocate buffer of the same size), you can use <see cref="P:Aurigma.GraphicsMill.BitmapData.MemoryUsed" /> property.
</para><para>
If you need you also have an access to the bitmap associated with this bitmap data via <see cref="P:Aurigma.GraphicsMill.BitmapData.Bitmap" /> property. The parameters of the bitmap area you captured are available through <see cref="P:Aurigma.GraphicsMill.BitmapData.Left" />, <see cref="P:Aurigma.GraphicsMill.BitmapData.Top" />, <see cref="P:Aurigma.GraphicsMill.BitmapData.Width" /> and <see cref="P:Aurigma.GraphicsMill.BitmapData.Height" /> properties.
</para><para>
After you finished working with the the bitmap data, you should release it by calling <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" /> method.
</para></remarks>
            <example><code language="CS" source="LoadingAndSavingCS/form1.cs#DirectDataAccess"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Bitmap">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Bitmap" /> associated with this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance associated with this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.BitsPerPixel">
            <summary>Returns number of bits per pixel for current <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <value>Number of bits per pixel for current <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</value>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#BitsPerPixel"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#BitsPerPixel"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.ColorSpace">
            <summary>Indicates the color space of the current <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value specifying color space of the current bitmap.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Export">
            <summary>Returns a copy of pixel data as 3D array.</summary>
            <returns>Array of image pixels returned in the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.GetEmptyMask">
            <summary>Returns grayscale image of the same size as current bitmap data filled with black color. It can be used as mask template for transforms.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object which can be used as a template for a mask for using transforms on current bitmap data.</returns>
            <remarks>Using this method you can get a template for a mask. Initially it is filled with black pixels (i.e. mask is absolutely transparent). After that you draw something on this mask (white color means opaque areas) and use it with transforms derived from <see cref="T:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform" /> class.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.GetPixel(System.Int32,System.Int32)">
            <summary>Returns pixel value at specified coordinates.</summary>
            <param name="x">Horizontal position of the pixel.</param>
            <param name="y">Vertical position of the pixel.</param>
            <returns>Pixel value at the specified position. The actual type of the returned object depends on color space of the bitmap. E.g. if bitmap is in RGB color space, actual type will be <see cref="T:Aurigma.GraphicsMill.RgbColor" />, etc.</returns>
            <remarks><para>This method was implemented for easy but slow access to pixels. It works ideally if you need to get one pixel value, for example, when you implement color picker. However if you need iterate each pixel in bitmap, it will work too slow. In this case you should consider using <see cref="P:Aurigma.GraphicsMill.BitmapData.Scan0" /> property instead. This property provides you a direct access to pixels.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Height">
            <summary>Returns a height of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> (a number of scan lines).</summary>
            <value>A height of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> (a number of scan lines).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Import(System.Int32[0:,0:,0:])">
            <summary>Fills the pixels of the current <see cref="T:Aurigma.GraphicsMill.BitmapData" /> object from given 3D array.</summary>
            <param name="array">Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. <note type="caution">Array width, height, and channel number must conform current bitmap data dimensions and pixel format.</note></param>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Left">
            <summary>Returns X-coordinate of the left top corner of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> relatively parent <see cref="P:Aurigma.GraphicsMill.BitmapData.Bitmap" />.</summary>
            <value>X-coordinate of the left top corner of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> relatively parent <see cref="P:Aurigma.GraphicsMill.BitmapData.Bitmap" />.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Lock">
            <summary>Locks the object.</summary>
            <remarks><para>
After calling this method this object is not accessible from any other thread (until <see cref="M:Aurigma.GraphicsMill.BitmapData.Unlock" /> is called). You can safely check <see cref="P:Aurigma.GraphicsMill.ILockable.Locked" /> property to ensure if object is locked.
</para><para>
When you access the object which has been locked, the thread stops and waits until it become unlocked. Using property <see cref="P:Aurigma.GraphicsMill.ILockable.Timeout" /> you can specify how much time to wait.
</para><note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" />/<see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.MemoryUsed">
            <summary>Returns a number of bytes occupied with pixels of this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <value>A number of bytes occupied with pixels of this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</value>
            <remarks>You can use this value to allocate a buffer which should hold a copy of pixels of this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.PixelFormat">
            <summary>Returns pixel format of the current bitmap data.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> values specifying the pixel format of the current bitmap data.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.SaveToClipboard">
            <summary>Saves the bitmap into the clipboard.</summary>
            <remarks><para>
  To load the bitmap from the clipboard, use the <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadFromClipboard" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.
</para><note>
  The copy of the bitmap is converted into the format which is supported by Windows so that other applications (e.g. MS PaintBrush) could load it. It means that if the bitmap has some non-standard pixel format (e.g. CMYK), it is automatically converted to 24-bit RGB. Therefore when you load the bitmap back from buffer using <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadFromClipboard" /> method, it may have another pixel format.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Scan0">
            <summary>Returns the pointer to the very first pixel of this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</summary>
            <value>The address of the first pixel of this <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</value>
            <example><code language="CS" source="LoadingAndSavingCS/form1.cs#DirectDataAccess"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.SetPixel(System.Int32,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Sets pixel value at the specified coordinates.</summary>
            <param name="x">Horizontal position of the pixel.</param>
            <param name="y">Vertical position of the pixel.</param>
            <param name="color">Color value to put into the bitmap at specified coordinates. It is recommended to make sure that this object has the same color space as the bitmap itself. If color spaces are not match (e.g. bitmap is CMYK and this color is RGB), color will be automatically converted, but no color management will be applied.</param>
            <remarks><para>
  This method was implemented for easy but slow access to pixels. It works ideally if you need to set one pixel value, for example, when you implement pencil tool. However if you need iterate each pixel in bitmap, it will work too slow. In this case you should consider using <see cref="P:Aurigma.GraphicsMill.BitmapData.Scan0" /> property instead. This property provides you a direct access to pixels.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Stride">
            <summary>Returns the bitmap data stride (scan line width in bytes).</summary>
            <value>Scan line width in bytes.</value>
            <remarks>Since <see cref="P:Aurigma.GraphicsMill.BitmapData.Width" /> property specifies number of pixels in single scan line, this property contains number of bytes in a scan line. As scan line may be aligned on four-bytes boundary, stride may differ from bitmap data width multiplied on number of bytes per pixel. That's why you should use this property to move to the same position on the next row instead of any other methods.</remarks>
            <example><code language="CS" source="LoadingAndSavingCS/form1.cs#DirectDataAccess"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Top">
            <summary>Returns Y-coordinate of the left top corner of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> relatively parent <see cref="P:Aurigma.GraphicsMill.BitmapData.Bitmap" />.</summary>
            <value>Y-coordinate of the left top corner of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> relatively parent <see cref="P:Aurigma.GraphicsMill.BitmapData.Bitmap" />.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapData.Unlock">
            <summary>Unlocks the object previously locked with method <see cref="M:Aurigma.GraphicsMill.BitmapData.Lock" />.</summary>
            <remarks>Every time you call method <see cref="M:Aurigma.GraphicsMill.BitmapData.Lock" /> object becomes unavailable until you call this method (the threads which access locked object are stopped until unlocking). That's why it is extremely important to call this method when you finished working with the object.
<note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" />/<see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapData.Width">
            <summary>Returns a width of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> (in pixels).</summary>
            <value>A width of this <see cref="T:Aurigma.GraphicsMill.BitmapData" /> (in pixels).</value>
            <remarks>This value holds number of pixels stored in a single scan line. To obtain number of bytes occupied with the single scan line, use property <see cref="P:Aurigma.GraphicsMill.BitmapData.Stride" />.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapDataProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapEmptyException">
            <summary>The exception which is thrown when you try to manipulate with empty bitmap (which has not any data loaded yet).</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapEmptyException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.BitmapEmptyException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.BitmapEmptyException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapEmptyException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.BitmapEmptyException" /> class with a specified error message.</summary>
            <param name="name">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapEmptyException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.BitmapEmptyException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapEmptyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapLockedException">
            <summary>The exception which is thrown when you try to access the bitmap pixel data which has been locked with <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</summary>
            <remarks><para>
To avoid getting this exception, you can use <see cref="P:Aurigma.GraphicsMill.Bitmap.BitsLocked" /> to check if <see cref="M:Aurigma.GraphicsMill.Bitmap.LockBits(System.Int32,System.Int32,System.Int32,System.Int32)" /> was called without subsequent <see cref="M:Aurigma.GraphicsMill.Bitmap.UnlockBits(Aurigma.GraphicsMill.BitmapData)" />.
</para><note>
This exception is never thrown when object is locked with <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" /> method which is used to provide thread safety of the operations. It is raised only when bitmap bits are locked.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapLockedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.BitmapLockedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.BitmapLockedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapLockedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.BitmapLockedException" /> class with a specified error message.</summary>
            <param name="name">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapLockedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.BitmapLockedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapLockedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapSavingEventArgs">
            <summary>Provides data for <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapSavingEventArgs.Cancel">
            <summary>Sets a value specifying if to cancel the bitmap saving before it will be started.</summary>
            <value>Value specifying if to cancel the bitmap saving before it will be started.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapSavingEventArgs.#ctor(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.BitmapSavingEventArgs" /> object.</summary>
            <param name="options">An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which provides access to the encoder options used for bitmap saving.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapSavingEventArgs.Options">
            <summary>Provides access to encoder options passed to <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method (may be changed in the <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event handler).</summary>
            <value>An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which provides access to the encoder options used for bitmap saving.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapSavingEventHandler">
            <summary>This delegate represents the method that will handle <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.BitmapStatisticsProvider">
            <summary>This class contains methods used by <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to retrieve various bitmap statistics.</summary>
            <remarks>Main feature of this class is possibility to calculate bitmap histogram. Histogram is an array of values that specify how much pixels has a luminosity (or other value that specifies pixel brightness level) equal to appropriate array index. It can be either calculated as histogram of bitmap luminosity (<see cref="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetLuminosityHistogram" /> method), or histogram of the channels sum (<see cref="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetSumHistogram(System.Boolean)" /> method). Last method is used in Adobe Photoshop by default.</remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.BitmapStatisticsProvider" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.BitmapStatisticsProvider" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetLuminosityHistogram">
            <summary>Calculates and returns a histogram built from the bitmap luminosity.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance that contains luminosity histogram of this bitmap.</returns>
            <remarks><para>
This histogram is equivalent to the histogram built from the same bitmap converted to grayscale.
</para></remarks>
            <overloads><summary>Calculates and returns a histogram built from the bitmap luminosity.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetSumHistogram(System.Boolean[])" draft="yes">
            <summary>Calculates and returns a histogram built from the sum of each channel luminosities of the pixel. You can exclude some channels from this sum.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, calculation will be done for the channel with appropriate index. Otherwise this channel is skipped.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance that contains sum histogram of this bitmap.</returns>
            <remarks><para>
This histogram type is used in Adobe Photoshop.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
            <overloads><summary>Calculates and returns a histogram.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetSumHistogram(System.Boolean)">
            <summary>Calculates and returns a histogram built from the sum of each channel luminosities of the pixel. You can include or exclude alpha channel from this sum.</summary>
            <param name="useAlpha">Flag that specify whether to include alpha channel into the histogram calculation.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance that contains sum histogram of this bitmap.</returns>
            <remarks><para>
This histogram type is used in Adobe Photoshop.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.BitmapStatisticsProvider.GetSumHistogram(System.Int32)">
            <summary>Calculates and returns a histogram built from luminosity of the single channel of the pixel.</summary>
            <param name="channel">A channel number to build histogram for.</param>
            <returns>An array which contains bitmap histogram.</returns>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.BitmapStatisticsProvider.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.ChannelsProvider" draft="yes">
            <summary>This class contains methods and properties used by <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to provide access to bitmap channels.</summary>
            <remarks>This class enables you to extract bitmap channels to separate grayscale image, or replace some channel with another grayscale bitmap. You can do that using <see cref="P:Aurigma.GraphicsMill.ChannelsProvider.Channel(System.Int32)" /> method. Here you can add alpha channel (<see cref="M:Aurigma.GraphicsMill.ChannelsProvider.AddAlpha(System.Single)" /> method) or remove it (<see cref="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha(Aurigma.GraphicsMill.Color)" /> method). Using <see cref="M:Aurigma.GraphicsMill.ChannelsProvider.Transparentize(Aurigma.GraphicsMill.Color,System.Single)" /> method you can make alpha channel transparent at the areas with specified color.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.AddAlpha(System.Single)" draft="yes">
            <summary>Appends alpha channel to current bitmap.</summary>
            <param name="opacity">Opacity value to initialize alpha channel with. Valid values are in range [0, 1]. Depending on channel bit depth this value is normalized to 255 (for non-extended 8 bits per channel pixel formats) or to 65535 (for extended 16 bits per channel pixel formats).</param>
            <remarks>If alpha channel is already presented in the bitmap, this method will throw an exception. To check if alpha channel is available, use <see cref="P:Aurigma.GraphicsMill.Bitmap.HasAlpha" /> property of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AddAlpha"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AddAlpha"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.AddAlpha(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Appends bitmap alpha channel to current bitmap.</summary>
            <param name="alpha">Grayscale bitmap to initialize alpha channel with. Valid bitmaps have the same dimensions and color depth as the current bitmap.</param>
            <remarks>If alpha channel is already presented in the bitmap, this method will throw an exception. To check if alpha channel is available, use <see cref="P:Aurigma.GraphicsMill.Bitmap.HasAlpha" /> property of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</remarks>
        </member>		
        <member name="P:Aurigma.GraphicsMill.ChannelsProvider.AlphaChannelIndex">
            <summary>Returns an index of the alpha channel.</summary>
            <value>A number which specifies an index of the alpha channel for the current bitmap.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ChannelsProvider.Channel(Aurigma.GraphicsMill.ColorChannel)" draft="yes">
            <summary>Extracts/replaces specified bitmap channel to/with grayscale <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <param name="colorChannel"><see cref="T:Aurigma.GraphicsMill.ColorChannel" /> value specifying an alias of channel to retrieve. Draw attention, it does not check color space, so if you pass, say, <see cref="F:Aurigma.GraphicsMill.ColorChannel.Yellow" /> to RGB color, you will get a channel stored at the same index as yellow in CMYK (i.e. <see cref="F:Aurigma.GraphicsMill.ColorChannel.Green" />).</param>
            <value><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance specifying a bitmap channel. It always has the same dimensions as source bitmap and its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> (if source bitmap is not extended) or <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format16bppGrayScale" /> (if source bitmap is extended).</value>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Extract"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Extract"></code><code language="VB" source="ApplyingEffectsVB/form1.vb#Replace"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Replace"></code></example>
            <overloads><summary>Extracts/replaces specified bitmap channel to/with grayscale <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.ChannelsProvider.Channel(System.Int32)">
            <summary>Extracts/replaces specified bitmap channel to/with grayscale <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <param name="channelIndex">Number of channel to work with.</param>
            <value><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance specifying a bitmap channel. It always has the same dimensions as source bitmap and its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> (if source bitmap is not extended) or <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format16bppGrayScale" /> (if source bitmap is extended).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ChannelsProvider.Count">
            <summary>Returns number of channels available in current bitmap.</summary>
            <value>Number of channels available in current bitmap.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha">
            <summary>Removes alpha channel from the current bitmap. Alpha channel is just discarded without affecting other channels of the pixel.</summary>
            <remarks>This overloaded method does not flatten the alpha channel (it will be discarded without additional processing). If you need to flatten alpha channel by blending it with some color, use <see cref="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha(Aurigma.GraphicsMill.Color)">another overloaded version of this method with Aurigma.GraphicsMill.Color argument</see>.</remarks>
            <overloads><summary>Removes alpha channel from the current bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha(Aurigma.GraphicsMill.Color)">
            <summary>Removes alpha channel from the current bitmap. Alpha channel is flattened using specified color (i.e. each pixel is alpha-blended with this color).</summary>
            <param name="backgroundColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying a color to blend semi-transparent areas with.</param>
            <remarks>If you do not want to flatten the alpha channel, use <see cref="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha">another overloaded version of this method without arguments</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ChannelsProvider" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ChannelsProvider" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.SwapChannels(System.Int32[])">
            <summary>Swaps channels.</summary>
            <param name="channels">An array of channel indices sorted in the necessary order. E.g. if you need to swap blue and green channel in RGB bitmap, this array will be looking in the following way: (1, 0, 2).</param>
            <remarks>If number of indices in <i>channels</i> argument is less than number of channels in the current bitmap, the rest channels will be unchanged. If there are more indices than current bitmap provides, all extra indices will be ignored.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#SwapChannels"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#SwapChannels"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.ChannelsProvider.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ChannelsProvider.Transparentize(Aurigma.GraphicsMill.Color,System.Single)">
            <summary>Sets alpha values of pixels with specified colors (and tolerant ones) to transparent.</summary>
            <param name="transparentColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying a color to transparentize.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and transparent color. Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Transparentize"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Transparentize"></code></example>
        </member>
        <member name="T:Aurigma.GraphicsMill.CMAdobeModuleLoadException" draft="yes">
            <summary>This exception is thrown when you try to perform image conversion from one color format to another using Adobe CMM whereas it is not installed on the system.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMAdobeModuleLoadException.#ctor" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMAdobeModuleLoadException" /> class.</summary>
            <overloads><summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMAdobeModuleLoadException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMAdobeModuleLoadException.#ctor(System.String)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMAdobeModuleLoadException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMAdobeModuleLoadException.#ctor(System.String,System.Exception)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMAdobeModuleLoadException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMAdobeModuleLoadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.CMException">
            <summary>This is a base exception for the problems which may arise when you work with color management.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.CMInappropriateProfileException" draft="yes">
            <summary>This exception is thrown when you try to specify a color profile which does not conform target color space.</summary>
            <remarks>For example, you will get this exception when you assign RGB color profile to <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.CmykColorProfile" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMInappropriateProfileException.#ctor" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMInappropriateProfileException" /> class.</summary>
            <overloads><summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMInappropriateProfileException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMInappropriateProfileException.#ctor(System.String)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMInappropriateProfileException" /> class with a name of the profile which causes a error.</summary>
            <param name="profileName">The name of the profile which causes the error.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMInappropriateProfileException.#ctor(System.String,System.Exception)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMInappropriateProfileException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMInappropriateProfileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.CMOpenProfileException">
            <summary>This exception is thrown when Graphics Mill for .NET tries to open a color profile from file, but fails for some reason (e.g. file not found, access is denied, profile is corrupted, or any other).</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMOpenProfileException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMOpenProfileException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMOpenProfileException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMOpenProfileException.#ctor(System.String)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMOpenProfileException" /> class with a specified error message.</summary>
            <param name="profileName">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMOpenProfileException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMOpenProfileException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMOpenProfileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.CMTransformException">
            <summary>This exception is thrown if some errors encountered during some color space transform made by color management module.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMTransformException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMTransformException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.CMTransformException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMTransformException.#ctor(System.String)" draft="yes">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMTransformException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMTransformException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.CMTransformException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.CMTransformException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.CmykColor">
            <summary>This class represents color value in CMYK color space.</summary>
            <remarks><para>To get access to cyan, magenta, yellow, and black component use <see cref="P:Aurigma.GraphicsMill.CmykColor.C" />, <see cref="P:Aurigma.GraphicsMill.CmykColor.M" />, <see cref="P:Aurigma.GraphicsMill.CmykColor.Y" />, and <see cref="P:Aurigma.GraphicsMill.CmykColor.K" /> properties accordingly. Alpha channel is available through <see cref="P:Aurigma.GraphicsMill.CmykColor.A" /> property. Also there are extended versions of these properties (that returns 16-bit version of the component). These properties have a suffix 32 (e.g. <see cref="P:Aurigma.GraphicsMill.CmykColor.C32" />, etc).</para><para>Also you can get components by index using <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" /> method.</para><para>This class implements cast operator for other color types as well as for <see cref="T:System.Drawing.Color">System.Drawing.Color</see>. Note, when you convert colors, no color management is applied. To convert colors with color management, use <see cref="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.ColorProfile)" /> method of <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> class.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.A">
            <summary>Returns 8-bit alpha channel value (color opacity).</summary>
            <value>8-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.A32">
            <summary>Returns 16-bit  (extended) alpha channel value (color opacity).</summary>
            <value>16-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.C">
            <summary>Returns 8-bit cyan channel value.</summary>
            <value>Cyan channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.C32">
            <summary>Returns 16-bit cyan channel value.</summary>
            <value>Cyan channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.ChannelCount">
            <summary>Returns number of channels available in this color.</summary>
            <value>Number of channels available in this color. <see cref="T:Aurigma.GraphicsMill.CmykColor" /> always returns 5 (alpha channel + 4 color channels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.ColorSpace">
            <summary>Returns a color space of the color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value indicating color space of the color. <see cref="T:Aurigma.GraphicsMill.CmykColor" /> always returns <see cref="F:Aurigma.GraphicsMill.ColorSpace.Cmyk" />.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> with specified object.</summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.CmykColor" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.CmykColor" />, exception will be raised.</param>
            <returns>Value specifying if given object represents the same color value as this <see cref="T:Aurigma.GraphicsMill.CmykColor" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)">
            <summary>Gets value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Non-extended (8-bit) value stored in specified channel.</returns>
            <remarks>You can also use extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel32(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel32(System.Int32)" /> returns extended (16-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.GetChannel32(System.Int32)">
            <summary>Gets extended (16-bit) value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Extended (16-bit) value stored in specified channel.</returns>
            <remarks>You can also use non-extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" /> returns non-extended (8-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.GetHashCode">
            <summary>Returns a hash code for this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class.</summary>
            <returns>An integer value that specifies the hash code for this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.K">
            <summary>Returns 8-bit black channel value.</summary>
            <value>Black channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.K32">
            <summary>Returns 16-bit black channel value.</summary>
            <value>Black channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.M">
            <summary>Returns 8-bit magenta channel value.</summary>
            <value>Magenta channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.M32">
            <summary>Returns 16-bit magenta channel value.</summary>
            <value>Magenta channel value.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.CmykColor" /> instance. All channels are initialized with zeros, therefore this color will be represent absolutely white and transparent CMYK value.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(Aurigma.GraphicsMill.CmykColor)~Aurigma.GraphicsMill.GrayScaleColor" draft="yes">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> to <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> automatically converting it to grayscale.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
            <overloads><summary>Casts CMYK color data format.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(Aurigma.GraphicsMill.CmykColor)~Aurigma.GraphicsMill.RgbColor">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> to <see cref="T:Aurigma.GraphicsMill.RgbColor" /> automatically converting it to RGB color space.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(Aurigma.GraphicsMill.CmykColor)~System.Int32">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> to <see cref="T:System.Int32" /> containing numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance to cast.</param>
            <returns><see cref="T:System.Int32" /> containing numerical representation of the color.</returns>
            <remarks>CMYK color contains more channels than can fit to <see cref="T:System.Int32" /> value. It has 5 channels (alpha, cyan, magenta, yellow, and black), but a 32-bit number can hold only 4 extended channels. That's why alpha channel is truncated and you get only CMYK quad instead of ACMYK quintuple.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(Aurigma.GraphicsMill.CmykColor)~System.Int64">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> to <see cref="T:System.Int64" /> containing extended numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance to cast.</param>
            <returns><see cref="T:System.Int64" /> containing extended numerical representation of the color.</returns>
            <remarks>CMYK color contains more channels than can fit to <see cref="T:System.Int64" /> value. It has 5 channels (alpha, cyan, magenta, yellow, and black), but a 64-bit number can hold only 4 extended channels. That's why alpha channel is truncated and you get only CMYK quad instead of ACMYK quintuple.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(Aurigma.GraphicsMill.CmykColor)~System.Drawing.Color">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> class instance to <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> class instance to cast.</param>
            <returns>Color value casted to <see cref="T:System.Drawing.Color">System.Drawing.Color</see>.</returns>
            <remarks>This <see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> is always automatically converted from CMYK to RGB color space using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(System.Int32)~Aurigma.GraphicsMill.CmykColor">
            <summary>Casts integer value to <see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> class instance.</summary>
            <param name="value"><see cref="T:System.Int32" /> containing numerical representation of the color.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance created from the integer value.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.op_Implicit(System.Int64)~Aurigma.GraphicsMill.CmykColor">
            <summary>Casts long value to <see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> class instance.</summary>
            <param name="value"><see cref="T:System.Int64" /> containing extended numerical representation of the color.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance created from the integer value.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.ToGdiplusColor">
            <summary>Returns <see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> does.</summary>
            <returns><see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.CmykColor" /> does.</returns>
            <remarks>This <see cref="T:Aurigma.GraphicsMill.CmykColor">Aurigma.GraphicsMill.CmykColor</see> is always automatically converted from CMYK to RGB color space using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.ToInt32">
            <summary>Returns non-extended (8 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.CmykColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.CmykColor" />.</returns>
            <remarks>CMYK color contains more channels than can fit to <see cref="T:System.Int32" /> value. It has 5 channels (alpha, cyan, magenta, yellow, and black), but a 32-bit number can hold only 4 channels. That's why alpha channel is truncated and you get only CMYK quad instead of ACMYK quintuple.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.ToInt64">
            <summary>Returns extended (16 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.CmykColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.CmykColor" />.</returns>
            <remarks>CMYK color contains more channels than can fit to <see cref="T:System.Int64" /> value. It has 5 channels (alpha, cyan, magenta, yellow, and black), but a 64-bit number can hold only 4 extended channels. That's why alpha channel is truncated and you get only CMYK quad instead of ACMYK quintuple.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.CmykColor.ToString">
            <summary>Converts the value of this instance to its equivalent string representation.</summary>
            <returns>The <see cref="T:System.String" /> representation of the value of this instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.Y">
            <summary>Returns 8-bit yellow channel value.</summary>
            <value>Yellow channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.CmykColor.Y32">
            <summary>Returns 16-bit yellow channel value.</summary>
            <value>Yellow channel value.</value>
        </member>
        <member name="N:Aurigma.GraphicsMill.Codecs" draft="yes">
            <summary>The <see cref="N:Aurigma.GraphicsMill.Codecs" /> namespace contains classes intended to work with files that have one or more images (frames) inside, such as multipage TIFF files, animated GIF, etc. These classes support a lot of file formats and allow to  work with metadata.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" draft="yes">
            <summary>This class represents the Adobe image resource block.</summary>
            <remarks><para>Image resource blocks are one of the basic building units of several file formats,
including Photoshops native file format, JPEG, and TIFF. Image resources are
used to store nonpixel data associated with an image, such as pen tool
paths.</para></remarks>
            <seealso cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Data" draft="yes">
            <summary>Gets/sets the data of the Adobe image resource block referred to by <see cref="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Pointer" />.</summary>
            <value>Data of the Adobe image resource block referred to by <see cref="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Pointer" />.</value>
            <remarks><note>No internal binary data validation is performed during encoding so user is responsible for providing correctly filled <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance. Files which have been saved with incorrect Adobe image resource blocks can produce errors during opening or processing in Adobe applications.</note></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Pointer" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Name" draft="yes">
            <summary>Gets/sets the name of the Adobe image resource block.</summary>
            <value>Name of the Adobe image resource block.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.#ctor(System.String,System.Byte[])" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" /> class instance.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Pointer" draft="yes">
            <summary>Gets the pointer to <see cref="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Data" /> of the Adobe image resource block.</summary>
            <value>Pointer to <see cref="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Data" /> of the Adobe image resource block.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock.Size" draft="yes">
            <summary>Gets a size of the Adobe image resource block data.</summary>
            <value>Size in bytes of the Adobe image resource block data.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" draft="yes">
            <summary>This class represents a dictionary of Adobe image resource blocks, each block is represented by the <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" /> class.</summary>
            <remarks><para>
              Adobe applications (first of all Adobe Photoshop) store meta-information in so called Adobe image resource blocks. Graphics Mill for .NET provides <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class to facilitate work with these data.</para><para>All functionality of this class is implemented in base class <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary" />. To put or get some Adobe image resource block, you should use the <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> property. Just pass ID of the Adobe image resource block as an argument into this property. Refer Adobe Photoshop File Formats Specification for exact Adobe image resource block ID values.</para><para>
Instances of <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class are used in two interfaces:
<list type="bullet"><item><see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport" /> - objects which implement this interface can read resource blocks from a file and retrieve them as instance of <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class.</item><item><see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport" /> - objects which implement this intereface can accept instances of <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class and encode contained resource blocks to a file. No validation of the internal structure of the binary data is performed during encoding so user is responsible for providing correctly filled <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance. Files which have been saved with incorrect Adobe image resource blocks can produce errors during opening or processing in Adobe applications.</item></list></para></remarks>
            <example><para>
                The code sample below demonstrates how to remove thumbnail from Adobe image resource blocks and mark the image as
                copyrighted. Thumbnail block ID is 0x0409 and copyright flag ID is 0x040A.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#RemoveARB"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#RemoveARB"></code></example>
            <seealso cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" />
<seealso cref="T:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport">IMetadataReadSupport Interface</seealso>
<seealso cref="T:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport">IMetadataWriteSupport Interface</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary.{dtor}" draft="yes">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary.Clone" draft="yes">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance.</summary>
            <returns>A <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> object containing full copy of current object.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary.#ctor(System.IntPtr)" draft="yes">
            <summary>This constructor is used by Graphics Mill for .NET for internal purposes. Do not call it directly.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions" draft="yes">
            <summary>This class holds possible BMP format encoder options.</summary>
            <remarks><para>
When you save image to BMP you can specify the single BMP-related setting: compression type (using <see cref="P:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.Compression" /> property). 
</para><note type="note">BMP supports only RLE compression for 4-bit and 8-bit images.</note><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.BmpFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for BMP and always set to 0.</para></remarks>
            <example><para>This sample saves the BMP image with RLE compression:</para><code language="VB" source="FileFormatsVB/form1.vb#BMPSync"></code><code language="CS" source="FileFormatsCS/form1.cs#BMPSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.Compression">
            <summary>Gets/sets BMP compression type.</summary>
            <value>Value that specifies necessary BMP compression type.</value>
            <remarks><para>
BMP format very limited compression support. The table below specifies what compression types are supported by this format:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for BMP files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Rle" /> compression type.</term><description>Can be used only if the bitmap has 4 or 8 bits per pixel (<see cref="P:Aurigma.GraphicsMill.Bitmap.PixelFormat" /> is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format4bppIndexed" />, <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" />, or <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />).
</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.#ctor(Aurigma.GraphicsMill.Codecs.CompressionType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions" /> class instance. You can pass BMP compression type here.</summary>
            <param name="compression">Value that specifies necessary BMP compression type. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.BmpFrame">
            <summary>This class represents a frame of the BMP format.</summary>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#BMPAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#BMPAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.BmpFrame.Compression" draft="yes">
            <summary>Gets/sets BMP compression type.</summary>
            <value>Value that specifies necessary BMP compression type.</value>
            <remarks><para>
BMP format very limited compression support. The table below specifies what compression types are supported by this format:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for BMP files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Rle" /> compression type.</term><description>Can be used only if the bitmap has 4 or 8 bits per pixel (<see cref="P:Aurigma.GraphicsMill.Bitmap.PixelFormat" /> is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format4bppIndexed" />, <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" />, or <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />).
</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.#ctor(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Codecs.CompressionType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpFrame" /> class instance. You can set bitmap and compression type here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="compression">Value that specifies necessary BMP compression type. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.#ctor(Aurigma.GraphicsMill.Codecs.CompressionType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpFrame" /> class instance. You can set compression type here.</summary>
            <param name="compression">Value that specifies necessary BMP compression type. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.BmpEncoderOptions.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.BmpReader" draft="yes">
            <summary>This class enables you to read BMP images.</summary>
            <remarks><para>
BMP (Bitmap) is a standard image format mainly used on the Microsoft Windows platform. BMP images can range from black and white (1 bit per pixel) up to 32 bit color (16.7 million colors), in that way bitmap image format can store both indexed and true color images. There are two main BMP formats exist: Windows bitmap formats and OS/2 bitmap format. All of these formats supports RLE-type compression for 4 and 8 bits per pixel palette images. 
</para><para>
BMP files can store only single image per file.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.BmpWriter" draft="yes">
            <summary>This class enables you to write BMP images.</summary>
            <remarks><para>
BMP (Bitmap) is a standard image format mainly used on the Microsoft Windows platform. BMP images can range from black and white (1 bit per pixel) up to 32 bit color (16.7 million colors), in that way bitmap image format can store both indexed and true color images. There are two main BMP formats exist: Windows bitmap formats and OS/2 bitmap format. All of these formats supports RLE-type compression for 4 and 8 bits per pixel palette images. 
</para><para>
BMP files can store only single image per file.
</para></remarks>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#BMPAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#BMPAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.BmpFrame" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.BmpWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.BmpWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CompressionType" draft="yes">
            <summary>Contains possible compression types for various encoders.</summary>
            <remarks>Note, some media formats support only few of these formats. Check <b>Remarks</b> section of the <b>Compression</b> property of appropriate media format encoder options to get information what compression types are supported with this format.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt3">
            <summary>CCITT Group 3 compression (used for sending fax documents, for 1-bit images only).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt4">
            <summary>CCITT Group 4 compression (used for sending fax documents, for 1-bit images only).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.CcittRle">
            <summary>CCITT RLE compression (used for sending fax documents, for 1-bit images only).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg">
            <summary>JPEG compression (lossy algorithm, used mostly for TrueColor images like photos).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Lzw">
            <summary>LZW compression algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.None">
            <summary>No compression.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Rle">
            <summary>RLE compression algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Unknown">
            <summary>Some unsupported compression method.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossless">
            <summary>Lossless wavelet compression (Jpeg2000).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy">
            <summary>Lossy wavelet compression (Jpeg2000).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip">
            <summary>Deflate compression algorithm (the same is used in ZIP files).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CustomEncoderOptions">
            <summary>Abstract class for custom encoder options object.</summary>
            <remarks><para>This class represents encoder options which are supported by your codec.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomEncoderOptions.#ctor" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.CustomEncoderOptions" /> class instance.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomEncoderOptions.SetMediaFormat(System.Int64)">
            <summary>Sets the unique media format identifier for the codec.</summary>
            <param name="mediaFormat">Unique value corresponding to the format supported by the codec.</param>
            <remarks><para>This method should be used in a constructor to set codec parameters.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CustomFormatReader">
            <summary>Abstract class for a custom format reader object.</summary>
            <remarks><para>In case you want to add read support of media formats not already supported by Graphics Mill for .NET, or if you want a custom reader for an already supported format, you should create a reader class derived from this class.</para><para>It provides several methods and properties, most of which are inherited. However, there are some members that you should implement:</para><list type="bullet"><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetEmptyFrame" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.IsSupported(System.IO.Stream)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OpenReader(System.IO.Stream)" /></description></item></list><para>For more details on these members, see the appropriate reference topics.</para></remarks>
            <seealso cref="T:Aurigma.GraphicsMill.Codecs.FormatReader" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.CheckOpened">
            <summary>Checks if the format reader is opened.</summary>
            <remarks><para>This method is called whenever any reader property that is associated with an opened file (for example, dimensions or quality) is used. It is also called when the frame is loaded using the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.LoadFrame(System.Int32)" /> method.</para><para>No need to implement this method yourself. Use the standard implementation.</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.Opened" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.LoadFrame(System.Int32)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.CloseReader">
            <summary>Closes the format reader, and detaches it from a previously opened file (or other media).</summary>
            <remarks><para>This method is called by the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" /> method. Implement it when you write your own custom codec and need to release resources when the reader is closed.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetEmptyFrame">
            <summary>Returns an empty  <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" /> associated with this reader.</summary>
            <returns>Object of the <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" /> descendant class associated with this reader.</returns>
            <remarks><para>The implementation of this method is always simple: just return an instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" /> descendant implemented by you.</para></remarks>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#GetEmptyFrame"></code></example>
            <seealso cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetFrameIndexToLoad">
            <summary>Returns an index of the frame being loaded.</summary>
            <returns>Index of the frame being loaded.</returns>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> method so that you know what frame to load.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetLoadingFrame">
            <summary>Returns the frame being loaded.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" /> object representing the frame being loaded.</returns>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> or <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters" /> method if the frame object should be modified somehow, for example, if its parameters should be initialized.</para></remarks>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#LoadFrameParameters"></code></example>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetLoadingMode">
            <summary>Returns a mode, in which the frame is going to be loaded: either a bitmap or a thumbnail.</summary>
            <returns>A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadingMode" /> enumeration.</returns>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> method.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetThumbnailHeightToLoad">
            <summary>Returns the requested thumbnail height.</summary>
            <returns>Requested thumbnail height.</returns>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> method.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetThumbnailWidthToLoad">
            <summary>Returns the requested thumbnail width.</summary>
            <returns>Requested thumbnail width.</returns>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> method.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.IsSupported(System.IO.Stream)">
            <summary>Returns whether this reader can handle the specified file (stream).</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> value that specifies a stream for which the format needs to be checked.</param>
            <returns>Value that is equal to <b>true</b> when the file format is supported, or <b>false</b> otherwise.</returns>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#IsSupported"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap">
            <summary>Loads the frame bitmap.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters">
            <summary>Loads frame parameters.</summary>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#LoadFrameParameters"></code></example>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadingMode">
            <summary>Contains possible values corresponding to frame loading modes.</summary>
            <remarks><para>Depending on these values, the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameBitmap" /> method should either load full bitmap from the file, or resize it on the fly. If the image should be resized, you can determine thumbnail size using the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetThumbnailWidthToLoad" /> and <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetThumbnailHeightToLoad" /> methods.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.GetLoadingMode" />
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadingMode.Bitmap">
            <summary>Original bitmap.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadingMode.Thumbnail">
            <summary>Resized bitmap (thumbnail).</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.#ctor">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFormatReader" /> class instance.</summary>
            <remarks><para>The constructor for this class should specify the default properties of your reader, for example, its name, description, supported MIME type, and so on. This can be done by calling the following methods:</para><list type="bullet"><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetDefaultExtension(System.String)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFilterString(System.String)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFormatDescription(System.String)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFormatName(System.String)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetMediaFormat(System.Int64)" /></description></item><item><description><see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetMimeType(System.String)" /></description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
            <remarks><para>This method is called by the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.IO.Stream)" /> method and has a standard implementation that calls the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.IsSupported(System.IO.Stream)" /> method.</para><note>No need to implement this method directly. Implement the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.IsSupported(System.IO.Stream)" /> method instead.</note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.IsSupported(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OnClose" draft="yes">
            <summary>Frees resources when the reader closes.</summary>
            <remarks><para>Do not implement this method. Implement the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.CloseReader" /> instead.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OnOpen" draft="yes">
            <summary>Called when the reader is opened.</summary>
            <remarks><para>Do not implement this method. Implement the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OpenReader(System.String)" /> instead.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.String)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OpenReader(System.String)">
            <summary>Opens the reader on the specifed file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
            <remarks><para>Usually, this method is a simple wrapper around the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OpenReader(System.IO.Stream)" /> method.</para></remarks>
            <overloads><summary>Opens the reader.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.OpenReader(System.IO.Stream)">
            <summary>Opens the reader on the specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#OpenReader"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.ResetEvents(System.Int32)">
            <summary>Initializes a progress state while loading a bitmap or a thumbnail.</summary>
            <param name="count">Number of steps that should be performed before the operation will be completed.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetDefaultExtension(System.String)">
            <summary>Sets the default extension of files opened using this codec.</summary>
            <param name="defaultExtension">String in a format <c>*.ext</c>.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFilterString(System.String)">
            <summary>Sets the filter string for the <b>Open file</b> dialog.</summary>
            <param name="filterString">String in a format <c>*.ext1;*.ext2;...</c>.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFormatDescription(System.String)">
            <summary>Sets the description of the codec.</summary>
            <param name="formatDescription">Description of the codec.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFormatName(System.String)">
            <summary>Sets the name of the codec.</summary>
            <param name="formatName">Name of the codec.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetFrameCount(System.Int32)">
            <summary>Sets the maximum possible frame count supported by this codec.</summary>
            <param name="count">Number of frames which can be stored in files of this format.</param>
            <remarks><para>This method should be called when the file is being opened.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetLoadedBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Set the bitmap for the current frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance that represents the image which should be set for the current frame.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetMediaFormat(System.Int64)">
            <summary>Sets the unique media format identifier for the codec.</summary>
            <param name="mediaFormat">Unique value corresponding to the format supported by the codec.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.SetMimeType(System.String)">
            <summary>Sets the MIME type of the files opened with the codec.</summary>
            <param name="mimeType">String representing a MIME type of the file type represented by this codec.</param>
            <remarks><para>This method should be used in a reader constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.UpdateEvents">
            <summary>Updates the progress state while loading a bitmap or a thumbnail.</summary>
            <remarks><para>This method should be called after completing a successive step of the operation, for example, after reading a pixel row.</para><para>It has the same effect as calling the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.UpdateEvents(System.Int32)" /> method with the <paramref name="valueToUpdateProgress" /> equal to <b>1</b>.</para></remarks>
            <overloads><summary>Updates the progress state while loading a bitmap or a thumbnail.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.UpdateEvents(System.Int32)">
            <summary>Updates the progress state while loading a bitmap or a thumbnail by the specified value.</summary>
            <param name="valueToUpdateProgress">Progress state value (to update the progress by).</param>
            <remarks><para>This method should be called after completing a successive step of the operation, for example, after reading a pixel row.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CustomFormatWriter" draft="yes">
            <summary>Abstract class for a custom format writer object.</summary>
            <remarks><para>In case you want to add write support of media formats not already supported by Graphics Mill for .NET, or if you want a custom writer for an already supported format, you should create a writer class derived from this class.</para></remarks>
            <seealso cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CustomFormatWriter._currentLeft">
            <exclude />
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.CustomFormatWriter._currentTop">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.CheckFrameParams(Aurigma.GraphicsMill.Codecs.Frame)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.CloseWriter">
            <summary>Closes the format writer, and detaches it from a previously opened file (or other media).</summary>
            <remarks><para>This method is called by the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Close" /> method. Implement it when you write your own custom codec and need to release resources when the writer is closed.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.GetClosestPixelFormat(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Get a pixel format supported by this writer closest to the specified one.</summary>
            <param name="pixelFormat"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member that specifies the pixel format you would like to get a closest pixel format of this codec for.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member that specifies the closest pixel format supported by the writer comparing to the specified one.</returns>
            <remarks><para>This method is used to automate conversion of the bitmap before saving it. </para><para>Imagine, that your file format supports only 24-bit RGB and 32-bit CMYK. If the user tries to save, say, 8-bit indexed image, obviously you should convert it to 24-bit RGB. But for 40-bit ACMYK bitmap, you should convert to 32-bit CMYK (to avoid color losses during conversion between CMYK and RGB).</para></remarks>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#GetClosestPixelFormat"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.GetStream">
            <summary>Returns the stream associated with the currently opened writer.</summary>
            <returns><see cref="T:System.IO.Stream" /> associated with the current writer.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.GetSupportedPixelFormats">
            <summary>Returns an array of supported pixel formats.</summary>
            <returns>Array of pixel formats supported by this writer.</returns>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#GetSupportedPixelFormats"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.GetWrittenFrameCount">
            <summary>Returns the number of frames that are already written to a file or stream.</summary>
            <returns>Number of frames written to a file or stream.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Checks if the provided pixel format is supported.</summary>
            <param name="pixelFormat"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member that specifies the pixel format you would like to verify.</param>
            <returns><b>true</b> if the writer can save bitmaps of the specified pixel formats without conversion to another pixel format; <b>false</b> otherwise.</returns>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#IsPixelFormatSupported"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OnAfterAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OnClose">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OnOpen">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OpenWriter(System.String)">
            <summary>Opens the writer on the specifed file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
            <remarks><para>This method is a simple wrapper around the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OpenWriter(System.IO.Stream)">overloaded version of this method with System.IO.Stream as an argument</see>. No need to implement this method yourself, it will automatically work when you implement the stream-based version of this method.</para></remarks>
            <overloads><summary>Opens the writer.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.OpenWriter(System.IO.Stream)">
            <summary>Opens the writer on the specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.ResetEvents(System.Int32)">
            <summary>Initializes a progress state while writing a bitmap.</summary>
            <param name="count">Number of steps that should be performed before the operation will be completed.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SaveFrameBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Write the specified bitmap to a file at current position.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance that represents the image to save.</param>
            <remarks><para>If you need to get frame settings like quality, position, etc, you need to implement the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SaveFrameParameters(Aurigma.GraphicsMill.Codecs.Frame)" /> method. In this method you will get the frame before the bitmap will be extracted and passed to the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SaveFrameBitmap(Aurigma.GraphicsMill.Bitmap)" />. This way you will be able to save parameters in private variables of your class or whatever else.</para></remarks>
            <example><code language="CS" source="CodeSnippets/CustomCodec.cs#SaveFrameBitmap"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SaveFrameParameters(Aurigma.GraphicsMill.Codecs.Frame)">
            <summary>Extracts the current frame settings before saving the bitmap into the file.</summary>
            <param name="frame">Current frame to get settings from.</param>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SaveFrameBitmap(Aurigma.GraphicsMill.Bitmap)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetDefaultExtension(System.String)">
            <summary>Sets the default extension of files opened using this codec.</summary>
            <param name="defaultExtension">String in a format <c>*.ext</c>.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetFilterString(System.String)">
            <summary>Sets the filter string for the <b>Save file</b> dialog.</summary>
            <param name="filterString">String in a format <c>*.ext1;*.ext2;...</c>.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetFormatDescription(System.String)">
            <summary>Sets the description of the codec.</summary>
            <param name="formatDescription">Description of the codec.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetFormatName(System.String)">
            <summary>Sets the name of the codec.</summary>
            <param name="formatName">Name of the codec.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetMediaFormat(System.Int64)">
            <summary>Sets the unique media format for the codec.</summary>
            <param name="mediaFormat">Unique value corresponding to the format supported by the codec.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.SetMimeType(System.String)">
            <summary>Sets the MIME type of the files that can be saved with the codec.</summary>
            <param name="mimeType">String representing a MIME type of the file type represented by this codec.</param>
            <remarks><para>This method should be used in a writer constructor to set codec parameters.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.UpdateEvents">
            <summary>Updates the progress state while writing a bitmap.</summary>
            <remarks><para>This method should be called after completing a successive step of the operation, for example, after writing a pixel row.</para><para>It has the same effect as calling the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.UpdateEvents(System.Int32)" /> method with the <paramref name="valueToUpdateProgress" /> equal to <b>1</b>.</para></remarks>
            <overloads><summary>Updates the progress state while writing a bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFormatWriter.UpdateEvents(System.Int32)">
            <summary>Sets the progress state while writing a bitmap by the specified value.</summary>
            <param name="valueToUpdateProgress">Progress state value (to update the progress by).</param>
            <remarks><para>This method should be called after completing a successive step of the operation, for example, after writing a pixel row.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.CustomFrame" draft="yes">
            <summary>Abstract class for a custom frame object.</summary>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.ColorProfileTU">
            <summary>Gets/sets a color profile of the bitmap stored in the frame (thread-unsafe version).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance which represents the color profile of the current frame.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFrame.Finalize">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.FormatReaderTU">
            <summary>Gets a format reader associated with the frame (thread-unsafe version).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.CustomFormatReader" /> instance which is associated with the current frame.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.HeightTU">
            <summary>Gets/sets a height of the bitmap stored in the frame (thread-unsafe version).</summary>
            <value>Heigth of the bitmap in pixels.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.HorizontalResolutionTU">
            <summary>Gets/sets a horizontal resolution of the bitmap stored in the frame (thread-unsafe version).</summary>
            <value>Horizontal resolution of the bitmap.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFrame.InitializeCustomFrameTU(System.String,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.PixelFormat,System.Single,System.Single,Aurigma.GraphicsMill.ColorProfile)">
            <summary>Initializes the frame with provided settings.</summary>
            <param name="name">Frame name.</param>
            <param name="left">X-coordinate of the left top corner of the frame (in pixels).</param>
            <param name="top">Y-coordinate of the left top corner of the frame (in pixels).</param>
            <param name="width">Frame width.</param>
            <param name="height">Frame height.</param>
            <param name="pixelFormat">Pixel format for the frame bitmap.</param>
            <param name="horizontalResolution">Horizontal resolution of the frame bitmap.</param>
            <param name="verticalResolution">Vertical resolution of the frame bitmap.</param>
            <param name="colorProfile">Frame color profile.</param>
            <remarks><para>This method should be called from the <see cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters" />.</para><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.CustomFormatReader.LoadFrameParameters" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.LeftTU">
            <summary>Gets/sets a horizontal position of the left top corner of the frame (thread-unsafe version).</summary>
            <value>X-coordinate of the left top corner of the frame (in pixels).</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.NameTU">
            <summary>Gets/sets the frame name (thread-unsafe version).</summary>
            <value>Frame name.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.CustomFrame.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.CustomFrame" /> class.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.PixelFormatTU">
            <summary>Gets/sets a pixel format of the current frame bitmap data (thread-unsafe version).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value specifying the pixel format of the bitmap data.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.TopTU">
            <summary>Gets/sets a vertical position of the left top corner of the frame (thread-unsafe version).</summary>
            <value>Y-coordinate of the left top corner of the frame (in pixels).</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.VerticalResolutionTU">
            <summary>Gets/sets a vertical resolution of the bitmap stored in the frame (thread-unsafe version).</summary>
            <value>Vertical resolution of the bitmap stored in the frame.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.CustomFrame.WidthTU">
            <summary>Gets/sets a width of the bitmap stored in the frame (thread-unsafe version).</summary>
            <value>Width of the bitmap in pixels.</value>
            <remarks><para>Use protected thread-unsafe versions of <b>xxxTU</b> properties instead of the public ones (without <b>TU</b> postfix) inside of the code of your custom codec. You should use to avoid deadlocks during multithreaded calls. </para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.DisposalMethod">
            <summary>Contains values for disposal methods used in animated files (GIF, SWF) to specify what to do with a frame after it has been displayed.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.Background">
            <summary>Restore to background color. The area used by a frame will be restored to the background color.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None">
            <summary>A frame will be left in place.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.NotSpecified">
            <summary>The decoder is not required to take any action.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.Previous">
            <summary>Restore to previous. The decoder is required to restore the area overwritten by a frame with what was there prior to rendering the frame.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.EncoderOptions">
            <summary>This is a base class for all encoder options.</summary>
            <remarks><para>Encoder options are used to specify settings for format writers. This base class does not contain format-specific settings. You can specify only frame position by <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> properties. Formats where frame position does not make sense ignores these properties.</para><para>As usual you get this class instance into <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event (and few other events/methods). To determine what a file type it is related to, use <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property.</para><para>You can export this class into the <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> instance using <see cref="M:Aurigma.GraphicsMill.Codecs.EncoderOptions.ToFrame" /> method. It enables you to use this class with <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> descendants directly.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left">
            <summary>Gets/sets left position of the frame.</summary>
            <value>X-coordinate of the top left corner of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat">
            <summary>Returns media format for which encoder options are defined.</summary>
            <value>An integer value that specifies a media format ID for which encoder options are defined.</value>
            <remarks><para>Each descendant class returns fixed value specifying media format it represents.</para><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.EncoderOptions.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.EncoderOptions.#ctor(System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.EncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top">
            <summary>Gets/sets top position of the frame.</summary>
            <value>Y-coordinate of the top left corner of the frame.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.EncoderOptionsProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" draft="yes">
            <summary>This class represents a dictionary of EXIF fields.</summary>
            <remarks>All functionality of this class is implemented in base class <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary" />. To put or get some EXIF field, you should use the <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> property. Just pass ID of the EXIF field as an argument into this property. Refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for exact field ID values. Alternatively you can use static members <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Artist" />, <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTime" />, <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Make" />, <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Orientation" />, and others. Exact interpretations of these parameters can be found at <see href="http://www.exif.org/specifications.html">EXIF specification</see>. Currently specification 2.2 is supported.</remarks>
            <example><para>The code below demonstrates how to extract and display both EXIF and IPTC data.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#LoadingEXIFIPTC"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#LoadingEXIFIPTC"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ExifDictionary.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ApertureValue">
            <summary>The lens aperture (in APEX units).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Artist">
            <summary>The name of photographer or image creator.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.BitsPerSample">
            <summary>The number of bits per image component.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.BrightnessValue">
            <summary>The brightness value (in APEX units).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.CfaPattern">
            <summary>The color filter pattern.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ExifDictionary.Clone" draft="yes">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" />).</returns>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ColorSpace">
            <summary>The color space of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ComponentsConfiguration">
            <summary>The order of pixel channels (components).</summary>
            <remarks><para>Makes sense only for compressed images.</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.CompressedBitsPerPixel">
            <summary>The number of bits per pixel in the compressed image.</summary>
            <remarks><para>Makes sense only for compressed images.</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Compression">
            <summary>The compression type.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Contrast">
            <summary>The contrast settings applied when images was captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Copyright">
            <summary>The copyright information.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.CustomRendered">
            <summary>Value that indicates that special processing on image was applied.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTime">
            <summary>The date and time of image creation.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTimeDigitized">
            <summary>The date and time when the images was converted into digital representation.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTimeOriginal">
            <summary>The date and time of the original file was created.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DeviceSettingDescription">
            <summary>The description of the image capturing device settings.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DigitalZoomRatio">
            <summary>The digital zoom ratio.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExifVersion">
            <summary>The version of the EXIF specification this data is stored at.</summary>
            <remarks><para>Due specification this field should be always presented at correct EXIF data block. Otherwise it should be treated as corrupted or unsupported by standard. So you should never remove this tag.</para><para>
To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.
</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExposureBiasValue">
            <summary>The exposure bias (in APEX units).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExposureIndex">
            <summary>The exposure index of the device when image is being captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExposureMode">
            <summary>The exposure mode.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExposureProgram">
            <summary>The exposure program.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ExposureTime">
            <summary>The exposure time (in seconds).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FileSource">
            <summary>The image source.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Flash">
            <summary>The flash status.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FlashEnergy">
            <summary>The flash energy (in BCPS).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FlashPixVersion">
            <summary>The version of FlashPix format.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FNumber">
            <summary>The F number.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalLength">
            <summary>The focal length of the lens (in millimeters).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalLengthIn35mmFilm">
            <summary>The focal length of the lens assuming 35mm film camera (in millimeters).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalPlaneResolutionUnit">
            <summary>The unit to measure focal plane resolution with (i.e. <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalPlaneXResolution" /> and <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalPlaneYResolution" />).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalPlaneXResolution">
            <summary>The horizontal resolution of the camera focal plane.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.FocalPlaneYResolution">
            <summary>The vertical resolution of the camera focal plane.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GainControl">
            <summary>The overall image gain adjustment.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ExifDictionary.GetItemInfo(System.Object)">
            <summary>Returns the information about the EXIF item by the key.</summary>
            <param name="key">The key to get the information for. Must be one of predefined keys (see static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />).</param>
            <returns>An <see cref="T:Aurigma.GraphicsMill.Codecs.ExifItemInfo" /> structure that contains the information about the item.</returns>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsAltitude">
            <summary>The altitude.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsAltitudeRef">
            <summary>The altitude reference.</summary>
            <remarks><para>Always sea level in the current implementation of EXIF.</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsAreaInformation">
            <summary>The name of GPS area.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDateStamp">
            <summary>The GPS datestamp.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestBearing">
            <summary>The bearing to the destination point (in degrees).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestBearingRef">
            <summary>The reference for giving the bearing to the destination point.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestDistance">
            <summary>The distance to the destination point.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestDistanceRef">
            <summary>The unit for distance to the destination point.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestLatitude">
            <summary>The destination point latitude.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestLatitudeRef">
            <summary>The destination point latitude reference (north or south).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestLongitude">
            <summary>The destination point longitude.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDestLongitudeRef">
            <summary>The destination point longitude reference (west or east).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDifferential">
            <summary>The GPS differencial correction.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsDop">
            <summary>The GPS data degree of precision.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsImgDirection">
            <summary>The direction of the image when it was captured (in degrees).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsImgDirectionRef">
            <summary>The reference for giving the direction of the image when it was captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsLatitude">
            <summary>The latitude.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsLatitudeRef">
            <summary>The latitude reference (north or south).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsLongitude">
            <summary>The longitude.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsLongitudeRef">
            <summary>The longitude reference (west or east).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsMapDatum">
            <summary>The geodetic survey data.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsMeasureMode">
            <summary>The GPS measurement mode.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsProcessingMethod">
            <summary>The name of GPS processing method.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsSatellites">
            <summary>The details about GPS sattelites used in measurement.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsSpeed">
            <summary>The speed of the GPS receiver movement.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsSpeedRef">
            <summary>The Unit for speed of movement of GPS receiver.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsStatus">
            <summary>The status of GPS receiver when image was recorded.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsTimeStamp">
            <summary>The GPS timestamp (in UTC).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsTrack">
            <summary>The direction of GPS receiver movement (in degrees).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsTrackRef">
            <summary>The reference for giving the direction of GPS receiver movement.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.GpsVersionId">
            <summary>The version of the GPSVersionID tag.</summary>
            <remarks><para>
When GPS details are presented, this field is mandatory.
</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.
</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ImageDescription">
            <summary>The title of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ImageLength">
            <summary>The height of the image in pixels.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ImageUniqueId">
            <summary>The 128-bit unique ID of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ImageWidth">
            <summary>The width of the image in pixels.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.InteroperabilityIndex">
            <summary>The index of interoperability rule.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.IsoSpeedRatings">
            <summary>The ISO speed and the ISO latitude of the device.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.LightSource">
            <summary>The light source.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Make">
            <summary>The name of manufacturer of the camera (or other recording equipment).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.MakerNote">
            <summary>The custom comments. May contain any information maker want to store.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.MaxApertureValue">
            <summary>The smallest F of the lens (in APEX units).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.MeteringMode">
            <summary>The metering mode.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Model">
            <summary>The name of the model of the camera (or other recording equipment).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ExifDictionary.#ctor" draft="yes">
            <summary>Creates and initializes new empty <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> object.</summary>
            <overloads><summary>Creates and initializes new empty <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ExifDictionary.#ctor(System.IntPtr)">
            <summary>This constructor is used by Graphics Mill for .NET for internal purposes. Do not call it directly.</summary>
            <param name="exif">The pointer to the internal Graphics Mill for .NET object.</param>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Oecf">
            <summary>The opto-electronic conversion function.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Orientation">
            <summary>The orientation of image (how it is rotated relatively top left corner).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.PhotometricInterpretation">
            <summary>The pixel composition.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.PixelXDimension">
            <summary>The valid width of the meaningful image.</summary>
            <remarks><para>Makes sense only for compressed images.</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.PixelYDimension">
            <summary>The valid height of the meaningful image.</summary>
            <remarks><para>Makes sense only for compressed images.</para><para>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.PlanarConfiguration">
            <summary>The planar configuration of the pixel components (planar or chunky).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.PrimaryChromaticities">
            <summary>The chromaticity of the three primary colors of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ReferenceBlackWhite">
            <summary>The reference for black and white point of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.RelatedSoundFile">
            <summary>The name of an audio file associated with this image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ResolutionUnit">
            <summary>The unit image resolution is measured at (i.e. <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.XResolution" /> and <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.YResolution" />).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.RowsPerStrip">
            <summary>Rows per strip (if image is divided into strips).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SamplesPerPixel">
            <summary>The number of components (channels) in one pixel.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Saturation">
            <summary>The saturation settings applied when images was captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SceneCaptureType">
            <summary>The type of scene was captured by camera (landscape, night scene, portrait, etc).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SceneType">
            <summary>The type of scene.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SensingMethod">
            <summary>The sensor type of the device.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Sharpness">
            <summary>The sharpness settings applied when images was captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ShutterSpeedValue">
            <summary>The shutter speed (in APEX units).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Software">
            <summary>The name of the software that created this image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SpatialFrequencyResponse">
            <summary>The spatial frequency response values.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SpectralSensitivity">
            <summary>The spectral sensitivity.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.StripByteCounts">
            <summary>The total number of bytes in one strip.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.StripOffsets">
            <summary>The bitmap stride (byte offset between strips).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubjectArea">
            <summary>The subject area.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubjectDistance">
            <summary>The distance to the subject (in meters).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubjectDistanceRange">
            <summary>The kind of distance to the subject (macro, close, or distant).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubjectLocation">
            <summary>The location of the main subject in the scene.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubSecTime">
            <summary>The fractions of seconds for <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTime" /> field.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubSecTimeDigitized">
            <summary>The fractions of seconds for <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTimeDigitized" /> field.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.SubSecTimeOriginal">
            <summary>The fractions of seconds for <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTimeOriginal" /> field.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.Thumbnail">
            <summary>The image thumbnail.</summary>
            <remarks>When you pass this value into <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" />, you get a  <see cref="T:Aurigma.GraphicsMill.Bitmap" /> that contains the thumbnail stored in EXIF data. Almost all digital cameras include EXIF thumbnail into captured photos. This way of thumbnails from digital photos is much faster comparing to <see cref="M:Aurigma.GraphicsMill.Bitmap.LoadThumbnail(System.String,System.Int32,System.Int32)" /> method or <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> transform.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailBitsPerSample">
            <summary>The number of bits per channel in the thumbnail.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailCompression">
            <summary>The compression type of the thumbnail.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailLength">
            <summary>The height of the thumbnail in pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailOrientation">
            <summary>The orientation of the thumbnail (how it is rotated relatively top left corner).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>Orientation</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailPhotometricInterpretation">
            <summary>The pixel composition of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>PhotometricInterpretation</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailResolutionUnit">
            <summary>The unit thumbnail resolution is measured at (i.e. <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailXResolution" /> and <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailYResolution" />).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>ResolutionUnit</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailRowsPerStrip">
            <summary>Rows per strip at the thumbnail (if thumbnail is divided into strips).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>RowsPerStrip</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailSamplesPerPixel">
            <summary>The number of components (channels) in one pixel of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>SamplesPerPixel</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailStripByteCounts">
            <summary>The total number of bytes in one strip of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for <b>StripByteCounts</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailStripOffsets">
            <summary>The thumbnail stride (byte offset between strips).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for for <b>StripOffset</b> tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailWidth">
            <summary>The width of the thumbnail in pixels.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailXResolution">
            <summary>The horizontal resolution of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for ThumbnailXResolution tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailYCbCrPositioning">
            <summary>YCbCr positioning of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailYCbCrSubSampling">
            <summary>YCbCr subsampling of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.ThumbnailYResolution">
            <summary>The vertical resolution of the thumbnail.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see> for ThumbnailYResolution tag.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.TransferFunction">
            <summary>The transfer function in tabular form.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.UserComment">
            <summary>The additional comments or keywords on the image available for users.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.WhiteBalance">
            <summary>The mode of the white balance when the image was captured.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.WhitePoint">
            <summary>The white point of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.XResolution">
            <summary>The horizontal resolution of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.YCbCrCoefficients">
            <summary>The coefficients used during the transformation between RGB and YCbCr color spaces.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.YCbCrPositioning">
            <summary>The position of chrominance components relatively luminosity component.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.YCbCrSubSampling">
            <summary>Sampling ratio of the chrominance components relatively luminosity component.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.YResolution">
            <summary>The vertical resolution of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.exif.org/specifications.html">EXIF specification</see>.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.ExifItemInfo">
            <summary>The structure which describes the EXIF items.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.ExifItemInfo.Type">
            <summary>Gets the type of the EXIF item.</summary>
            <value>The type of the EXIF item.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.ExifItemInfo.ValueCount">
            <summary>Gets a number of values stored inside this item.</summary>
            <value>A number of values stored in the item.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FormatManager" draft="yes">
            <summary>This class enables you to manage installed format readers and writers.</summary>
            <remarks><para>
This class provides a number of static method and properties related with format readers and writers. In particular it serves as a class factory that creates proper <see cref="T:Aurigma.GraphicsMill.Codecs.FormatReader" /> or <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> descendant class from specified media. It is extremely useful, for example, when you do not know the format of the file to load beforehand. In this case you do not know what exact format reader implementation to create. Here format manager comes into play: you just call <see cref="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatReader(System.String)" /> and format manager automatically determines file format. This way it creates proper format reader and returns it. The same is true for format writers: method <see cref="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatWriter(System.String)" /> analyzes file extension and return proper format writer instance.
</para><para>
Another useful feature of this class is automatic retrieval of filter for file dialog. Using <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad" /> property you can get a filter string for open file dialog, using <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave" /> property - a filter string for save file dialog.
</para><para>
  Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of this class, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc. This ID is passed to number of methods of this class, and also returned by format readers and writers.
</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.AsfFormat">
            <summary>ASF format ID. Note, this format is supported only if you have Media Processor add-on.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.AviFormat">
            <summary>AVI format ID. Note, this format is supported only if you have AVI Processor add-on.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.BmpFormat">
            <summary>BMP format ID.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateEncoderOptions(System.Int64)">
            <summary>Creates a encoder options object for specified the format.</summary>
            <param name="format">An ID of the necessary format (see static fields of this class).</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface of the encoder options object for specified format.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatReader(System.Int64)" draft="yes">
            <summary>Creates and returns format reader by specified media format ID.</summary>
            <param name="format">An integer value that specifies a media format ID which should have the requested format reader.</param>
            <returns>The object that implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatReader" /> interface which has the requested media format.</returns>
            <overloads><summary>Creates and returns format reader.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatReader(System.String)">
            <summary>Creates and returns format reader opened on specified file.</summary>
            <param name="fileName">The name of the file to open format reader on.</param>
            <returns>The object that implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatReader" /> interface which is opened on the specified file.</returns>
            <remarks>This method automatically determines the file format and creates appropriate format reader class instance.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatReader(System.IO.Stream)">
            <summary>Creates and returns format reader opened on specified stream.</summary>
            <param name="stream">The stream to open format reader on.</param>
            <returns>The object that implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatReader" /> interface which is opened on the specified stream.</returns>
            <remarks>This method automatically determines the media format and creates appropriate format reader class instance.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatWriter(System.Int64)" draft="yes">
            <summary>Creates and returns format writer by specified media format ID.</summary>
            <param name="format">An integer value that specifies a media format ID which should have the requested format writer.</param>
            <returns>The object that implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatWriter" /> interface which has the requested media format.</returns>
            <overloads><summary>Creates and returns format writer.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatWriter(System.String)">
            <summary>Creates and returns format writer opened on specified file.</summary>
            <param name="fileName">The name of the file to open format writer on.</param>
            <returns>The object that implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatWriter" /> interface which is opened on the specified file.</returns>
            <remarks>This method analyzes an extension of the <i>fileName</i> argument and selects necessary format writer this way.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad">
            <summary>Returns a filter string for open file dialog that contains all file formats supported by Graphics Mill for .NET for reading.</summary>
            <value>String that contains a filter string for open file dialog that contains all file formats supported by Graphics Mill for .NET for reading.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave">
            <summary>Returns a filter string for save file dialog that contains all file formats supported by Graphics Mill for .NET for writing.</summary>
            <value>String that contains a filter string for save file dialog that contains all file formats supported by Graphics Mill for .NET for writing.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetDefaultExtension(System.Int64)" draft="yes">
            <summary>Returns default extension for specified format.</summary>
            <param name="format">An integer value that specifies a media format ID of necessary format.</param>
            <returns>The string value that contains the default extension for specified format.</returns>
            <remarks><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetFilterString(System.Int64[])" draft="yes">
            <summary>Returns filter string for open/save file dialogs that contains all specified file formats.</summary>
            <param name="formats">Array of file formats identifiers.</param>
            <returns>String that contains a filter string for open/save file dialogs that contains all specified file formats.</returns>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad">FormatManager.FilterStringForLoad Property</seealso>
<seealso cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave">FormatManager.FilterStringForSave Property</seealso>
            <overloads><summary>Returns filter string.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetFilterString(System.Int64)" draft="yes">
            <summary>Returns filter string for this format.</summary>
            <param name="format">An integer value that specifies a media format ID of necessary format.</param>
            <returns>The string value that contains the filter string for specified format.</returns>
            <remarks><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetFilterString(System.String,System.Int64[])" draft="yes">
            <summary>Returns filter string for open/save file dialogs that contains all specified file formats.</summary>
            <param name="title">Title of the filter string.</param>
            <param name="formats">Array of file formats identifiers.</param>
            <returns>String that contains a filter string for open/save file dialogs that contains all specified file formats and specified title.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetFormatDescription(System.Int64)">
            <summary>Returns user-friendly format description.</summary>
            <param name="format">An integer value that specifies a media format ID of necessary format.</param>
            <returns>The string value that contains the description for specified format.</returns>
            <remarks><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetFormatName(System.Int64)">
            <summary>Returns format name by specified ID.</summary>
            <param name="format">An integer value that specifies a media format ID of necessary format.</param>
            <returns>The string value that contains the name for specified format.</returns>
            <remarks><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetMediaFormat(System.String)" draft="yes">
            <summary>Recognizes the media format by the specified file name.</summary>
            <param name="fileName">The name of the file to get a media format for.</param>
            <returns>A number that specifies the media format number. You can use static members <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.TiffFormat" />, and its siblings to compare it with.</returns>
            <overloads><summary>Recognizes the media format of the given file or stream.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetMediaFormat(System.IO.Stream)" draft="yes">
            <summary>Recognizes the media format by the specified stream.</summary>
            <param name="stream">The stream to get a media format for.</param>
            <returns>A number that specifies the media format number. You can use static members <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.TiffFormat" />, and its siblings to compare it with.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.GetMimeType(System.Int64)">
            <summary>Returns mime type of the format by specified ID.</summary>
            <param name="format">An integer value that specifies a media format ID of necessary format.</param>
            <returns>The string value that contains the MIME type for specified format.</returns>
            <remarks><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat">
            <summary>GIF format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.Jpeg2kFormat">
            <summary>JPEG2000 format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat">
            <summary>JPEG format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.Mp3Format">
            <summary>MP3 format ID. Note, this format is supported only if you have Media Processor add-on.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.MpegFormat">
            <summary>MPEG format ID. Note, this format is supported only if you have Media Processor add-on.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.PcxFormat">
            <summary>PCX format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.PdfFormat">
            <summary>PDF format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.PngFormat">
            <summary>PNG format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.PsdFormat">
            <summary>PSD format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.QuickTimeFormat">
            <summary>QuickTime format ID. Note, this format is supported only if you have Media Processor add-on.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.RegisterFormatReader(System.Type)" draft="yes">
            <summary>Registers format reader and returns a boolean value indicating whether the registration was successful.</summary>
            <param name="pReaderType">The format reader type which implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatReader" /> interface.</param>
            <returns><b>true</b> if format reader was successfully registered; otherwise, <b>false</b>.</returns>
            <remarks>This method fails to register format reader with <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownFormat" /> or <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownBeforeOpenFormat" /> media format ID.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatManager.RegisterFormatWriter(System.Type)" draft="yes">
            <summary>Registers format writer and returns a boolean value indicating whether the registration was successful.</summary>
            <param name="pWriterType">The format writer type which implements the <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatWriter" /> interface.</param>
            <returns><b>true</b> if format writer was successfully registered; otherwise, <b>false</b>.</returns>
            <remarks>This method fails to register format writer with <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownFormat" /> or <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownBeforeOpenFormat" /> media format ID.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatManager.SupportedMediaFormatsForLoad">
            <summary>Gets an array of identifiers of media formats which can be read by Graphics Mill for .NET.</summary>
            <value>An array of identifiers of media formats which can be read by Graphics Mill for .NET.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatManager.SupportedMediaFormatsForSave">
            <summary>Gets an array of identifiers of media formats which can be written by Graphics Mill for .NET.</summary>
            <value>An array of identifiers of media formats which can be written by Graphics Mill for .NET.</value>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.SwfFormat">
            <summary>SWF format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.TiffFormat">
            <summary>TIFF format ID.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownBeforeOpenFormat">
            <summary>"Dummy" ID of an unknown format which is used before the stream is opened.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.UnknownFormat">
            <summary>"Dummy" ID of unknown format.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.FormatManager.WbmpFormat">
            <summary>WBMP format ID.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FormatReader" draft="yes">
            <summary>This is a base class for all format readers.</summary>
            <remarks><para>This class is derived by all format readers. It provides base functionality, i.e.:</para><list type="bullet"><item><description>Opening file or stream with appropriate overload of <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.String)" /> method. To check whether the reader is already opened, use <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.Opened" /> property.</description></item><item><description>Retrieving specified frame via <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.LoadFrame(System.Int32)" /> method. If you need to iterate all frames in the file, you can obtain total frame number using <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.FrameCount" /> property.</description></item><item><description>Checking whether this reader can read the file (i.e. you can determine whether file belongs specific format). Use <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.String)" /> method for it.</description></item><item><description>Getting details about the format. Use <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.FormatName" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.FormatDescription" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.MimeType" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.FilterString" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.DefaultExtension" />, and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.MediaFormat" /> properties. </description></item></list><para>Typically you use this class (rather than its descendant) when you use <see cref="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatReader(System.String)" /> method of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class to get a format reader of proper type. It allows you to write the decoding code once for all formats you are going to load.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.String)">
            <summary>Checks if the image can be loaded with this reader.</summary>
            <param name="fileName">The name of the file to test.</param>
            <returns>If image can be read with this reader, returns <b>true</b>, otherwise returns <b>false</b>.</returns>
            <remarks><para>You can use this method to ensure if the file has necessary format. For example, to check if the image is a GIF file, you should create an instance of <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class and call this method. It will return <b>true</b> for all GIF files and <b>false</b> for other formats.</para></remarks>
            <overloads><summary>Checks if the image can be loaded with this reader.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckForSupport(System.IO.Stream)">
            <summary>Checks if the image can be loaded with this reader.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns>If image can be read with this reader, returns <b>true</b>, otherwise returns <b>false</b>.</returns>
            <remarks><para>
You can use this method to ensure if the file has necessary format. For example, to check if the image is a GIF file, you should create an instance of <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class and call this method. It will return <b>true</b> for all GIF files and <b>false</b> for other formats.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckFrameParams(Aurigma.GraphicsMill.Codecs.Frame)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.CheckOpened">
            <summary>Checks if the format reader is opened.</summary>
            <remarks><para>This method is called whenever any reader property that is associated with an opened file (for example, dimensions or quality) is used. It is also called when the frame is loaded.</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.Opened" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.LoadFrame(System.Int32)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close">
            <summary>Closes format reader, and detaches it from previously opened file (or other media).</summary>
            <remarks><para>
You should always use this method to detach from opened file (or other media). As soon as you call  <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.String)" /> method, file will be locked until you close the reader. 
</para><para>If you close the reader which has not been opened, the method does nothing. So you need not do any checks to ensure if reader is opened to close it.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.CodecPriority">
            <summary>Returns the priority of the codec.</summary>
            <value>The priority of the codec.</value>
            <remarks>Graphics Mill for .NET uses this value to resolve the conflict when several codec classes are used to load the same file format. It will choose the codec class which has the higher priority.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.DefaultExtension">
            <summary>Returns default extension for this format.</summary>
            <value>Default extension for this format.</value>
            <remarks><para>
Default extension is used by file dialogs. If you type file name without extension, file dialog will automatically append this extension to it.
</para><para> 
This extension is returned in file mask form, i.e. includes asterisk: <c>*.[extension]</c>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.FormatReader" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.FormatReader" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.FilterString">
            <summary>Returns filter string for this format.</summary>
            <value>Filter string for this format.</value>
            <remarks><para>
Filter string is used in file dialogs to specify what files to display. Class <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> searches for all format readers and writers, requests <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatInfo" /> interface, and extracts filter strings of each format to make a filter string which makes visible all files of supported formats and hides unsupported files.
</para><para>
Filter string is returned in file mask form, i.e. includes asterisk. Multiple extensions are separated by semicolon: <c>*.[extension1];*.[extension2];*.[extension3]</c>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.FormatDescription">
            <summary>Returns user-friendly format description.</summary>
            <value>Format description.</value>
            <remarks><para>
This description is inserted as user-friendly filter name into filter string generated by <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave" /> properties of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.FormatName">
            <summary>Returns format name.</summary>
            <value>Format name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.FrameCount">
            <summary>Returns number of frames in the format reader.</summary>
            <value>Number of frames in the format reader.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.GetEnumerator">
            <summary>Returns an enumerator for the frames allowing the writer to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.IsFrameSeekable">
            <summary>Check whether the reader supports random access to frames.</summary>
            <value><b>true</b> if the file contains a seek index, and <b>false</b> otherwise.</value>
            <remarks><para>Some multi-frame file formats does not allow random access. To get a frame from a file of this format, you should get all previous frames.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.LoadFrame(System.Int32)" draft="yes">
            <summary>Returns a frame with specified index. This frame contains a bitmap and possible other details describing it.</summary>
            <param name="index">Index of the frame. Cannot exceed value specified with <see cref="P:Aurigma.GraphicsMill.Codecs.FormatReader.FrameCount" /> property.</param>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface and contains the data of the specified frame.</returns>
            <remarks><note type="caution">
Frames loaded with this method are not cached. It means that if you load a frame with some index, do some changes in this frame, and then load this frame through this method again, all changes will be lost.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.MediaFormat">
            <summary>Returns the ID of the media format this reader can read from.</summary>
            <value>An integer value that specifies a media format ID of this reader.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.MimeType">
            <summary>Returns mime type of the format.</summary>
            <value>Mime type of the format.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.OnClose" draft="yes">
            <summary>Frees resources when the reader closes.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.OnOpen" draft="yes">
            <summary>Called when the reader is opened.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.String)">
            <summary>Opens format reader on the specified file.</summary>
            <param name="fileName">The name of the file to read from.</param>
            <remarks>After you completed reading from file, you should close the reader with <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" /> method. Until that the file will be locked.</remarks>
            <overloads><summary>Opens format reader on specified media.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.IO.Stream)">
            <summary>Opens format reader on the specified stream.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> class instance that holds data to read from.</param>
            <remarks>After you completed reading, you should close the reader with <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatReader.Opened">
            <summary>Returns value that specifies whether the reader is opened.</summary>
            <value>Value that specifies whether the reader is opened.</value>
            <remarks>Reader becomes opened after you call <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Open(System.String)" /> method until the subsequent call of <see cref="M:Aurigma.GraphicsMill.Codecs.FormatReader.Close" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatReader.UpdateFormatInfo">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FormatReaderProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FormatWriter" draft="yes">
            <summary>This is a base class for all format writers.</summary>
            <remarks><para>This class is derived by all format writers. It provides the follwoing base functionality:</para><list type="bullet"><item><description>Opening file or stream with appropriate overload of <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Open(System.String)" /> method. To check whether the writer is already opened, use <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.Opened" /> property.</description></item><item><description>Writing frames (or one frame if only one is allowed) using <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> property.</description></item><item><description>Checking whether the bitmap with certain pixel format can be saved into this file format without conversion. Use <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)" /> method and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.SupportedPixelFormats" /> property for it.</description></item><item><description>Getting details about the format. Use <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FormatName" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FormatDescription" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.MimeType" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FilterString" />, <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.DefaultExtension" />, and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatWriter.MediaFormat" /> properties. </description></item></list><para>Typically you use this class (rather than its descendant) when you use <see cref="M:Aurigma.GraphicsMill.Codecs.FormatManager.CreateFormatWriter(System.String)" /> method of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class to get a format writer of proper type. It allows you to write the encoding code once for all formats you are going to save.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Abort">
            <summary>Aborts file writing operation.</summary>
            <remarks>The class which was aborted with this operation will throw the <see cref="T:Aurigma.GraphicsMill.AbortedException" />. In synchronous mode you need to use standard exception handling mechanism (try/catch block or its analogue). In asynchronous mode the exception is retrieved into <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event (as its argument). Event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Aborted" /> is also fired.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <summary>Appends specified frame to the end of file (or other media).</summary>
            <param name="frame">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface representing the frame which you need to add into the file (or other media).</param>
            <remarks>Note, this interface provides only <i>forward-only</i> writing support. So you cannot insert frames before frames which were already added, or remove some of them.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.CheckFrameParams(Aurigma.GraphicsMill.Codecs.Frame)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Close">
            <summary>Closes format writer, flushes all unsaved data, and detaches the writer from previously opened file (or other media).</summary>
            <remarks><para>
You should always use this method to detach from opened file (or other media). As soon as you call <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Open(System.String)" /> method, file will be locked until you close the writer. 
</para><para>If you close the writer which has not been opened, the method does nothing. So you need not do any checks to ensure if writer is opened to close it.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.CodecPriority">
            <summary>Returns the priority of the codec.</summary>
            <value>The priority of the codec.</value>
            <remarks>Graphics Mill for .NET uses this value to resolve the conflict when several codec classes are used to save to the same file format. It will choose the codec class which has the higher priority.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Continue">
            <summary>Resumes execution of the operation previously paused with <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Pause" /> method.</summary>
            <remarks>When operation is resumed, event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Continued" /> fires.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.DefaultExtension">
            <summary>Returns default extension for this format.</summary>
            <value>Default extension for this format.</value>
            <remarks><para>
Default extension is used by file dialogs. If you type file name without extension, file dialog will automatically append this extension to it.
</para><para> 
This extension is returned in file mask form, i.e. includes asterisk: <c>*.[extension]</c>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.ExportEncoderOptions" draft="yes">
            <summary>Exports all writer settings into the encoder options object.</summary>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and holds the writer settings.</returns>
            <overloads><summary>Exports all writer settings into the encoder options object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.ExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Exports all writer settings into the existing encoder options object.</summary>
            <param name="options">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and should contain the writer settings.</param>
            <remarks><para>The properties of the frame (if supported by the encoder options object) are neither removed nor modified.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FilterString">
            <summary>Returns filter string for this format.</summary>
            <value>Filter string for this format.</value>
            <remarks><para>
Filter string is used in file dialogs to specify what files to display. Class <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> searches for all format readers and writers, requests <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatInfo" /> interface, and extracts filter strings of each format to make a filter string which makes visible all files of supported formats and hides unsupported files.
</para><para>
Filter string is returned in file mask form, i.e. includes asterisk. Multiple extensions are separated by semicolon: <c>*.[extension1];*.[extension2];*.[extension3]</c>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FormatDescription">
            <summary>Returns user-friendly format description.</summary>
            <value>Format description.</value>
            <remarks><para>
This description is inserted as user-friendly filter name into filter string generated by <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave" /> properties of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.FormatName">
            <summary>Returns format name.</summary>
            <value>Format name.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface representing the frame of the format supported with this writer.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.ImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Initialize the writer settings from the encoder options object.</summary>
            <param name="options">An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which holds the frame settings.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns whether this format writer can handle bitmaps with specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies a pixel format necessary to be checked.</param>
            <returns>Value that equal to <b>true</b> when specified pixel format is supported, or <b>false</b> otherwise.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.MediaFormat">
            <summary>Returns the ID of the media format this reader can write to.</summary>
            <value>An integer value that specifies a media format ID of this writer.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.MimeType">
            <summary>Returns mime type of the format.</summary>
            <value>Mime type of the format.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnAfterAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <summary>Called after the frame is added to the stream.</summary>
            <param name="frame">The frame which has been added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnClose">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnOpen">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Open(System.String)" draft="yes">
            <summary>Opens format writer on the specified file.</summary>
            <param name="fileName">The name of the file to write to.</param>
            <remarks>After you completed writing to the file, you should close the writer with <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Close" /> method. Until that the file will be locked and some data may be not flushed.</remarks>
            <overloads><summary>Opens format writer.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Open(System.IO.Stream)">
            <summary>Opens format writer on the specified stream.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> class instance that holds data to write to.</param>
            <remarks>After you completed writing to the stream, you should close the writer with <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Close" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.Opened">
            <summary>Returns value that specifies if the writer is opened.</summary>
            <value>Value that specifies if the writer is opened.</value>
            <remarks>Writer becomes opened after you call <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Open(System.String)" /> method until the subsequent call of <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Close" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Pause">
            <summary>Pauses execution of the file writing operation.</summary>
            <remarks><para>
When operation is paused, <see cref="E:Aurigma.GraphicsMill.SyncHandler.Paused" /> event fires.
</para><para>
You can resume the execution using <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.Continue" /> method.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.FormatWriter.SupportedPixelFormats">
            <summary>Returns an array of pixel formats which are supported with this format writer.</summary>
            <value>An array of <see cref="T:Aurigma.GraphicsMill.PixelFormat" /> values which are supported with this format writer.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.FormatWriter.UpdateFormatInfo">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FormatWriterProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Frame">
            <summary>This is a base class for the frames.</summary>
            <remarks><para>
In general, frames stores the following information:
</para><list type="bullet"><item><description>Bitmap. You can get it using <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.GetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method. You can also receive its thumbnail using <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.GetThumbnail(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32)" /> method (it will work much faster than receiving thumbnail and then resizing it, because it will be done "on-the-fly").</description></item><item><description>Bitmap characteristics such as <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Width" />, <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Height" />, and <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.PixelFormat" />. These properties will extract these data without loading entire bitmap into memory, so it works extremely fast.</description></item><item><description>Frame position relatively entire file "canvas" (<see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> properties). As this "canvas" defined not for all the formats, these values are meaningless for such formats. In this case they are always equal to 0.</description></item></list><note type="note">
These data are read from file only once. After you read some property, it is cached and next time it returns pre-loaded data.  
</note></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.BitsPerPixel">
            <summary>Gets a number of bits per pixel in the bitmap stored in the frame.</summary>
            <value>An integer value which stores a number of bits per pixel of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.ColorProfile">
            <summary>Gets a color profile of the bitmap stored in the frame.</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance which represents the color profile of the current frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.ColorSpace">
            <summary>Gets a color space of the bitmap stored in the frame.</summary>
            <value>An <see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value which specifies a color space of the frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.ExportEncoderOptions" draft="yes">
            <summary>Exports all frame settings into encoder options object.</summary>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and holds the frame settings.</returns>
            <overloads><summary>Exports all frame settings into encoder options object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.ExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Exports all frame settings into the existing encoder options object.</summary>
            <param name="options">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and should contain the frame settings.</param>
            <remarks><para>The properties of the writer (if supported by the encoder options object) are neither removed nor modified.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.GetBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Returns bitmap stored in this frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance stored in the frame.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.GetThumbnail(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32)">
            <summary>Returns thumbnail of the bitmap stored in this frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance containing thumbnail stored in the frame.</param>
            <param name="width">Thumbnail width (in pixels). If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. Both <i>width</i> and <i>height</i> cannot be set to 0 at the same time.</param>
            <param name="height">Thumbnail height (in pixels). If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. Both <i>width</i> and <i>height</i> cannot be set to 0 at the same time.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.HasAlpha">
            <summary>Gets a value specifying whether the bitmap stored in the frame has alpha channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has alpha channel.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Height">
            <summary>Returns this frame height.</summary>
            <value>Frame height (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.HorizontalResolution">
            <summary>Gets a horizontal resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a horizontal resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.ImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Initialize the frame settings from the encoder options object.</summary>
            <param name="options">An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which holds the frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Index">
            <summary>Returns frame index in the format reader (if applicable).</summary>
            <value>Frame index in the format reader.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.IsCmyk">
            <summary>Gets a value specifying whether the bitmap stored in the frame is CMYK.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is CMYK.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.IsExtended">
            <summary>Gets a value specifying whether the bitmap stored in the frame has 16 bits per channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has 16 bits per channel (i.e. extended pixel format).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.IsGrayScale">
            <summary>Gets a value specifying whether the bitmap stored in the frame is grayscale.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is grayscale.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.IsIndexed">
            <summary>Gets a value specifying whether the bitmap stored in the frame is indexed.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is indexed.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.IsRgb">
            <summary>Gets a value specifying whether the bitmap stored in the frame is RGB.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is RGB.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Left">
            <summary>Returns horizontal position of the left top corner of the frame.</summary>
            <value>X-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.LockLoadingBitmap(Aurigma.GraphicsMill.Bitmap)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.LockLoadingBitmap(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.BitmapChange)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Name">
            <summary>Returns frame name (if defined).</summary>
            <value>Frame name.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.#ctor(Aurigma.GraphicsMill.Codecs.FormatReader,System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.PixelFormat">
            <summary>Returns a pixel format of the bitmap stored in this frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies a pixel format of the bitmap stored in this frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Puts a bitmap into frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame.</param>
            <remarks>If this frame is associated with some format reader, this method <b>will not</b> write the bitmap into it (instead of previously associated bitmap). The purpose of this method is to initialize internal <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object with proper bitmap before passing this frame into <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Top">
            <summary>Returns vertical position of the left top corner of the frame.</summary>
            <value>Y-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.UnlockLoadingBitmap(Aurigma.GraphicsMill.Bitmap)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Frame.UnlockLoadingBitmap(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.BitmapChange)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.VerticalResolution">
            <summary>Gets a vertical resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a vertical resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Frame.Width">
            <summary>Returns this frame width.</summary>
            <value>Frame width (in pixels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.FrameProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions">
            <summary>This class holds GIF encoder options.</summary>
            <remarks><para>
This class enables to initialize both entire GIF file and separate frames settings. Usually you can use this class from <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event handler to modify both global and frames settings. If you set global settings for the same file multiple times, only settings specified at the first time are used.
</para><para>This table gives the explanation for all GIF settings:</para><list type="table"><listheader><term>Property</term><term>Description</term></listheader><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> (frame)</description><description>Specifies a delay of the frame (how long should it be displayed).</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod" /> (frame)</description><description>Specifies a disposal method for the frame (what to do with the screen when new frame is being displayed).</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> (frame)</description><description>Specifies whether the frame should be interlaced.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BackgroundEntryIndex" /> (global)</description><description>Specifies an entry in the global palette which is treated as a background.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.GlobalPalette" /> (global)</description><description>Specifies a global palette for entire GIF file.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LocalPaletteEnabled" /> (global)</description><description>Specifies whether to use local palettes for each frame or use global palette only.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.PlaybackCount" /> (global)</description><description>Specifies how much times the GIF should be animated (or if it should be played infinitely).</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> (global)</description><description>Specifies a width of the GIF file. If dimensions of frame is larger of GIF dimensions, frame bitmap is cropped.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> (global)</description><description>Specifies a height of the GIF file. If dimensions of frame is larger of GIF dimensions, frame bitmap is cropped.</description></item></list><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are used to specify offset of the frame relatively top left corner of the GIF.</para></remarks>
            <example><para>Let's assume that we want to load a JPEG file and save this image as a web-optimized GIF file (for example, reduce number of colors to 32). This code sample demonstrates how to do it: </para><code language="VB" source="FileFormatsVB/form1.vb#GIFSync"></code><code language="CS" source="FileFormatsCS/form1.cs#GIFSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BackgroundEntryIndex">
            <summary>Gets/sets an index of the background color.</summary>
            <value>An index in the global palette for the background color.</value>
            <remarks><para>Using this property you can also disable background. To do this, pass -1.</para><para>
If <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.GlobalPalette" /> is not specified, this property is ignored (the same effect as specifying -1).
</para><para>Default value is -1.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BasisOptimizationFrameCount">
            <summary>Gets/sets the number of frames that will be stored before the global palette will be saved.</summary>
            <value>Number of frames to store. If this value is <c>-1</c>, there is no limit for the number of frames used to build a global palette for.</value>
            <remarks><para>If the optimization is enabled (the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Optimized" /> property is set to <b>true</b>), Graphics Mill for .NET will try to build a global palette which is common for all frames (other optimization activities are done as well, but they do not concern this property). Due a GIF format specification, no image data may be written before the global palette is saved. Therefore we cannot write a frame as soon as the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method is called. Instead of it we should store the frame in memory before the global palette will be generated and saved to the memory. Frames will be saved to the file only when the writer is closed.
            </para><para>Obviously, if you add too many frames, it will consume too much memory. To avoid this, use this value to specify a threshold for the number of frames to build a global palette for. </para><para>
              Another way to stop gathering statistics for the global palette is to set the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" /> property to <b>true</b> on the frame we would like to stop. In this case the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BasisOptimizationFrameCount" /> will be disregarded.
            </para><para>If you add some frames after global palette is generated, and all entries of palettes of these frames are the same as in the global palette, Graphics Mill for .NET automatically uses the global palette. However if at least one color will not be contained in the global palette, this frame will be saved with a local palette.</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Optimized" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay">
            <summary>Gets/sets a number of hundredths (1/100) of a second to wait after rendering the frame.</summary>
            <value>Number of hundredths (1/100) of a second to wait after rendering the frame.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod">
            <summary>Gets/sets disposal method, i.e. what to do with the screen when new frame is being displayed.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.GlobalPalette">
            <summary>Gets/sets a global palette for the animated frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance that specifies a global palette for the animated GIF.</value>
            <remarks><para>
Using global palette may noticeable reduce result file size, however it requires some additional preparations of the GIF frames. Besides, you will not be able to use different colors in each frame.
</para><para>
By default the global palette is not initialized (it is set to <b>null</b>).
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height">
            <summary>Gets/sets entire GIF file height.</summary>
            <value>Entire GIF file height (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> properties you specify a "viewport" for the GIF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced">
            <summary>Gets/sets a value that specifies if the frame should be interlaced.</summary>
            <value>Value that specifies if the frame should be interlaced.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame">
            <summary>Gets/sets a value that specifies if the current frame is the last frame the global palette is generated for.</summary>
            <value>Value that specifies if the last frame is reached.</value>
            <remarks><para>If the optimization is enabled (the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Optimized" /> property is set to <b>true</b>), Graphics Mill for .NET will try to build a global palette which is common for all frames (other optimization activities are done as well, but they do not concern this property). Due a GIF format specification, no image data may be written before the global palette is saved. Therefore we cannot write a frame as soon as the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method is called. Instead of it we should store the frame in memory before the global palette will be generated and saved to the memory. Frames will be saved to the file only when the writer is closed.</para><para>Obviously, if you add too many frames, it will consume too much memory. To avoid this, set the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" /> property to <b>true</b> on the frame we would like to stop. As soon as you do it, the global palette will be generated and all frames will be flushed into the file.</para><para>Another way to stop gathering statistics for the global palette is to specify a threshold for the number of frames to build a global palette for using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BasisOptimizationFrameCount" /> property.</para><para>If you add some frames after global palette is generated, and all entries of palettes of these frames are the same as in the global palette, Graphics Mill for .NET automatically uses the global palette. However if at least one color will not be contained in the global palette, this frame will be saved with a local palette.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LocalPaletteEnabled">
            <summary>Gets/sets a value that specify if local palette of the frames should be saved (otherwise global palette will be used).</summary>
            <value>Value that specify if local palette of the frames should be saved.</value>
            <remarks><para>If you disable this property, you should initialize <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.GlobalPalette" /> property with correct palette object.</para><para>Default value is <b>true</b>.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property here.</summary>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize frame-related properties here.</summary>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.  You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize frame-related properties here.</summary>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.  You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
            <param name="lastFrame">Value that specifies if the current frame is the last frame the global palette is generated for. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize some frame-related properties here.</summary>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize frame-related properties and GIF dimensions here.</summary>
            <param name="width">Entire GIF file width (in pixels). You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> property.</param>
            <param name="height">Entire GIF file height (in pixels). You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize frame-related properties and GIF dimensions here.</summary>
            <param name="width">Entire GIF file width (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> property.</param>
            <param name="height">Entire GIF file height (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
            <param name="lastFrame">Value that specifies if the current frame is the last frame the global palette is generated for. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifEncoderOptions" /> class instance. You can initialize some frame-related properties and GIF dimensions here.</summary>
            <param name="width">Entire GIF file width (in pixels). You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> property.</param>
            <param name="height">Entire GIF file height (in pixels). You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Delay" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Optimized">
            <summary>Gets/sets a value that specifies if the frame is optimized.</summary>
            <value>Value that specifies if the frame is optimized.</value>
            <remarks><para>When the optimization is enabled, the following algorithms are applied: </para><list type="bullet"><item><description>Global palette common to all frames is generated, and all frames are using this palette. To control this algorithm, use the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.BasisOptimizationFrameCount" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" /> properties.</description></item><item><description>If the neigbour frames have the same portions of the image the frame is automatically cropped (if possible).</description></item><item><description>If some pixels in the neigbour frames are the same, they are replaced by the transparent ones (if possible).</description></item></list></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.PlaybackCount">
            <summary>Gets/sets a number of times to play the GIF file.</summary>
            <value>A number of times to play the GIF file.</value>
            <remarks><para>If this property is 0, the file is played infinitely.</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width">
            <summary>Gets/sets entire GIF file width.</summary>
            <value>Entire GIF file width (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Height" /> properties you specify a "viewport" for the GIF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.GifFrame" draft="yes">
            <summary>This class represents a frame of the GIF format.</summary>
            <example><para>This code sample demonstrates how to create an animated GIF file from several JPEG files. Draw attention, you can use this code to save simple GIF files too (by passing the single frame into it). </para><code language="VB" source="FileFormatsVB/form1.vb#GIFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#GIFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.ColorKeyIndex">
            <summary>Returns an index of transparent palette entry.</summary>
            <value>Index of the transparent palette entry. If the frame has no transparent areas, -1 is returned.</value>
            <remarks><para>
This value is read from GIF file rather than obtained from the bitmap. It means that if you modify the bitmap with <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method, it will still return the value stored in the file this frame is associated with. Therefore this property has limited usage. 
</para><para>
This property is not used when you pass this frame into <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" />. Instead of that writer analyzes the palette of the image stored in this frame and initalizes this value in the result GIF file with it.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.Delay">
            <summary>Gets/sets a number of hundredths (1/100) of a second to wait after rendering the frame.</summary>
            <value>Number of hundredths (1/100) of a second to wait after rendering the frame.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.DisposalMethod">
            <summary>Gets/sets disposal method, i.e. what to do with the screen when new frame is being displayed.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced">
            <summary>Gets/sets a value that specifies if the frame should be interlaced.</summary>
            <value>Value that specifies if the frame should be interlaced.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame">
            <summary>Gets/sets a value that specifies if the current frame is the last frame the global palette is generated for.</summary>
            <value>Value that specifies if the last frame is reached.</value>
            <remarks><para>If the optimization is enabled (the <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Optimized" /> property is set to <b>true</b>), Graphics Mill for .NET will try to build a global palette which is common for all frames (other optimization activities are done as well, but they do not concern this property). Due a GIF format specification, no image data may be written before the global palette is saved. Therefore we cannot write a frame as soon as the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method is called. Instead of it we should store the frame in memory before the global palette will be generated and saved to the memory. Frames will be saved to the file only when the writer is closed.
            </para><para>
              Obviously, if you add too many frames, it will consume too much memory. To avoid this, set the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" /> property to <b>true</b> on the frame we would like to stop. As soon as you do it, the global palette will be generated and all frames will be flushed into the file.
            </para><para>
              Another way to stop gathering statistics for the global palette is to specify a threshold for the number of frames to build a global palette for using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.BasisOptimizationFrameCount" /> property.
            </para><para>If you add some frames after global palette is generated, and all entries of palettes of these frames are the same as in the global palette, Graphics Mill for .NET automatically uses the global palette. However if at least one color will not be contained in the global palette, this frame will be saved with a local palette.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifFrame.LocalPaletteEnabled">
            <summary>Specifies if local palette of the frames should be saved (otherwise global palette will be used).</summary>
            <value>Value that specify if local palette of the frames should be saved.</value>
            <remarks><para>If you disable this property, you should initialize <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.GlobalPalette" /> property with correct palette object.</para><para>Default value is <b>true</b>.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance. You can associate a bitmap with it.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use the <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance. You can associate a bitmap with it as well as set frame position and interlacing option here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean,System.Boolean)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
            <param name="lastFrame">Value that specifies if the frame is the last one and the global palette can be saved immediately. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> instance. You can initialize the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property here.</summary>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance. You can set frame position and interlacing option here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance. You can set most of the frame settings here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Boolean,System.Boolean)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> instance. You can set all the frame settings here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.DisposalMethod" /> property.</param>
            <param name="interlaced">Value that specifies if the frame should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.Interlaced" /> property.</param>
            <param name="lastFrame">Value that specifies if the frame is the last one and the global palette can be saved immediately. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.LastFrame" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.GifReader">
            <summary>This class enables you to read GIF images.</summary>
            <remarks><para>The GIF format was designed by Compuserve in 1987. Since then it has become very popular for general image exchange. There are two types of GIF files; GIF87a, the original standard of 1987 and GIF89a, the revised standard of 1989. All of these formats are available for reading in Graphics Mill for .NET and GIF89a format is available for saving. Main advantage of GIF89a against GIF87a is animation and transparency support.</para><para>The GIF format is a lossless format and is good for saving any type of image that has 256 colors (or shades of gray), or fewer. This format is suitable as a generalized format for image exchange, however the color information limit in the format may require you to choose PNG, TIFF or JPEG instead of it. In general this is the best format for images with a limited number of colors, since the compression ratio is good (it is difficult to obtain better compression and stay lossless) and GIF files can be decompressed very quickly. GIF image format supports one-dimensional interlacing (a method of progressive display), this makes this format convenient for transmission images across slow communication links. That is why this format is very popular for Web graphics. </para><para>
GIF format can store only indexed images. As soon as it supports animation, it can contain multiple frames. Frame can have its own position, and a number of other paramaters, as delay time, disposal method, etc.
</para></remarks>
            <example><para>This code sample demonstrates how to process animated GIF. For example, if you need to resize an animated GIF, you can use this code:</para><code language="VB" source="FileFormatsVB/form1.vb#GifAnimated"></code><code language="CS" source="FileFormatsCS/form1.cs#GifAnimated"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifReader.BackgroundEntryIndex">
            <summary>Returns an index of the background color.</summary>
            <value>An index in the global palette for the background color.</value>
            <remarks><para>If this property equals to -1, background color is disabled.</para><para>
If <see cref="P:Aurigma.GraphicsMill.Codecs.GifReader.GlobalPalette" /> is not specified (set to <b>null</b>), this property is meaningless.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifReader.GlobalPalette">
            <summary>Returns a global palette for the animated frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance that specifies a global palette for the animated GIF.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifReader.Height">
            <summary>Returns entire GIF file height.</summary>
            <value>Entire GIF file height (in pixels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.
</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifReader.OnOpen">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifReader.PlaybackCount">
            <summary>Returns a number of times to play the GIF file.</summary>
            <value>A number of times to play the GIF file.</value>
            <remarks><para>If this property is 0, the file is played infinitely.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifReader.Width">
            <summary>Returns entire GIF file width.</summary>
            <value>Entire GIF file width (in pixels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.GifWriter" draft="yes">
            <summary>This class enables you to write GIF images (both static and animated).</summary>
            <remarks><para>The GIF format was designed by Compuserve in 1987. Since then it has become very popular for general image exchange. There are two types of GIF files; GIF87a, the original standard of 1987 and GIF89a, the revised standard of 1989. All of these formats are available for reading in Graphics Mill for .NET and GIF89a format is available for saving. Main advantage of GIF89a against GIF87a is animation and transparency support.</para><para>The GIF format is a lossless format and is good for saving any type of image that has 256 colors (or shades of gray), or fewer. This format is suitable as a generalized format for image exchange, however the color information limit in the format may require you to choose PNG, TIFF or JPEG instead of it. In general this is the best format for images with a limited number of colors, since the compression ratio is good (it is difficult to obtain better compression and stay lossless) and GIF files can be decompressed very quickly. GIF image format supports one-dimensional interlacing (a method of progressive display), this makes this format convenient for transmission images across slow communication links. That is why this format is very popular for Web graphics. </para><para>
GIF format can store only indexed images. As soon as it supports animation, it can contain multiple frames. Frame can have its own position, and a number of other paramaters, as delay time, disposal method, etc.
</para></remarks>
            <example><para>This code sample demonstrates how to create an animated GIF file from several JPEG files. Draw attention, you can use this code to save simple GIF files too (by passing the single frame into it). </para><code language="VB" source="FileFormatsVB/form1.vb#GIFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#GIFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.BackgroundEntryIndex">
            <summary>Specifies an index of the background color.</summary>
            <value>An index in the global palette for the background color.</value>
            <remarks><para>Using this property you can also disable background. To do this, pass -1.</para><para>
If <see cref="P:Aurigma.GraphicsMill.Codecs.GifEncoderOptions.GlobalPalette" /> is not specified, this property is ignored (the same effect as specifying -1).
</para><para>Default value is -1.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.BasisOptimizationFrameCount">
            <summary>Gets/sets the number of frames that will be stored before the global palette will be saved.</summary>
            <value>Number of frames to store. If this value is <c>-1</c>, there is no limit for the number of frames used to build a global palette for.</value>
            <remarks><para>If the optimization is enabled (the <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Optimized" /> property is set to <b>true</b>), Graphics Mill for .NET will try to build a global palette which is common for all frames (other optimization activities are done as well, but they do not concern this property). Due a GIF format specification, no image data may be written before the global palette is saved. Therefore we cannot write a frame as soon as the <see cref="M:Aurigma.GraphicsMill.Codecs.FormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method is called. Instead of it we should store the frame in memory before the global palette will be generated and saved to the memory. Frames will be saved to the file only when the writer is closed.</para><para>Obviously, if you add too many frames, it will consume too much memory. To avoid this, use this value to specify a threshold for the number of frames to build a global palette for. </para><para>Another way to stop gathering statistics for the global palette is to set the <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" /> property to <b>true</b> on the frame we would like to stop. In this case the <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.BasisOptimizationFrameCount" /> will be disregarded.</para><para>If you add some frames after global palette is generated, and all entries of palettes of these frames are the same as in the global palette, Graphics Mill for .NET automatically uses the global palette. However if at least one color will not be contained in the global palette, this frame will be saved with a local palette.</para></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Optimized" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.GifFrame" /> class instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.GlobalPalette">
            <summary>Specifies a global palette for the animated frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance that specifies a global palette for the animated GIF.</value>
            <remarks><para>
Using global palette may noticeable reduce result file size, however it requires some additional preparations of the GIF frames. Besides, you will not be able to use different colors in each frame.
</para><para>
By default the global palette is not initialized (it is set to <b>null</b>).
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.Height">
            <summary>Specifies entire GIF file height.</summary>
            <value>Entire GIF file height (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Height" /> properties you specify a "viewport" for the GIF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.GifWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.GifWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.Optimized">
            <summary>Gets/sets a value that specifies if the image is optimized.</summary>
            <value>Value that specifies if the image is optimized.</value>
            <remarks><para>When the optimization is enabled, the following algorithms are applied: </para><list type="bullet"><item><description>Global palette common to all frames is generated, and all frames are using this palette. To control this algorithm, use the <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.BasisOptimizationFrameCount" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifFrame.LastFrame" /> properties.</description></item><item><description>If the neigbour frames have the same portions of the image the frame is automatically cropped (if possible).</description></item><item><description>If some pixels in the neigbour frames are the same, they are replaced by the transparent ones (if possible).</description></item></list></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.PlaybackCount">
            <summary>Specifies a number of times to play the GIF file.</summary>
            <value>A number of times to play the GIF file.</value>
            <remarks><para>If this property is 0, the file is played infinitely.</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.GifWriter.Width">
            <summary>Specifies entire GIF file width.</summary>
            <value>Entire GIF file width (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.GifWriter.Height" /> properties you specify a "viewport" for the GIF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions">
            <summary>This interface is implemented with all the encoder options objects.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IEncoderOptions.Left">
            <summary>Gets/sets left position of the frame.</summary>
            <value>X-coordinate of the top left corner of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IEncoderOptions.MediaFormat">
            <summary>Returns media format for which encoder options are defined.</summary>
            <value>An integer value that specifies a media format ID for which encoder options are defined.</value>
            <remarks><para>Each descendant class returns fixed value specifying media format it represents.</para><para>
              Each format supported with Graphics Mill for .NET has its own format ID. They are represented by static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" />, such as <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" />, <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.GifFormat" />, etc.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IEncoderOptions.Top">
            <summary>Gets/sets top position of the frame.</summary>
            <value>Y-coordinate of the top left corner of the frame.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IFormatInfo">
            <summary>This interface is implemented by all Graphics Mill for .NET format readers and writers to provide information about the formats.</summary>
            <remarks>In particular it is used to get filter string for open and save file dialogs (see <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave" /> properties of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class).</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatInfo.DefaultExtension">
            <summary>Returns default extension for this format.</summary>
            <value>Default extension for this format.</value>
            <remarks><para>
Default extension is used by file dialogs. If you type file name without extension, file dialog will automatically append this extension to it.
</para><para> 
This extension is returned in file mask form, i.e. includes asterisk: <c>*.[extension]</c>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatInfo.FilterString">
            <summary>Returns filter string for this format.</summary>
            <value>Filter string for this format.</value>
            <remarks><para>
Filter string is used in file dialogs to specify what files to display. Class <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> searches for all format readers and writers, requests <see cref="T:Aurigma.GraphicsMill.Codecs.IFormatInfo" /> interface, and extracts filter strings of each format to make a filter string which makes visible all files of supported formats and hides unsupported files.
</para><para>
Filter string is returned in file mask form, i.e. includes asterisk. Multiple extensions are separated by semicolon: <c>*.[extension1];*.[extension2];*.[extension3]</c>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatInfo.FormatDescription">
            <summary>Returns user-friendly format description.</summary>
            <value>Format description.</value>
            <remarks><para>
This description is inserted as user-friendly filter name into filter string generated by <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForLoad" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.FormatManager.FilterStringForSave" /> properties of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatInfo.FormatName">
            <summary>Returns format name.</summary>
            <value>Format name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatInfo.MimeType">
            <summary>Returns mime type of the format.</summary>
            <value>Mime type of the format.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IFormatReader">
            <summary>This interface is implemented by all Graphics Mill for .NET format readers to provide reading data (both bitmaps and meta information) functionality.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.CheckForSupport(System.String)" draft="yes">
            <summary>Checks if the image can be loaded with this reader.</summary>
            <param name="fileName">Filename for the image to test.</param>
            <returns>If image can be read with this reader, returns <b>true</b>, otherwise returns <b>false</b>.</returns>
            <remarks>You can use this method to ensure if the file has necessary format. For example, to check if the image is a GIF file, you should create an instance of <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class and call this method. It will return <b>true</b> for all GIF files and <b>false</b> for other formats.</remarks>
            <overloads><summary>Checks if the image can be loaded with this reader.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.CheckForSupport(System.IO.Stream)">
            <summary>Checks if the image can be loaded with this reader.</summary>
            <param name="stream">Stream that contains the image to test.</param>
            <returns>If image can be read with this reader, returns <b>true</b>, otherwise returns <b>false</b>.</returns>
            <remarks><para>
You can use this method to ensure if the file has necessary format. For example, to check if the image is a GIF file, you should create an instance of <see cref="T:Aurigma.GraphicsMill.Codecs.GifReader" /> class and call this method. It will return <b>true</b> for all GIF files and <b>false</b> for other formats.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Close">
            <summary>Closes format reader, and detaches it from previously opened file (or other media).</summary>
            <remarks><para>
You should always use this method to detach from opened file (or other media). As soon as you call  <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Open(System.String)" /> method, file will be locked until you close the reader. 
</para><para>If you close the reader which has not been opened, the method does nothing. So you need not do any checks to ensure if reader is opened to close it.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatReader.CodecPriority">
            <summary>Returns the priority of the codec.</summary>
            <value>The priority of the codec.</value>
            <remarks>Graphics Mill for .NET uses this value to resolve the conflict when several codec classes are used to load the same file format. It will choose the codec class which has the higher priority.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatReader.FrameCount">
            <summary>Returns number of frames in the format reader.</summary>
            <value>Number of frames in the format reader.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatReader.IsFrameSeekable">
            <summary>Check whether the reader supports random access to frames.</summary>
            <value><b>true</b> if the file contains a seek index, and <b>false</b> otherwise.</value>
            <remarks><para>Some multi-frame file formats does not allow random access. To get a frame from a file of this format, you should get all previous frames.</para></remarks>
            <seealso href="ReadingVideoFrameByFrame.htm">Reading Video Files Frame by Frame</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.LoadFrame(System.Int32)">
            <summary>Returns a frame with specified index. This frame contains a bitmap and possible other details describing it.</summary>
            <param name="index">Index of the frame. Cannot exceed value specified with <see cref="P:Aurigma.GraphicsMill.Codecs.IFormatReader.FrameCount" /> property.</param>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface and contains the data of the specified frame.</returns>
            <remarks><note type="caution">
Frames loaded with this method are not cached. It means that if you load a frame with some index, do some changes in this frame, and then load this frame through this method again, all changes will be lost.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatReader.MediaFormat">
            <summary>Returns the ID of the media format this reader can read from.</summary>
            <value>An integer value that specifies a media format ID of this reader.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Open(System.String)">
            <summary>Opens format reader on the specified file.</summary>
            <param name="fileName">Name of the file to read from.</param>
            <remarks>After you completed reading from file, you should close the reader with <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Close" /> method. Until that the file will be locked.</remarks>
            <overloads><summary>Opens format reader on specified media.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Open(System.IO.Stream)">
            <summary>Opens format reader on the specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> class instance that holds data to read from.</param>
            <remarks>After you completed reading, you should close the reader with <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Close" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatReader.Opened">
            <summary>Returns value that specifies if the reader is opened.</summary>
            <value>Value that specifies if the reader is opened.</value>
            <remarks>Reader becomes opened after you call <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Open(System.String)" /> method without subsequent call of <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatReader.Close" /> method.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IFormatWriter">
            <summary>This interface is implemented by all Graphics Mill for .NET format readers to provide writing data (both bitmaps and meta information) functionality.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)">
            <summary>Appends specified frame to the end of file (or other media).</summary>
            <param name="frame">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface representing the frame which you need to add into the file (or other media).</param>
            <remarks>Note, this interface provides only <i>forward-only</i> writing support. So you cannot insert frames before frames which were already added, or remove some of them.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Close">
            <summary>Closes format writer, flushes all unsaved data, and detaches the writer from previously opened file (or other media).</summary>
            <remarks><para>
You should always use this method to detach from opened file (or other media). As soon as you call <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Open(System.String)" /> method, file will be locked until you close the writer. 
</para><para>If you close the writer which has not been opened, the method does nothing. So you need not do any checks to ensure if writer is opened to close it.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatWriter.CodecPriority">
            <summary>Returns the priority of the codec.</summary>
            <value>The priority of the codec.</value>
            <remarks>Graphics Mill for .NET uses this value to resolve the conflict when several codec classes are used to save to the same file format. It will choose the codec class which has the higher priority.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.ExportEncoderOptions" draft="yes">
            <summary>Exports all writer settings into the encoder options object.</summary>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and holds the writer settings.</returns>
            <overloads><summary>Exports all writer settings into the encoder options object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.ExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Exports all writer settings into the existing encoder options object.</summary>
            <param name="options">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and should contain the writer settings.</param>
            <remarks><para>The properties of the frame (if supported by the encoder options object) are neither removed nor modified.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns>An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IFrame" /> interface representing the frame of the format supported with this writer.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.ImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Initialize the writer settings from the encoder options object.</summary>
            <param name="options">An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which holds the frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatWriter.MediaFormat">
            <summary>Returns the ID of the media format this reader can write to.</summary>
            <value>An integer value that specifies a media format ID of this writer.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Open(System.String)">
            <summary>Opens format writer on the specified file.</summary>
            <param name="fileName">Name of the file to write to.</param>
            <remarks>After you completed writing to the file, you should close the writer with <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Close" /> method. Until that the file will be locked and some data may be not flushed.</remarks>
            <overloads><summary>Opens format writer on specified media.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Open(System.IO.Stream)">
            <summary>Opens format writer on the specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> class instance that holds data to write to.</param>
            <remarks>After you completed writing to the stream, you should close the writer with <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Close" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFormatWriter.Opened">
            <summary>Returns value that specifies if the writer is opened.</summary>
            <value>Value that specifies if the writer is opened.</value>
            <remarks>Writer becomes opened after you call <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Open(System.String)" /> method without subsequent call of <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.Close" /> method.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IFrame">
            <summary>This interface is implemented by objects which represents media formats frames.</summary>
            <remarks><para>
In general, frames stores the following information:
</para><list type="bullet"><item><description>Bitmap. You can get it using <see cref="M:Aurigma.GraphicsMill.Codecs.IFrame.GetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method. You can also receive its thumbnail using <see cref="M:Aurigma.GraphicsMill.Codecs.IFrame.GetThumbnail(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32)" /> method (it will work much faster than receiving thumbnail and then resizing it, because it will be done "on-the-fly").</description></item><item><description>Bitmap characteristics such as <see cref="P:Aurigma.GraphicsMill.Codecs.IFrame.Width" />, <see cref="P:Aurigma.GraphicsMill.Codecs.IFrame.Height" />, and <see cref="P:Aurigma.GraphicsMill.Codecs.IFrame.PixelFormat" />. These properties will extract these data without loading entire bitmap into memory, so it works extremely fast.</description></item><item><description>Frame position relatively entire file "canvas" (<see cref="P:Aurigma.GraphicsMill.Codecs.IFrame.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.IFrame.Top" /> properties). As this "canvas" defined not for all the formats, these values are meaningless for such formats. In this case they are always equal to 0.</description></item></list><note type="note">
These data are read from file only once. After you read some property, it is cached and next time it returns pre-loaded data.  
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.BitsPerPixel">
            <summary>Gets a number of bits per pixel in the bitmap stored in the frame.</summary>
            <value>An integer value which stores a number of bits per pixel of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.ColorProfile">
            <summary>Gets a color profile of the bitmap stored in the frame.</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance which represents the color profile of the current frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.ColorSpace">
            <summary>Gets a color space of the bitmap stored in the frame.</summary>
            <value>An <see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value which specifies a color space of the frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.ExportEncoderOptions" draft="yes">
            <summary>Exports all frame settings into the encoder options object.</summary>
            <returns>An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which holds the frame settings.</returns>
            <overloads><summary>Exports all frame settings into the encoder options object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.ExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports all frame settings into the existing encoder options object.</summary>
            <param name="options">An object which implements <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface and should contain the frame settings.</param>
            <remarks><para>The properties of the writer (if supported by the encoder options object) are neither removed nor modified.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.GetBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Returns bitmap stored in this frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance stored in the frame.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.GetThumbnail(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32)">
            <summary>Returns thumbnail of the bitmap stored in this frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance containing thumbnail stored in the frame.</param>
            <param name="width">Thumbnail width (in pixels). If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. Both <i>width</i> and <i>height</i> cannot be set to 0 at the same time.</param>
            <param name="height">Thumbnail height (in pixels). If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. Both <i>width</i> and <i>height</i> cannot be set to 0 at the same time.</param>
            <remarks><para>Thumbnail is generated for the bitmap stored inside frame. If no bitmap loaded yet (<see cref="M:Aurigma.GraphicsMill.Codecs.IFrame.GetBitmap(Aurigma.GraphicsMill.Bitmap)" /> was not previously called), this method creates a thumbnail from file "on-the-fly" (without loading entire bitmap into memory). If bitmap is already loaded with <see cref="M:Aurigma.GraphicsMill.Codecs.IFrame.GetBitmap(Aurigma.GraphicsMill.Bitmap)" /> or specified by <see cref="M:Aurigma.GraphicsMill.Codecs.IFrame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method, thumbnail is created for this image  (actual content of file is not read).</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.HasAlpha">
            <summary>Gets a value specifying whether the bitmap stored in the frame has alpha channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has alpha channel.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Height">
            <summary>Returns this frame height.</summary>
            <value>Frame height (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.HorizontalResolution">
            <summary>Gets a horizontal resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a horizontal resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.ImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <summary>Fills the frame settings from the encoder options object.</summary>
            <param name="options">An object implementing <see cref="T:Aurigma.GraphicsMill.Codecs.IEncoderOptions" /> interface which holds the frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Index">
            <summary>Returns frame index in the format reader (if applicable).</summary>
            <value>Frame index in the format reader.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.IsCmyk">
            <summary>Gets a value specifying whether the bitmap stored in the frame is CMYK.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is CMYK.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.IsExtended">
            <summary>Gets a value specifying whether the bitmap stored in the frame has 16 bits per channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has 16 bits per channel (i.e. extended pixel format).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.IsGrayScale">
            <summary>Gets a value specifying whether the bitmap stored in the frame is grayscale.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is grayscale.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.IsIndexed">
            <summary>Gets a value specifying whether the bitmap stored in the frame is indexed.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is indexed.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.IsRgb">
            <summary>Gets a value specifying whether the bitmap stored in the frame is RGB.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is RGB.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Left">
            <summary>Returns horizontal position of the left top corner of the frame.</summary>
            <value>X-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Name">
            <summary>Returns frame name (if defined).</summary>
            <value>Frame name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.PixelFormat">
            <summary>Returns a pixel format of the bitmap stored in this frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies a pixel format of the bitmap stored in this frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IFrame.SetBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Puts a bitmap into frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame.</param>
            <remarks>If this frame is associated with some format reader, this method <b>will not</b> write the bitmap into it (instead of previously associated bitmap). The purpose of this method is to initialize internal <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object with proper bitmap before passing this frame into <see cref="M:Aurigma.GraphicsMill.Codecs.IFormatWriter.AddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Top">
            <summary>Returns vertical position of the left top corner of the frame.</summary>
            <value>Y-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.VerticalResolution">
            <summary>Gets a vertical resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a vertical resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IFrame.Width">
            <summary>Returns this frame width.</summary>
            <value>Frame width (in pixels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport" draft="yes">
            <summary>This interface should be supported by each format reader that can obtain metadata (such as EXIF, IPTC, XMP or Adobe image resource blocks) from the file.</summary>
            <remarks><para>
Using this interface is easy. You can get EXIF and IPTC metadata dictionaries using <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Exif" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Iptc" /> properties. After that just pass necessary tag ID into <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> property of these dictionaries. Most popular tags are predefined as a static members of <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and  <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.
</para><para>
The value of the <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.AdobeResources" /> property is an instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class. It specifies a dictionary of Adobe image resource blocks, each block is represented by the <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceBlock" /> class.
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Xmp" /> property contains string in XML format which contains XMP data. You can either parse this XML document manually or use <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class. 
</para><para>
You can also copy EXIF, IPTC, XMP or Adobe image resource blocks from one file to another simply by assigning the value of the corresponding property of the <see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport" /> interface to the same named property of the <see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport" /> interface. 
</para><para>
Currently only those image formats are supported for metadata reading: JPEG, TIFF, PSD.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.AdobeResources" draft="yes">
            <summary>Gets Adobe image resource blocks from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks obtained from the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Exif" draft="yes">
            <summary>Gets EXIF data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection obtained from the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Iptc" draft="yes">
            <summary>Gets IPTC data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains IPTC data collection obtained from the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Xmp" draft="yes">
            <summary>Gets XMP metadata from file.</summary>
            <value>XML code containing the XMP metadata</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport" draft="yes">
            <summary>This interface should be supported by each format writer that can save metadata (such as EXIF, IPTC, XMP or Adobe image resource blocks) into the file.</summary>
            <remarks>Currently only those image formats are supported for metadata writing: JPEG, TIFF.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.Iptc" draft="yes">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.Xmp" draft="yes">
            <summary>Gets/sets XMP metadata you want to write into the file.</summary>
            <value>XML code containing the XMP metadata you want to write into the file.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" draft="yes">
            <summary>This class represents a dictionary of IPTC fields.</summary>
            <remarks><para>
All functionality of this class is implemented in base class <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary" />. To put or get some IPTC field, you should use the <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> property. Just pass ID of the IPTC field as an argument into this property. Refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see> for exact field ID values. Alternatively you can use static members <see cref="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Caption" />, <see cref="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Writer" />, <see cref="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Keyword" />, and others. Exact interpretations of these parameters can be found at <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>. Currently specification 4.1 is supported.
</para><para>
IPTC tags consist of two numbers. For example, "2:25" means "Keywords". To be able to pass these numbers into <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" />, you should pack them as follows: first byte stores the second number (25 in this example), the second byte stores the first number (2 in this example). Other two bytes are not used.
</para></remarks>
            <example><para>The code below demonstrates how to extract and display both EXIF and IPTC data.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#LoadingEXIFIPTC"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#LoadingEXIFIPTC"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IptcDictionary.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Byline">
            <summary>The name of the creator of the image, e.g. artist, photographer, etc.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.BylineTitle">
            <summary>The byline title (e.g. staff photographer, correspondent, etc).</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Caption">
            <summary>The textual description of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Category">
            <summary>The image category.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.City">
            <summary>The city of the image origin.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IptcDictionary.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />).</returns>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.CopyrightNotice">
            <summary>The copyright notice.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Country">
            <summary>The country of the image origin.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Credit">
            <summary>The provider of the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.DateCreated">
            <summary>The date the image (as an intellectual content, rather than physical file) created.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Headline">
            <summary>The brief overview for the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Keyword">
            <summary>The keywords used for search.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IptcDictionary.#ctor">
            <summary>Creates and initializes new empty <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance.</summary>
            <overloads><summary>Creates and initializes new empty <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IptcDictionary.#ctor(System.IntPtr)">
            <summary>This constructor is used by Graphics Mill for .NET for internal purposes. Do not call it directly.</summary>
            <param name="iptc">The pointer to the internal Graphics Mill for .NET object.</param>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.ObjectName">
            <summary>The short reference for the object.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.OriginalTransmissionReference">
            <summary>The location of the original transmission.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Source">
            <summary>The original owner of the intellectual content of this image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.SpecialInstructions">
            <summary>Some custom editorial instructions.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.State">
            <summary>The state/province of the image origin.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.SupplementaryCategory">
            <summary>The supplementary category for the image.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Urgency">
            <summary>The editorial urgency of the content.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.IptcDictionary.Writer">
            <summary>The name of editor or other person involved in the writing.</summary>
            <remarks>To get more details about exact meaning of this field, refer <see href="http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf">IPTC specification</see>.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.ITimeReader">
            <summary>This interface should be supported by each format reader that can convert frame numbers to time values and vice versa.</summary>
            <remarks><para>Each reader that supports any video format should implement this interface.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.ITimeReader.Duration">
            <summary>Gets the duration of the audio or video file.</summary>
            <value>An integer value which specifies a duration of the audio or video file. This value is measured in 1/100s of a second like any other time value in Graphics Mill for .NET.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ITimeReader.FrameIndexToTime(System.Int32)">
            <summary>Returns time at which the frame with specified index appears.</summary>
            <param name="frameIndex">The number of the frame in question.</param>
            <returns>An integer value measured in 1/100s of a second that specifies the moment of time at which the frame in question appears.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.ITimeReader.FramesPerSecond">
            <summary>Gets the frames per second ratio of the video file.</summary>
            <value>An integer value which specifies how many frames should be displayed in one second.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ITimeReader.TimeToFrameIndex(System.Int32)">
            <summary>Returns the index of the frame which is shown at the specified time.</summary>
            <param name="time">An integer value measured in 1/100s of a second that specifies the moment of time at which the frame in question appears.</param>
            <returns>The number of the frame which is shown at the specified time.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.ITimeWriter">
            <summary>This interface should be supported by each format writer that can convert frame numbers to time values and vice versa.</summary>
            <remarks><para>Each writer that supports any video format should implement this interface.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ITimeWriter.FrameIndexToTime(System.Int32)">
            <summary>Returns time at which the frame with specified index appears.</summary>
            <param name="frameIndex">The number of the frame in question.</param>
            <returns>An integer value measured in 1/100s of a second that specifies the moment of time at which the frame in question appears.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.ITimeWriter.FramesPerSecond">
            <summary>Gets/sets the frames per second ratio of the video file.</summary>
            <value>An integer value which specifies how many frames should be displayed in one second.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.ITimeWriter.TimeToFrameIndex(System.Int32)">
            <summary>Returns the index of the frame which is shown at the specified time.</summary>
            <param name="time">An integer value measured in 1/100s of a second that specifies the moment of time at which the frame in question appears.</param>
            <returns>The number of the frame which is shown at the specified time.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.IXmpDictionary">
            <summary>This interface class should be supported by codecs that can read an write XMP metadata.</summary>
            <remarks><para>This abstract class is used to retrieve XMP metadata stored in images. Such metadata is stored in the XML format (more specifically, RDF) as pairs of keys and values belonging to different namespaces. To get a collection of all namespaces, use the <see cref="P:Aurigma.GraphicsMill.Codecs.IXmpDictionary.Namespaces" /> property. To get a collection of keys contained in a specific namespace, use the <see cref="M:Aurigma.GraphicsMill.Codecs.IXmpDictionary.FindKeysByNamespace(Aurigma.GraphicsMill.Codecs.XmpNamespace)" /> method.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.IXmpDictionary.FindKeysByNamespace(Aurigma.GraphicsMill.Codecs.XmpNamespace)">
            <summary>Returns a collection of keys contained in a specific namespace.</summary>
            <param name="ns">Namespace from which the keys should be retrieved.</param>
            <returns>A collection of keys.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.IXmpDictionary.Namespaces">
            <summary>Gets a collection of metadata namespaces.</summary>
            <value>A collection of namespaces.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions">
            <summary>This class holds possible JPEG2000 format encoder options.</summary>
            <remarks><para>
JPEG2000 files can be compressed either with lossy or lossless compression algorithm. You can select it using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Compression" /> property. When lossy compression (<see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />) is used, you can specify the compression ratio using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate" /> property. It can accepts values from 0 to 1, and specifies the ratio between compressed and uncompressed bitmap. E.g. you compress 1MB bitmap and specify the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate" /> to 0.1. As a result, you will get 100KB JPEG2000 file. 
</para><para>
Also you can specify additional JPEG2000 encoder settings, such as tile size (<see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileWidth" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileHeight" />), as well as a progression order (<see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.ProgressionOrder" />).
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.Jpeg2kFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for JPEG2000 and always set to 0.</para></remarks>
            <example><para>This code sample demonstrates how to save the JPEG2000 file with non-default encoder settings. Here we use high compression. The result file size will be only 10% from the original size:</para><code language="VB" source="FileFormatsVB/form1.vb#Jpeg2kSync"></code><code language="CS" source="FileFormatsCS/form1.cs#Jpeg2kSync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Compression">
            <summary>Gets/sets a value that specifies a JPEG2000 compression type.</summary>
            <value><para>A member of <see cref="T:Aurigma.GraphicsMill.Codecs.CompressionType" /> enumeration which specifies a type of the JPEG2000 compression. </para><note>Only <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossless" /> and  <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" /> values are supported. </note></value>
            <remarks><para>If the compression type is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />, you can specify the ratio of the compression using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate" /> property. For <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" /> this property is ignored.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions" /> class instance.</summary>
            <param name="tileWidth">A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileWidth" /> property.</param>
            <param name="tileHeight">A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileHeight" /> property.</param>
            <param name="progressionOrder">A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.ProgressionOrder" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.#ctor(System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions" /> class instance. Compression ratio is specified in this constructor.</summary>
            <param name="rate">A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate" /> property.</param>
            <remarks><para>This constructor sets <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Compression" /> property to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.#ctor(System.Single,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions" /> class instance. All JPEG2000 encoder options are initialized here.</summary>
            <param name="rate">A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate" /> property.</param>
            <param name="tileWidth">A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileWidth" /> property.</param>
            <param name="tileHeight">A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileHeight" /> property.</param>
            <param name="progressionOrder">A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.ProgressionOrder" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.ProgressionOrder">
            <summary>Gets/sets a progression order (packets ordering in the code stream).</summary>
            <value>A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression.</value>
            <remarks><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.RateScalable" />.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Rate">
            <summary>Gets/sets a compression ratio.</summary>
            <value>A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap.</value>
            <remarks><para>Default value is 1 (no compression).</para><note>This property value is ignored if <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.Compression" /> is not <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />.</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileHeight">
            <summary>Gets/sets a JPEG2000 tile height.</summary>
            <value>A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height.</value>
            <remarks><para>When you specify small tile size, it enables JPEG2000 viewers to load the image partially (i.e. load in memory by tiles). However it increases the output file size.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.TileWidth">
            <summary>Gets/sets a JPEG2000 tile width.</summary>
            <value>A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile width is taken the same as a bitmap width.</value>
            <remarks><para>When you specify small tile size, it enables JPEG2000 viewers to load the image partially (i.e. load in memory by tiles). However it increases the output file size.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" draft="yes">
            <summary>This class represents a frame of the JPEG2000 format.</summary>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.
</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class usage is demonstrated below:
</para><code language="VB" source="FileFormatsVB/form1.vb#Jpeg2kAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#Jpeg2kAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Compression">
            <summary>Gets/sets a value that specifies a JPEG2000 compression type.</summary>
            <value><para>A member of <see cref="T:Aurigma.GraphicsMill.Codecs.CompressionType" /> enumeration which specifies a type of the JPEG2000 compression. </para><note>Only <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossless" /> and  <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" /> values are supported. </note></value>
            <remarks><para>If the compression type is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />, you can specify the ratio of the compression using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Rate" /> property. For <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" /> this property is ignored.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance.</summary>
            <param name="tileWidth">A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileWidth" /> property.</param>
            <param name="tileHeight">A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileHeight" /> property.</param>
            <param name="progressionOrder">A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.ProgressionOrder" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.#ctor(System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance. Compression ratio is specified in this constructor.</summary>
            <param name="rate">A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Rate" /> property.</param>
            <remarks><para>This constructor sets <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Compression" /> property to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.#ctor(System.Single,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance. All JPEG2000 encoder options are initialized here.</summary>
            <param name="rate">A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Rate" /> property.</param>
            <param name="tileWidth">A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileWidth" /> property.</param>
            <param name="tileHeight">A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileHeight" /> property.</param>
            <param name="progressionOrder">A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression. You can change this value later using the <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.ProgressionOrder" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.ProgressionOrder">
            <summary>Gets/sets a progression order (packets ordering in the code stream).</summary>
            <value>A member of the <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder" /> enumeration which specifies a progression order of the JPEG2000 compression.</value>
            <remarks><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.RateScalable" />.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Rate">
            <summary>Gets/sets a compression ratio.</summary>
            <value>A positive value in range (0, 1] which specifies a compression ratio, i.e. ratio between compressed and uncompressed bitmap. E.g. if you set this value to 0.1, the output file size will be one tenth of the size of the uncompressed bitmap.</value>
            <remarks><para>Default value is 1 (no compression).</para><note>This property value is ignored if <see cref="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.Compression" /> is not <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.WaveletLossy" />.</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileHeight">
            <summary>Gets/sets a JPEG2000 tile height.</summary>
            <value>A non-negative value that specifies a JPEG2000 tile height. If it equals to 0, the tile height is taken the same as a bitmap height.</value>
            <remarks><para>When you specify small tile size, it enables JPEG2000 viewers to load the image partially (i.e. load in memory by tiles). However it increases the output file size.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame.TileWidth">
            <summary>Gets/sets a JPEG2000 tile width.</summary>
            <value>A non-negative value that specifies a JPEG2000 tile width. If it equals to 0, the tile width is taken the same as a bitmap width.</value>
            <remarks><para>When you specify small tile size, it enables JPEG2000 viewers to load the image partially (i.e. load in memory by tiles). However it increases the output file size.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder">
            <summary>Contains possible values for packets ordering in the code stream (progressions). Used in JPEG2000 compression.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Cprl">
            <summary>Component-position-resolution-layer ordering.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Lrcp">
            <summary>Layer-resolution-component-position ordering.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Pcrl">
            <summary>Position-component-resolution-layer ordering.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.RateScalable">
            <summary>The same as <see cref="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Lrcp" />.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.ResolutionScalable">
            <summary>The same as <see cref="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Rlcp" />.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Rlcp">
            <summary>Resolution-layer-component-position ordering.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.Jpeg2kProgressionOrder.Rpcl">
            <summary>Resolution-position-component-layer ordering.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader">
            <summary>This class enables you to read JPEG2000 images.</summary>
            <remarks><para>JPEG2000 is an image format which implements wavelet-based compression algorithm. This algorithm provides high compression ratio with better quality than JPEG. This compression is also lossy, however JPEG2000 artifacts are looking visually better comparing to JPEG. </para><para>Graphics Mill for .NET can save bitmaps to JPEG2000 format in two color spaces: </para><list type="bullet"><item><description>RGB;</description></item><item><description>Grayscale;</description></item></list><para>These bitmaps can be both extended (16 bit per channel) and non-extended (8 bit per channel). Also, these bitmaps may contain an alpha channel.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> object containing full copy of the current object.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.
</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter">
            <summary>This class enables you to write JPEG2000 images.</summary>
            <remarks><para>JPEG2000 is an image format which implements wavelet-based compression algorithm. This algorithm provides high compression ratio with better quality than JPEG. This compression is also lossy, however JPEG2000 artifacts are looking visually better comparing to JPEG. </para><para>Graphics Mill for .NET can save bitmaps to JPEG2000 format in two color spaces: </para><list type="bullet"><item><description>RGB;</description></item><item><description>Grayscale;</description></item></list><para>These bitmaps can be both extended (16 bit per channel) and non-extended (8 bit per channel). Also, these bitmaps may contain an alpha channel.</para></remarks>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.
</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class usage is demonstrated below:
</para><code language="VB" source="FileFormatsVB/form1.vb#Jpeg2kAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#Jpeg2kAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> object containing full copy of the current object.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kFrame" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.Jpeg2kWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode">
            <summary>Contains possible values for aligning to JPEG sample size.</summary>
            <remarks><para>These values are used in the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)" /> method of the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> class. It specifies whether you need to align only X and y-coordinates of the left top corner, or width and height also. </para><para>
If you need to get cropped JPEG and do not want to patch the file with it, you can use <see cref="F:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode.Crop" /> value. In this case the width and height of cropped bitmap can be arbitrary. 
</para><para>
However if you are going to put a bitmap into the JPEG file (i.e. patch it), width and height of this bitmap must be aligned. In this case you should use <see cref="F:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode.Patch" /> value.
</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode.Crop">
            <summary>Only X and y-coordinates of the top left corner will be aligned. Width and height will not be aligned. Should be used for <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" /> if no consequent <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> is implied. Width and height still may be changed to preserver right and bottom position of the input rectangle. However it will not be aligned.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode.Patch">
            <summary>Both top left corner location and dimensions of the input rectangle are aligned. You should use this value if you are preparing rectangle (offset and bitmap dimensions) for the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions" draft="yes">
            <summary>This class holds possible JPEG format encoder options.</summary>
            <remarks><para>
The main JPEG encoder setting is a quality/file size ratio. It is specified with <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Quality" /> property. This property accepts values in range [0, 100] where 0 means the lowest quality (but smallest file size) and 100 means the highest quality (but largest file size).
</para><para>
Besides of this you can specify is JPEG should be progressive (using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.IsProgressive" />). It allows the browsers to display the JPEG file while it is being downloaded (displaying more and more details upon new file portions download). Unfortunately this feature is not supported with Internet Explorer browser.
</para><para>
Another compression setting can be changed via <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.ChromaSubsamplingEnabled" /> property. Chroma subsampling is one of the compression methods used in JPEG. It is based on the specific of the human vision and allows to reduce size of the result file by storing color information at lower resolution than luminance information. In most cases this tradeoff will not be noticeable to the human. But sometimes such information loss may be significant (e.g. for some classes of image processing algorithms) and chroma subsampling should be turned off. Chroma subsampling is enabled by default.
</para><para>Also you can provide meta-information for encoding. Use <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.AdobeResources" />, <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Exif" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Iptc" /> properties to specify corresponding metadata objects.
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.JpegFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for JPEG and always set to 0.</para></remarks>
            <example><para>This code sample demonstrates how to save the JPEG file with non-default encoder settings. Here we set low quality and make JPEG to be progressive (good for fast delivery via Web):</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGSync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGSync"></code><para>JPEG files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.ChromaSubsamplingEnabled" draft="yes">
            <summary>Gets/sets the value that specifies whether to use chroma subsampling in JPEG compression or not.</summary>
            <value>Value that specifies whether to use chroma subsampling in JPEG compression or not.</value>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.ChromaSubsamplingEnabled">JpegFrame.ChromaSubsamplingEnabled Property</seealso>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
            <example><para>JPEG files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataSync"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Iptc">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
            <example><para>JPEG files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataSync"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.IsProgressive" draft="yes">
            <summary>Gets/sets a value that specifies if JPEG should be progressive.</summary>
            <value>Value that specifies if JPEG should be progressive.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.#ctor(System.Int32,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions" /> class instance. You can set some JPEG settings here.</summary>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.IsProgressive" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.#ctor(System.Int32,System.Boolean,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions" /> class instance. You can set all JPEG settings here.</summary>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.IsProgressive" /> property.</param>
            <param name="cromaSubsampling">Value that specifies whether to use chroma subsampling during JPEG encoding. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.ChromaSubsamplingEnabled" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Quality">
            <summary>Gets/sets JPEG quality.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
            <remarks><para>
The higher JPEG quality you specify, the larger file size you will get.
</para><para>Default value is 75.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegEncoderOptions.Xmp" draft="yes">
            <summary>Gets/sets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata.</value>
            <remarks><para>To modify the XMP data, you can use either the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or standard .NET XML-processing means according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegFrame" draft="yes">
            <summary>This class represents a frame of the JPEG format.</summary>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegFrame.ChromaSubsamplingEnabled" draft="yes">
            <summary>Gets/sets the value that specifies whether to use chroma subsampling in JPEG compression or not.</summary>
            <value>Value that specifies whether to use chroma subsampling in JPEG compression or not.</value>
            <remarks><para>Chroma subsampling is one of the compression methods used in JPEG. It is based on the specific of the human vision and allows to reduce size of the result file by storing color information at lower resolution than luminance information. In most cases this tradeoff will not be noticeable to the human. But sometimes such information loss may be significant (e.g. for some classes of image processing algorithms) and chroma subsampling should be turned off.</para><para>
Chroma subsampling is enabled by default.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegFrame.IsProgressive" draft="yes">
            <summary>Gets/sets a value that specifies if JPEG should be progressive.</summary>
            <value>Value that specifies if JPEG should be progressive.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.IsProgressive" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Boolean,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.IsProgressive" /> property.</param>
            <param name="chromaSubsampling">Value that specifies whether to use chroma subsampling during JPEG encoding. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.ChromaSubsamplingEnabled" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.#ctor(System.Int32,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance. You can set some the frame settings here.</summary>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.IsProgressive" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.#ctor(System.Int32,System.Boolean,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.Quality" /> property.</param>
            <param name="progressive">Value that specifies if JPEG should be progressive. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.IsProgressive" /> property.</param>
            <param name="chromaSubsampling">Value that specifies whether to use chroma subsampling during JPEG encoding. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.JpegFrame.ChromaSubsamplingEnabled" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegFrame.Quality">
            <summary>Gets/sets JPEG quality.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
            <remarks><para>
The higher JPEG quality you specify, the larger file size you will get.
</para><para>Default value is 75.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegMarkerException">
            <summary>This exception is thrown by <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> if you try to write incorrect JPEG metadata.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegMarkerException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.JpegMarkerException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.JpegMarkerException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegMarkerException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.JpegMarkerException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegMarkerException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.JpegMarkerException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegMarkerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegReader" draft="yes">
            <summary>This class enables you to read JPEG images.</summary>
            <remarks><para>JPEG is a standard image format for storing photos. JPEG stands for Joint Photographic Experts Group, the original name of the committee that wrote this standard. JPEG stores images with lossy compression and it is designed for compressing either full-color or grayscale images of natural, real-world scenes. During the process of an original image writing to JPEG the quality of image can be specified. The less compression quality specified, the less size result file will have.</para><para>There is a special type of JPEG images - progressive. Progressive JPEG rearranges the stored image data. When the JPEG file is transmitted across a slow communications link, it allows to decoder to generate a low-quality image very quickly, then gradually improve the displayed quality as more image data are received. The final image is identical to that of a regular JPEG file of the same quality setting.</para><para>JPEG files can also contain Adobe resources, XMP, EXIF and IPTC data. However it does not support multiple images in the single file.</para><para>JPEG images support three main color spaces: </para><list type="bullet"><item><description>RGB;</description></item><item><description>CMYK;</description></item><item><description>Grayscale;</description></item></list><para>It does not support indexed images, as well as extended (16 bit per channel) pixel formats.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegReader.AdobeResources" draft="yes">
            <summary>Gets Adobe image resource blocks from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks obtained from the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegReader.Exif" draft="yes">
            <summary>Gets EXIF data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection obtained from the file.</value>
            <example><para>The code below demonstrates how to extract and display both EXIF and IPTC data.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#LoadingEXIFIPTC"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#LoadingEXIFIPTC"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegReader.Iptc">
            <summary>Gets IPTC data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains IPTC data collection obtained from the file.</value>
            <example><para>The code below demonstrates how to extract and display both EXIF and IPTC data.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#LoadingEXIFIPTC"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#LoadingEXIFIPTC"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegReader.OnOpen">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegReader.Xmp">
            <summary>Gets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata of the opened file.</value>
            <remarks><para>To get specific values of the XMP fields, you can either use the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or parse this XML manually according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.JpegWriter" draft="yes">
            <summary>This class enables you to write JPEG images.</summary>
            <remarks><para>JPEG is a standard image format for storing photos. JPEG stands for Joint Photographic Experts Group, the original name of the committee that wrote this standard. JPEG stores images with lossy compression and it is designed for compressing either full-color or grayscale images of natural, real-world scenes. During the process of an original image writing to JPEG the quality of image can be specified. The less compression quality specified, the less size result file will have.</para><para>There is a special type of JPEG images - progressive. Progressive JPEG rearranges the stored image data. When the JPEG file is transmitted across a slow communications link, it allows to decoder to generate a low-quality image very quickly, then gradually improve the displayed quality as more image data are received. The final image is identical to that of a regular JPEG file of the same quality setting.</para><para>JPEG files can also contain XMP, EXIF, IPTC data and Adobe image resource blocks. However it does not support multiple images in the single file.</para><para>JPEG images support three main color spaces: </para><list type="bullet"><item><description>RGB;</description></item><item><description>CMYK;</description></item><item><description>Grayscale;</description></item></list><para>It does not support indexed images, as well as extended (16 bit per channel) pixel formats.</para></remarks>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGAsync"></code><para>JPEG files can store XMP, EXIF, IPTC data blocks and Adobe image resource blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports corresponding meta information). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegWriter.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks you want to write into the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegWriter.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
            <example><para>JPEG files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataAsync"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.JpegFrame" /> class instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegWriter.Iptc" draft="yes">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
            <example><para>JPEG files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the JPEG file and save it into another JPEG file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#JPEGMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#JPEGMetadataAsync"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.JpegWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.OnClose">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.JpegWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.JpegWriter.Xmp" draft="yes">
            <summary>Gets/sets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata.</value>
            <remarks><para>To modify the XMP data, you can use either the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or standard .NET XML-processing means according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" draft="yes">
            <summary>This class enables you to apply lossless operations on the JPEG files.</summary>
            <remarks><para>
This class is intended to operate with JPEG files without recompression. It is useful if you need to modify Adobe image resource blocks, XMP, EXIF or IPTC data only (without modifying the image), rotate or/and flip the JPEG image without recompression, or recompress only a part of image (e.g. if you add a text caption on the image, it makes sense to recompress only the part of image where the caption is placed and leave all the rest of image intact).
</para><para>
To use this class, you need to open the JPEG file with the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method first. After that, if you need to apply the following task:
</para><list type="bullet"><item><term>Change Adobe resources, XMP, EXIF or IPTC data without JPEG recompression</term><description>use <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AdobeResources" />, <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Xmp" />, <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" /> properties to modify metadata, and then use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.String)" /> method to save changes. </description></item><item><term>Rotate JPEG image without recompression</term><description>use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" /> method. </description></item><item><term>Recompress only the part of the image</term><description>use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)" />, <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" />, and <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />. See remarks for these methods for more details. </description></item></list><para>According to JPEG specification an image is represented by blocks of pixels so-called JPEG Minimum Coded Units (MCU). Typically MCU size is a number divisible by 8. That fact allows to peform lossless rotation or flip: MCU blocks are rearranged in new order as well as the order of pixels is changed inside each MCU. Examine the situation when width or height of an image is non-divisible by MCU size, it means that the last column or row contains partially-filled MCU blocks. Such images do not support some types of rotation and flip. They will be cropped during tranformation and width and height of the result image will be divisible by MCU size. If you need to know whether dimensions of your image will be changed after a transformation, you can use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.IsTrimmingRequired(System.Drawing.RotateFlipType)" />  method. This method returns whether dimensions will be changed taking into account the dimensions of currently opened JPEG image and the desired type of transformation.</para><para>Do not forget to close the transform object after you made all necessary operations (using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method). It will release the file you opened.</para></remarks>
            <seealso href="ApplyingLosslessJPEGTransforms.htm" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks for the opened JPEG file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks.</value>
            <remarks><para>To edit Adobe image resource blocks you can either edit them in-place or assign new <see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance to this property. </para><para>You assign <b>null</b> to this property. In this case no Adobe resources will be saved with <b>WriteXXX</b> methods. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)">
            <summary>Aligns coordinates of the point and bitmap to the JPEG sample size.</summary>
            <param name="offset"><see cref="T:System.Drawing.Point" /> at which the <i>bitmap</i> should be placed. It will be used as a location of left top corner of the input rectangle.</param>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which specifies a bitmap. Its width and height will be used as dimensions of the input rectangle.</param>
            <returns><see cref="T:System.Drawing.Rectangle" /> which contains coordinates aligned to JPEG sample size. It is always greater or equal than the input rectangle formed by the <i>offset</i> and dimensions of the <i>bitmap</i>.</returns>
            <remarks>This method is used when you need overwrite some portion of JPEG file by some bitmap. Since JPEG compressed data is stored in blocks (samples) of several pixels (typically 8, 16, or other number divisible by 8), you cannot write bitmap by arbitrary coordinates. That's why you need to align coordinates by the JPEG sample size.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
            <overloads><summary>Aligns given coordinates to the JPEG sample size</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)">
            <summary>Aligns coordinates of the given rectangle to the JPEG sample size.</summary>
            <param name="rectangle"><see cref="T:System.Drawing.Rectangle" /> which needs to be aligned by the JPEG sample size.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode" /> value which specifies whether to align width and height. It is not obligatory to align width and height if you just crop the JPEG. But if you need to insert the bitmap into JPEG (using <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method), you should align width and height as well (otherwise you will have noise at right and bottom edge of inserted bitmap).</param>
            <returns><see cref="T:System.Drawing.Rectangle" /> which contains coordinates aligned to JPEG sample size. It is always greater or equal than the input <i>rectangle</i>.</returns>
            <remarks>This method is used when you need to crop a part of a JPEG file without recompression or overwrite some portion of JPEG file by some bitmap. Since JPEG compressed data is stored in blocks (samples) of several pixels (typically 8, 16, or other number divisible by 8), you cannot crop or write bitmap by arbitrary coordinates. That's why you need to align coordinates by the JPEG sample size.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close">
            <summary>Closes JPEG transform and releases the file opened with <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.</summary>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.ColorProfile">
            <summary>Gets/sets the color profile associated with this JPEG file.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection for the opened JPEG file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection.</value>
            <remarks><para>To edit EXIF you can either edit its fields in-place or assign new EXIF collection to this property. </para><para>You assign <b>null</b> to this property. In this case no EXIF data will be saved with <b>WriteXXX</b> methods. </para><note type="note">When EXIF data is moved to the file (when you use one of <b>WriteXXX</b> methods), Graphics Mill for .NET updates only width and height fields. It does not update thumbnail or any other fields. So your application is responsible to do it if it is necessary.
            </note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" draft="yes">
            <summary>Gets/sets IPTC data collection for the opened JPEG file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection.</value>
            <remarks><para>To edit IPTC you can either edit its fields in-place or assign new IPTC collection to this property. </para><para>
              You assign <b>null</b> to this property. In this case no Adobe image resource blocks will be saved with <b>WriteXXX</b> methods.
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.IsTrimmingRequired(System.Drawing.RotateFlipType)" draft="yes">
            <summary>Determines whether the image will be trimmed during the rotation or flipping.</summary>
            <param name="rotateFlipType"><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode.</param>
            <returns><b>true</b> if the image will be trimmed; otherwise, <b>false</b>.</returns>
            <remarks><para>
              According to JPEG specification an image is represented by blocks of pixels so-called JPEG Minimum Coded Units (MCU).
              Typically MCU size is a number divisible by 8. That fact allows to peform lossless rotation or flip: MCU blocks are rearranged in new order as well as the order
              of pixels is changed inside each MCU. Examine the situation when width or height of an image is non-divisible
              by MCU size, it means that the last column or row contains partially-filled MCU blocks. Such images
              do not support some types of rotation and flip. They will be cropped during tranformation and width and height
              of the result image will be divisible by MCU size. If you need to know whether dimensions of your image will be
              changed after transformation or not, you can use the
              <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.IsTrimmingRequired(System.Drawing.RotateFlipType)" /> method.
              This method returns whether dimensions will be changed taking into account the dimensions of the currently opened JPEG
              image and the desired type of transformation.
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> class instance.</summary>
            <overloads><summary>
              Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> class instance.
            </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> class instance. It also opens this transform on specified file.</summary>
            <param name="fileName">Name of the file to open the JPEG file transform on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> class instance. It also opens this transform on specified stream.</summary>
            <param name="stream">Name of the stream to open the JPEG file transform on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)">
            <summary>Opens the JPEG transform object on the specified file.</summary>
            <param name="fileName">The name of the JPEG file to open transform on.</param>
            <remarks>When you finished working with this file, you should call <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method to release this file. The file will be locked by your application until you close the JPEG transform.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Opened" />
            <overloads><summary>Opens the JPEG transform object on the specified file.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.IO.Stream)">
            <summary>Opens the JPEG transform object on the specified stream.</summary>
            <param name="stream">The stream which contains the JPEG file to open transform on.</param>
            <remarks>When you finished working with this file, you should call <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Opened" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Opened">
            <summary>Returns value that specifies if the JPEG file transform is opened.</summary>
            <value>Value that specifies if the JPEG file transform is opened.</value>
            <remarks>JPEG file transform  becomes opened after you call <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method until the subsequent call of <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.SampleSize">
            <summary>Returns a value that specifies the sample size of the JPEG file.</summary>
            <value>A sample size that is used in the currently opened JPEG image.</value>
            <remarks><para>JPEG compressed data is stored in blocks (samples) of several pixels, typically of 8, 16, or other number divisible by 8. Sometimes, it is necessary to take the sample size into account, for example, when cropping images.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.String)">
            <summary>Writes the JPEG file to the specified file without changes.</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <remarks><para>You can use this method to edit EXIF or IPCT data without recompression of the image. In this case the workflow should the following: </para><list type="number"><item><description>
                  Open the JPEG file using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.
                </description></item><item><description>
                  Update EXIF or IPTC data using <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" /> or <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" /> properties.
                </description></item><item><description>Save changes in a separate file using this method. </description></item></list><note type="note">
              You cannot save changes in the same file you opened the transform at (by design). If you need to do it, you should to save the updated file to a memory stream (using <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)">an overloaded version of this method</see>), close the transform, and save the stream to the original file.
            </note></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.String)" />
            <overloads><summary>Writes the JPEG file without modifying the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)">
            <summary>Writes the JPEG file to the specified stream without changes.</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <remarks><para>You can use this method to edit EXIF or IPCT data without recompression of the image. In this case the workflow should the following: </para><list type="number"><item><description>
                  Open the JPEG file using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.
                </description></item><item><description>
                  Update EXIF or IPTC data using <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" /> or <see cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" /> properties.
                </description></item><item><description>Save changes in a separate file using this method. </description></item></list></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Exif" />
<seealso cref="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Iptc" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.IO.Stream,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" draft="yes">
            <summary>Crops a portion of the uncompressed JPEG image and writes it to specified file.</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <param name="rectangle"><see cref="T:System.Drawing.Rectangle" /> object which specifies a portion of the image you need to crop. The rectangle must be inside the image. Note, coordinates of this rectangle and coordinates of the cropped portion of image may be different (see <b>Remarks</b> section for more details).</param>
            <remarks><para>You can use this method to recompress only a part of an image. For example, let's assume you want to apply a watermark to an image or remove an effect of red eyes. It obviously makes sense to recompress only that part of image which you modify without recompressing the other parts. It can be easily achieved with the following algorithm: </para><list type="number"><item><description>Determine what part of image you need to change. You may need to load it into a bitmap so that the user could select this part manually, or calculate it somehow else.</description></item><item><description>
                  Create <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> and open it using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.
                </description></item><item><description>
                  Use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> to align the rectangle specifying the image part to JPEG sample size (see below).
                </description></item><item><description>
                  Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" /> to get a portion of JPEG without recompression.
                </description></item><item><description>
                  Create a new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance and load the resulting JPEG file into it (e.g. using the <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> method).
                </description></item><item><description>Apply the necessary effect to the bitmap (e.g. watermark, red eye removal, etc).</description></item><item><description>
                  Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method to store the resulting bitmap into a JPEG file. Graphics Mill for .NET will automatically compress this bitmap with the same compression options as the original JPEG file and overwrite the appropriate portion of compressed JPEG data.
                </description></item><item><description>Do not forget to close the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> with the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</description></item></list><note type="caution"><para>
Due to specifics of JPEG, you cannot specify arbitrary coordinates to crop. Its top-left corner should be aligned  on the size of JPEG sample data. Typically it is a number divisible by 8. To calculate the actual rectangle, you can use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)" /> method. You just pass your rectangle to this method and it returns the nearest rectangle (with modified position aligned to the JPEG sample size). 
</para><para>If you pass a <i>rectangle</i> which is not aligned, Graphics Mill for .NET automatically aligns it. As a result, coordinates of the left-top corner of this <i>rectangle</i> will be rounded down by the JPEG sample size but coordinates of the right-bottom corner will not be changed. For example, if you specify this rectangle (11, 11, 20, 20) it will be aligned to (8, 8, 23, 23) if the JPEG sample size is 8x8.</para></note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Rectangle,Aurigma.GraphicsMill.Codecs.JpegAlignToSampleSizeMode)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.String)" />
            <overloads><summary>Crops a portion of the uncompressed JPEG image and writes it to specified file/stream.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" draft="yes">
            <summary>Crops a portion of the uncompressed JPEG image and writes it to specified stream.</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <param name="rectangle"><see cref="T:System.Drawing.Rectangle" /> object which specifies a portion of the image you need to crop. The rectangle must be inside the image. Note, coordinates of this rectangle and coordinates of the cropped portion of image may be different (see <b>Remarks</b> section for more details).</param>
            <remarks><para>You can use this method to recompress only a part of an image. For example, let's assume you want to apply a watermark to an image or remove an effect of red eyes. It obviously makes sense to recompress only that part of image which you modify without recompressing the other parts. It can be easily achieved with the following algorithm: </para><list type="number"><item><description>Determine what part of image you need to change. You may need to load it into a bitmap so that the user could select this part manually, or calculate it somehow else.</description></item><item><description>Create <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> and open it using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.</description></item><item><description>Use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> to align the rectangle specifying the image part to JPEG sample size (see below).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" /> to get a portion of JPEG without recompression.</description></item><item><description>Create a new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance and load the resulting JPEG file into it (e.g. using the <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> method).</description></item><item><description>Apply the necessary effect to the bitmap (e.g. watermark, red eye removal, etc).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method to store the resulting bitmap into a JPEG file. Graphics Mill for .NET will automatically compress this bitmap with the same compression options as the original JPEG file and overwrite the appropriate portion of compressed JPEG data.
            </description></item><item><description>Do not forget to close the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> with the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</description></item></list><note type="caution"><para>
Due to specifics of JPEG, you cannot specify arbitrary coordinates to crop. Its top-left corner should be aligned  on the size of JPEG sample data. Typically it is a number divisible by 8. To calculate the actual rectangle, you can use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method. You just pass your rectangle to this method and it returns the nearest rectangle (with modified position and dimensions aligned to the JPEG sample size). 
</para><para>If you pass a <i>rectangle</i> which is not aligned, Graphics Mill for .NET automatically aligns it. As a result, coordinates of the left-top corner of this <i>rectangle</i> will be rounded down by the JPEG sample size but coordinates of the right-bottom corner will not be changed. For example, if you specify this rectangle (11, 11, 20, 20) it will be aligned to (8, 8, 23, 23) if the JPEG sample size is 8x8.</para></note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.IO.Stream,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Compresses given bitmap to JPEG, overwrites a portion of JPEG data of the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> by this bitmap, and writes the result into the specified file.</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <param name="offset"><see cref="T:System.Drawing.Point" /> at which the <i>bitmap</i> should be placed. These coordinates must be inside of image (i.e. x-coordinate must be smaller than width, y-coordinate must be smaller than height). Note, it should be aligned on the JPEG data sample size (see the <b>Remarks</b> section for more details).</param>
            <param name="bitmap">An instance of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class which should be placed at the given position.</param>
            <remarks><para>You can use this method to recompress only a part of an image. For example, let's assume you want to apply a watermark to an image or remove an effect of red eyes. It obviously makes sense to recompress only that part of image which you modify without recompressing the other parts. It can be easily achieved with the following algorithm: </para><list type="number"><item><description>Determine what part of image you need to change. You may need to load it into a bitmap so that the user could select this part manually, or calculate it somehow else.</description></item><item><description>Create <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> and open it using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.</description></item><item><description>Use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> to align the rectangle specifying the image part to JPEG sample size (see below).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" /> to get a portion of JPEG without recompression.</description></item><item><description>Create a new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance and load the resulting JPEG file into it (e.g. using the <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> method).</description></item><item><description>Apply the necessary effect to the bitmap (e.g. watermark, red eye removal, etc).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method to store the resulting bitmap into a JPEG file. Graphics Mill for .NET will automatically compress this bitmap with the same compression options as the original JPEG file and overwrite the appropriate portion of compressed JPEG data.
            </description></item><item><description>Do not forget to close the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> with the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</description></item></list><note type="caution"><para>
Due to specifics of JPEG, you cannot put the bitmap at arbitrary coordinates. They should be aligned on the size of JPEG sample data. Typically it is a number divisible by 8. To calculate aligned coordinates, you can use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method. You just pass your position and the bitmap to this method and it returns the rectangle where this bitmap will be actually placed (with modified position and dimensions aligned to the JPEG sample size). 
</para><para>If you pass an <i>offset</i> which is not aligned, Graphics Mill for .NET automatically aligns it. As a result x and y coordinates of this <i>offset</i> will be rounded down by the JPEG sample size. For example, if you specify the following point (19, 19) to place the bitmap, it will be actually placed into the (16, 16) position (if the JPEG sample size is 8x8 or 16x16). If the <i>bitmap</i> you pass to this method is not aligned, Graphics Mill for .NET automatically aligns it. As a result its dimension will be enlarged to be divisible by the JPEG sample size and the extended area will be filled with garbage.</para></note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.String)" />
            <overloads><summary>Compresses given bitmap to JPEG, overwrites a portion of JPEG data of the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> by this bitmap, and writes the result into the specified file/stream.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.IO.Stream,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)">
            <summary>Compresses given bitmap to JPEG, overwrites a portion of JPEG data of the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> by this bitmap, and writes the result into the specified stream.</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <param name="offset"><see cref="T:System.Drawing.Point" /> at which the <i>bitmap</i> should be placed. These coordinates must be inside of image (i.e. x-coordinate must be smaller than width, y-coordinate must be smaller than height). Note, it should be aligned on the JPEG data sample size (see the <b>Remarks</b> section for more details).</param>
            <param name="bitmap">An instance of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class which should be placed at the given position.</param>
            <remarks><para>You can use this method to recompress only a part of an image. For example, let's assume you want to apply a watermark to an image or remove an effect of red eyes. It obviously makes sense to recompress only that part of image which you modify without recompressing the other parts. It can be easily achieved with the following algorithm: </para><list type="number"><item><description>Determine what part of image you need to change. You may need to load it into a bitmap so that the user could select this part manually, or calculate it somehow else.</description></item><item><description>Create <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> and open it using the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" /> method.</description></item><item><description>Use <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> to align the rectangle specifying the image part to JPEG sample size (see below).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" /> to get a portion of JPEG without recompression.</description></item><item><description>Create a new <see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance and load the resulting JPEG file into it (e.g. using the <see cref="M:Aurigma.GraphicsMill.Bitmap.Load(System.String)" /> method).</description></item><item><description>Apply the necessary effect to the bitmap (e.g. watermark, red eye removal, etc).</description></item><item><description>Use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method to store the resulting bitmap into a JPEG file. Graphics Mill for .NET will automatically compress this bitmap with the same compression options as the original JPEG file and overwrite the appropriate portion of compressed JPEG data.
            </description></item><item><description>Do not forget to close the <see cref="T:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform" /> with the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Close" /> method.</description></item></list><note type="caution"><para>
Due to specifics of JPEG, you cannot put the bitmap at arbitrary coordinates. They should be aligned on the size of JPEG sample data. Typically it is a number divisible by 8. To calculate aligned coordinates, you can use the <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" /> method. You just pass your position and the bitmap to this method and it returns the rectangle where this bitmap will be actually placed (with modified position and dimensions aligned to the JPEG sample size). 
</para><para>
                If you pass an <i>offset</i> which is not aligned, Graphics Mill for .NET automatically aligns it. As a result x and y coordinates of this <i>offset</i> will be rounded down by the JPEG sample size. For example, if you specify the following point (19, 19) to place the bitmap, it will be actually placed into the (16, 16) position (if the JPEG sample size is 8x8 or 16x16). If the <i>bitmap</i> you pass to this method is not aligned, Graphics Mill for .NET automatically aligns it. As a result its dimension will be enlarged to be divisible by the JPEG sample size and the extended area will be filled with garbage.
</para></note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.AlignToSampleSize(System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" draft="yes">
            <summary>Writes the JPEG file to the specified file rotated or/and flipped (without recompression).</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <param name="transform"><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode.</param>
            <remarks><para>
                According to JPEG specification an image is represented by blocks of pixels so-called JPEG Minimum Coded Units (MCU).
                Typically MCU size is a number divisible by 8. That fact allows to peform lossless rotation or flip: MCU blocks are rearranged in new order as well as the order
                of pixels is changed inside each MCU. Examine the situation when width or height of an image is non-divisible
                by MCU size, it means that the last column or row contains partially-filled MCU blocks. Such images
                do not support some types of rotation and flip. They will be cropped during tranformation and width and height
                of the result image will be divisible by MCU size. If you need to know whether dimensions of your image will be
                changed after transformation or not, you can use the
                <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.IsTrimmingRequired(System.Drawing.RotateFlipType)" /> method.
                This method returns whether dimensions will be changed taking into account the dimensions of the currently opened JPEG
                image and the desired type of transformation.
              </para></remarks>
            <overloads><summary>Writes the JPEG file rotated or/and flipped (without recompression).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" draft="yes">
            <summary>Writes the JPEG file to the specified stream rotated or/and flipped (without recompression).</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <param name="transform"><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode.</param>
            <remarks><para>
                According to JPEG specification an image is represented by blocks of pixels so-called JPEG Minimum Coded Units (MCU).
                Typically MCU size is a number divisible by 8. That fact allows to peform lossless rotation or flip: MCU blocks are rearranged in new order as well as the order
                of pixels is changed inside each MCU. Examine the situation when width or height of an image is non-divisible
                by MCU size, it means that the last column or row contains partially-filled MCU blocks. Such images
                do not support some types of rotation and flip. They will be cropped during tranformation and width and height
                of the result image will be divisible by MCU size. If you need to know whether dimensions of your image will be
                changed after transformation or not, you can use the
                <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.IsTrimmingRequired(System.Drawing.RotateFlipType)" /> method.
                This method returns whether dimensions will be changed taking into account the dimensions of the currently opened JPEG
                image and the desired type of transformation.
              </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.String)">
            <summary>Writes the JPEG file to the specified file transposed (without recompression).</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <remarks>It is the same as <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" /> with <i>transform</i> parameter equal to <b>Rotate270FlipY</b>.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.String)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.String,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.String,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.String)" />
            <overloads><summary>Writes the JPEG file transposed (without recompression).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.IO.Stream)" draft="yes">
            <summary>Writes the JPEG file to the specified stream transposed (without recompression).</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <remarks>It is the same as <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" /> with <i>transform</i> parameter equal to <b>Rotate270FlipY</b>.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.IO.Stream,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.IO.Stream)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.String)" draft="yes">
            <summary>Writes the JPEG file to the specified file transversed (without recompression).</summary>
            <param name="fileName">The name of the file where you want to save the result.</param>
            <remarks>It is the same as <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.String,System.Drawing.RotateFlipType)" /> with <i>transform</i> parameter equal to <b>Rotate90FlipY</b>.</remarks>
            <overloads><summary>Writes the JPEG file to the specified file transversed (without recompression).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransversed(System.IO.Stream)" draft="yes">
            <summary>Writes the JPEG file to the specified stream transversed (without recompression).</summary>
            <param name="stream">The stream where you want to save the result.</param>
            <remarks>It is the same as <see cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" /> with <i>transform</i> parameter equal to <b>Rotate90FlipY</b>.</remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Open(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Write(System.IO.Stream)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteCropped(System.IO.Stream,System.Drawing.Rectangle)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WritePatched(System.IO.Stream,System.Drawing.Point,Aurigma.GraphicsMill.Bitmap)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteRotated(System.IO.Stream,System.Drawing.RotateFlipType)" />
<seealso cref="M:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.WriteTransposed(System.IO.Stream)" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.LosslessJpegTransform.Xmp">
            <summary>Gets/sets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata.</value>
            <remarks><para>To get specific values of the XMP fields, you can either use the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or parse this XML manually according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MediaCorruptedException">
            <summary>This exception is thrown when you try to open file (or other media) which contains corrupted data.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaCorruptedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MediaCorruptedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MediaCorruptedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaCorruptedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MediaCorruptedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaCorruptedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MediaCorruptedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaCorruptedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MediaProviderException">
            <summary>This is a base class for all exception which can be thrown when you are working with format readers or writers.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaProviderException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MediaProviderException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MediaProviderException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaProviderException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MediaProviderException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaProviderException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MediaProviderException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaProviderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MediaUnsupportedException">
            <summary>This exception is thrown when you try to read file (or other media) and its format is not recognized as supported by Graphics Mill for .NET.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaUnsupportedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaUnsupportedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaUnsupportedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MediaUnsupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary">
            <summary>This class represents a dicitonary of image metadata, such as EXIF or IPTC.</summary>
            <remarks><para>This abstract class contains partial implementation of the <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> classes. It is used to read, write, and modify metadata stored in images. </para><para>Metadata is stored as pairs of keys and values. Key is an EXIF or IPTC tag (e.g. <see cref="F:Aurigma.GraphicsMill.Codecs.ExifDictionary.DateTime" />), value is an actual value stored at this key (e.g. "2004:11:19 20:50:03"). To get a piece of data from the collection use property <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> or method <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetItemArray(System.Object)" /> (for several items). To check whether an item with certain key is available at the dictionary, you can use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Contains(System.Object)" /> method. Also, you can get all keys or all values through <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Keys" /> or <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Values" /> property correspondingly. For easier displaying, you can convert key into human-readable text string using <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetKeyDescription(System.Object)" /> method. Property <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Count" /> returns number of items in the dictionary.  </para><para>Typically you get this class instance from <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Exif" /> or <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport.Iptc" /> property of the format reader that implements <see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataReadSupport" /> interface. You can also create new empty instance of <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> or <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class and put necessary details using <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Add(System.Object,System.Object)" /> method. After that you can put this dictionary into <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.Exif" /> or <see cref="P:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport.Iptc" /> property of the format writer that implements <see cref="T:Aurigma.GraphicsMill.Codecs.IMetadataWriteSupport" /> interface. This way you can save updated EXIF data into the image file.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Add(System.Object,System.Object[])">
            <summary>Adds several items at the specified key.</summary>
            <param name="key">Key of the object to add. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <param name="values">An array of items to add into the dictionary.</param>
            <remarks><para>If item (or several items) are already stored at specified key, this method fails. To check whether the item with such key exists, use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Contains(System.Object)" /> method.</para><para>An alternative way to add new entries into the dictionary is to use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.SetItemArray(System.Object,System.Object[])" /> method. Unlike <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Add(System.Object,System.Object[])" /> method, if the key is found in the dictionary, new items overwrite the old values. </para></remarks>
            <overloads><summary>Adds some data to the dictionary.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Add(System.Object,System.Object)">
            <summary>Adds one item at the specified key.</summary>
            <param name="key">Key of the object to add. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <param name="value">An item to add into the dictionary.</param>
            <remarks><para>If item (or several items) are already stored at specified key, this method fails. To check whether the item with such key exists, use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Contains(System.Object)" /> method.</para><para>An alternative way to add new entries into the dictionary is to use <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> method. Unlike <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Add(System.Object,System.Object)" /> method, if the key is found in the dictionary, new item overwrites the old value. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Clear">
            <summary>Remove all items from the dictionary.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Contains(System.Object)">
            <summary>Checks whether the dictionary contains an element with the specified key.</summary>
            <param name="key">Key of the object to check. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <returns>Value that equals to <b>true</b> when dictionary contains any data at specified key, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.ConvertKeyToObject(System.UInt32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.ConvertKeyToUint(System.Object)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.ConvertValueToDataItem(System.Object,System.IntPtr)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.ConvertValueToObject(System.UInt32,System.IntPtr)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.CopyTo(System.Array,System.Int32)">
            <summary>Copies the elements of the dictionary into the specified array beginning from specified index.</summary>
            <param name="array">One-dimensional zero-based <see cref="T:System.Array" /> that is the destination for the items. Items are values without keys.</param>
            <param name="index">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Count">
            <summary>Gets number of items in the dictionary.</summary>
            <value>Value that contains number of items in the dictionary.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetItemArray(System.Object)">
            <summary>Gets all items with the specified key.</summary>
            <param name="key">Key of the objects to get. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <returns>An array of returned items.</returns>
            <remarks><para>The essential difference from <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> property is that this method returns an array, even if only one item is stored at this key. In contrast, property <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> returns the item itself, and if several items are available at the specified key, it returns the first one. </para><para>
Therefore it is preferrable to use this method instead of <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" />. However if you do not care about handling all values, you still can use <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)" /> since it has simpler syntax.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetItemString(System.Object)">
            <summary>Gets a string representation of the item with the specified key.</summary>
            <param name="key">Key of the object to get or set. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <returns>A string representation for the item to get.</returns>
            <remarks><para>If at this key several values are stored, this property will return all these values concatenated into the single string separated by the whitespace. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetKeyDescription(System.Object)">
            <summary>Returns textual description for the specified key.</summary>
            <param name="key">The key to get textual description for. Must be one of predefined keys (see static fields of <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />).</param>
            <returns>Value that contains textual description of the key.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.IDictionary.GetEnumerator">
            <summary>Returns an enumerator for pairs key-value.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IDictionaryEnumerator">System.Collections.IDictionaryEnumerator</see> interface.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for pairs key-value.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.IsFixedSize">
            <summary>Indicates whether the dictionary has a fixed size.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.IsReadOnly">
            <summary>Indicates whether the dictionary is a read-only.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.IsSynchronized">
            <summary>Indicates whether the dictionary is synchronized.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Item(System.Object)">
            <summary>Gets/sets item with the specified key.</summary>
            <param name="key">Key of the object to get or set. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <value>An item to get or set.</value>
            <remarks><para>If at this key several values are stored, this property will return the first item. To return all the items, use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetItemArray(System.Object)" /> method. </para><para>If you need to extract a string representation of this item, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.GetItemString(System.Object)" /> method. For those items which returns a enumeration value, it will return human-friendly string instead of the number.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Keys">
            <summary>Returns a collection of keys stored in this dictionary.</summary>
            <value>An object that implements <see cref="T:System.Collections.ICollection" /> that contains keys stored in this dictionary.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Remove(System.Object)">
            <summary>Removes the item with specified key.</summary>
            <param name="key">Key of the object to remove. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <remarks>If specified key was not found, method just do nothing.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.SetItemArray(System.Object,System.Object[])">
            <summary>Sets multiple items at specified key.</summary>
            <param name="key">Key of the objects to set. Typically it is a number that represents an EXIF or IPTC tag. Most used tags are available as static members of  <see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> and <see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" />.</param>
            <param name="value">An array of values to put into the dictionary at specified key.</param>
            <remarks><para>If item (or several items) are already stored at specified key, this method overwrites it (or them). To check whether the item with such key exists, use <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Contains(System.Object)" /> method.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access was not implemented in <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary" />).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataDictionary.Values">
            <summary>Returns a collection of values (without keys) stored in this dictionary.</summary>
            <value>An object that implements <see cref="T:System.Collections.ICollection" /> that contains values stored in this dictionary.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MetadataDictionaryProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MetadataEnumerator">
            <summary>Provides a forward-only cursor to enumerate through metadata in a file.</summary>
            <remarks><para>This interface should be implemented by each class that supports metadata.</para><para>This interface inherits from the <see cref="T:System.Collections.IEnumerator" /> interface.</para><para>Initially, the enumerator is positioned before the first element in the collection. At this position, calling <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Current" /> throws an exception. Therefore, you must call <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.MoveNext" /> to advance the enumerator to the first element of the collection before reading the value of <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Current" />.</para><para>After the end of the collection is passed, the enumerator is positioned after the last element in the collection, and calling <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.MoveNext" /> returns <b>false</b>. If the last call to <see cref="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.MoveNext" /> returned <b>false</b>, calling <see cref="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Current" /> throws an exception.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Current">
            <summary>Gets a current key-value pair as an <see cref="T:System.Object" />.</summary>
            <value>A current key-value pair.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Entry">
            <summary>Gets a both a key and a value of the current entry.</summary>
            <value>Current key-value pair.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Key">
            <summary>Gets a current key.</summary>
            <value>Current key.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.MoveNext">
            <summary>Moves to the next key-value pair in a sequence.</summary>
            <returns>A <see cref="T:System.Boolean" /> value specifying whether the next pair can be read or not.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.#ctor(Aurigma.GraphicsMill.Codecs.MetadataDictionary)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataEnumerator" /> instance for the specified <see cref="T:Aurigma.GraphicsMill.Codecs.MetadataDictionary" /> collection.</summary>
            <param name="metaData">Metadata collection for which the enumerator should be created.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Reset">
            <summary>Resets the cursor to the beginning of the metadata collection.</summary>
            <remarks>Resets frame enumerator and sets the cursor before the first pair in a sequence.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.MetadataEnumerator.Value">
            <summary>Gets a value from the current key-value pair.</summary>
            <value>Current value.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.MultiFrameException">
            <summary>This exception is thrown when you try to add more frames than current format allows.</summary>
            <remarks>For example, this exception will be thrown when you try to add two image frames into JPEG.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MultiFrameException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MultiFrameException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MultiFrameException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Codecs.MultiFrameException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.MultiFrameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PcxEncoderOptions">
            <summary>This class represents PCX encoder options. Currently it is empty.</summary>
            <remarks>PCX format is not supported for saving, so you cannot use it.</remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxEncoderOptions" /> class instance.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass the necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PcxFrame">
            <summary>This class represents a frame of the PCX format.</summary>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxFrame.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxFrame" /> class instance. You can associate a bitmap with this frame here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PcxReader">
            <summary>This class enables you to read PCX images.</summary>
            <remarks>This quite old image format is developed by ZSoft Corporation. Data of this format is compressed using the Run-Length-Encoding (RLE) compression algorithm. PCX format supports palette-based and 24-bit RGB images.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PcxReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PcxReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions">
            <summary>This class holds PDF encoder options.</summary>
            <remarks><para>
              Graphics Mill for .NET allows to save the bitmap as PDF file. You can specify compression type for it using <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Compression" /> property. If you are using <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression, you can specify a JPEG quality via <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Quality" /> property.
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class aalways returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.PdfFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for PDF and always set to 0.</para></remarks>
            <example><para>This code sample demonstrates how to save an image to the PDF file:</para><code language="VB" source="FileFormatsVB/form1.vb#PDFSync"></code><code language="CS" source="FileFormatsCS/form1.cs#PDFSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Compression">
            <summary>Gets/sets PDF compression type.</summary>
            <value>Value that specifies necessary PDF compression type.</value>
            <remarks><para>
PDF format supports the following compression types:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for PDF files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for PDF files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Quality" /> property.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> unless you pass JPEG quality into <see cref="M:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.#ctor(System.Int32)">constructor</see>.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.IsPrintingEnabled" draft="yes">
            <summary>Gets/sets a value that specifies whether PDF should be printed when the user opens it.</summary>
            <value><b>true</b> if PDF should be printed when it is opened; otherwise, <b>false</b>.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions" /> class instance.</summary>
            <remarks>When this constructor is used, <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Compression" /> property is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" />.</remarks>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions" /> class instance.</summary>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Quality" /> property.</param>
            <remarks>When this constructor is used, <see cref="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Compression" /> property is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.Quality" draft="yes">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PdfFrame">
            <summary>This class represents a frame of the PDF format.</summary>
            <example><para>The same, but using <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class. This class provides more flexible file saving support. In particular, you can use asynchronous mode, etc.</para><code language="VB" source="FileFormatsVB/form1.vb#PDFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PDFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Compression">
            <summary>Gets/sets PDF compression type.</summary>
            <value>Value that specifies necessary PDF compression type.</value>
            <remarks><para>
PDF format supports the following compression types:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for PDF files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations. Supported with all pixel formats allowed for PDF files.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Quality" /> property.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> unless you pass <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Quality" /> into constructor.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance. You can associate a bitmap with this frame here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance. You can associate a bitmap with this frame here and initialize JPEG quality.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it using <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Compression" /> is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance. You can initialize JPEG quality here.</summary>
            <param name="quality">Value in range [0, 100] specifying JPEG quality. You can change it using <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Compression" /> is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfFrame.Quality">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PdfWriter">
            <summary>This class enables you to read PDF images.</summary>
            <remarks><para>
              PDF stands for Portable Document Format. This format was developed by Adobe Systems Incorporated for the secure and reliable distribution and exchange of electronic documents and nowadays this formats became standard de facto in this field. In general this formats contains not only raster images, but also vector data and texts. However Graphics Mill for .NET can only embed raster images to PDF file.
            </para><para>
You can create multiple pages in the PDF file. Bitmaps stored in the frame can be of most all the pixel format. 
</para></remarks>
            <example><para>The same, but using <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class. This class provides more flexible file saving support. In particular, you can use asynchronous mode, etc.</para><code language="VB" source="FileFormatsVB/form1.vb#PDFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PDFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.PdfFrame" /> class instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PdfWriter.IsPrintingEnabled" draft="yes">
            <summary>Gets/sets a value that specifies whether PDF should be printed when the user opens it.</summary>
            <value><b>true</b> if PDF should be printed when it is opened; otherwise, <b>false</b>.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PdfWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PdfWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PngEncoderOptions">
            <summary>This class holds PNG encoder options.</summary>
            <remarks><para>
The only PNG-related option which is available is whether to make it interlaced.
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.PngFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. . <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for PNG and always set to 0.</para></remarks>
            <example><para>The code below converts the JPEG file into the PNG. It also demonstrates how to change PNG encoder settings.</para><code language="VB" source="FileFormatsVB/form1.vb#PNGSync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGSync"></code><para>This code sample converts the image into the indexed bitmap with 32 palette entries. After that it saves this bitmap into the PNG file.</para><code language="VB" source="FileFormatsVB/form1.vb#PNGPaletteSync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGPaletteSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PngEncoderOptions.Interlaced">
            <summary>Gets/sets a value that specifies if the PNG file should be interlaced.</summary>
            <value>Value that specifies if the PNG file should be interlaced.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngEncoderOptions.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Codecs.PngEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Codecs.PngEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngEncoderOptions.#ctor(System.Boolean)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Codecs.PngEncoderOptions" /> class instance. You can specify if to make PNG interlaced here.</summary>
            <param name="interlaced">Value that specifies if the PNG file should be interlaced. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.PngEncoderOptions.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PngFrame">
            <summary>This class represents a frame of the PNG format.</summary>
            <example><para>Also you can use <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#PNGAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGAsync"></code><para>This code sample converts the image into the indexed bitmap with 32 palette entries. After that it saves this bitmap into the PNG file.</para><code language="VB" source="FileFormatsVB/form1.vb#PNGPaletteAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGPaletteAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PngFrame.Interlaced">
            <summary>Gets/sets a value that specifies if the PNG file should be interlaced.</summary>
            <value>Value that specifies if the PNG file should be interlaced.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngFrame" /> class instance. You can associate a bitmap with it as well as set all the frame settings here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="interlaced">Value that specifies if the PNG file should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.PngFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.#ctor(System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngFrame" /> class instance. You can set all the frame settings here.</summary>
            <param name="interlaced">Value that specifies if the PNG file should be interlaced. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.PngFrame.Interlaced" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PngReader">
            <summary>This class enables you to read PNG images.</summary>
            <remarks><para>
The Portable Network Graphics (PNG) format was designed to replace the older and simpler GIF format and, to some extent, the much more complex TIFF format. Besides of it, PNG was developed to avoid legal problems which was caused by LZW algorithm used in GIF and sometimes in TIFF. For the Web, PNG really has four main advantages over GIF: 
</para><list type="bullet"><item><description>Alpha channel support (variable transparency);</description><description>Gamma correction (cross-platform control of image brightness);</description><description>Two-dimensional interlacing (a method of progressive display);</description><description>In general it has higher compression ratio comparing to GIF (and still lossless);</description></item></list><para>
  PNG supports images of most Graphics Mill for .NET pixel formats (indexed, grayscale, and RGB, including extended versions). Being web-oriented, it does not support CMYK images. Only single bitmap can be stored into single PNG file (i.e. it has no multiple frames support).
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" /> class instance.</summary>
            <overloads><summary>
  Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" /> class instance.
</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PngReader.SkipCrcCheck">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PngWriter">
            <summary>This class enables you to write PNG images.</summary>
            <remarks><para>
  The Portable Network Graphics (PNG) format was designed to replace the older and simpler GIF format and, to some extent, the much more complex TIFF format. Besides of it, PNG was developed to avoid legal problems which was caused by LZW algorithm used in GIF and sometimes in TIFF. For the Web, PNG really has four main advantages over GIF:
</para><list type="bullet"><item><description>Alpha channel support (variable transparency);</description><description>Gamma correction (cross-platform control of image brightness);</description><description>Two-dimensional interlacing (a method of progressive display);</description><description>In general it has higher compression ratio comparing to GIF (and still lossless);</description></item></list><para>
  PNG supports images of most Graphics Mill for .NET pixel formats (indexed, grayscale, and RGB, including extended versions). Being web-oriented, it does not support CMYK images. Only single bitmap can be stored into single PNG file (i.e. it has no multiple frames support).
</para></remarks>
            <example><para>Also you can use <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#PNGAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGAsync"></code><para>This code sample converts the image into the indexed bitmap with 32 palette entries. After that it saves this bitmap into the PNG file.</para><code language="VB" source="FileFormatsVB/form1.vb#PNGPaletteAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#PNGPaletteAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.PngFrame" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PngWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PngWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PreLoadedFrame">
            <summary>This class represents a frame returned by <see cref="T:Aurigma.GraphicsMill.Codecs.FormatReader" /> and always containing a bitmap.</summary>
            <remarks><para>This abstract class is used for reading unseekable movies and, therefore, such kind of frames should already contain a bitmap, in contrast to the <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> objects.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.BitsPerPixel">
            <summary>Gets a number of bits per pixel in the bitmap stored in the frame.</summary>
            <value>An integer value which stores a number of bits per pixel of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.ColorProfile">
            <summary>Gets a color profile of the bitmap stored in the frame.</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance which represents the color profile of the current frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.ColorSpace">
            <summary>Gets a color space of the bitmap stored in the frame.</summary>
            <value>An <see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value which specifies a color space of the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.HasAlpha">
            <summary>Gets a value specifying whether the bitmap stored in the frame has alpha channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has alpha channel.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Height">
            <summary>Returns the frame height.</summary>
            <value>Frame height (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.HorizontalResolution">
            <summary>Gets a horizontal resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a horizontal resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Index">
            <summary>Returns frame index in the format reader (if applicable).</summary>
            <value>Frame index in the format reader.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.IsCmyk">
            <summary>Gets a value specifying whether the bitmap stored in the frame is CMYK.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is CMYK.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.IsExtended">
            <summary>Gets a value specifying whether the bitmap stored in the frame has 16 bits per channel.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame has 16 bits per channel (i.e. extended pixel format).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.IsGrayScale">
            <summary>Gets a value specifying whether the bitmap stored in the frame is grayscale.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is grayscale.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.IsIndexed">
            <summary>Gets a value specifying whether the bitmap stored in the frame is indexed.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is indexed.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.IsRgb">
            <summary>Gets a value specifying whether the bitmap stored in the frame is RGB.</summary>
            <value>A <see cref="T:System.Boolean" /> value specifying whether the bitmap stored in the frame is RGB.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Left">
            <summary>Returns horizontal position of the left top corner of the frame.</summary>
            <value>X-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Name">
            <summary>Returns the frame name (if defined).</summary>
            <value>Frame name.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.#ctor(System.IntPtr,System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.#ctor(System.IntPtr,System.Int32,System.String)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.PixelFormat">
            <summary>Returns a pixel format of the bitmap stored in this frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies a pixel format of the bitmap stored in this frame.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.SetBitmap(Aurigma.GraphicsMill.Bitmap)">
            <summary>Puts a bitmap into frame.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Top">
            <summary>Returns vertical position of the left top corner of the frame.</summary>
            <value>Y-coordinate of the left top corner of the frame (in pixels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.VerticalResolution">
            <summary>Gets a vertical resolution of the bitmap stored in the frame.</summary>
            <value>An integer value which specifies a vertical resolution of the bitmap stored in the frame.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PreLoadedFrame.Width">
            <summary>Returns the frame width.</summary>
            <value>Frame width (in pixels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions">
            <summary>This class represents PSD encoder options. Currently it is empty.</summary>
            <remarks>PSD format is not supported for saving, so you cannot use it.</remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions.Exif">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions.Iptc">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions" /> class instance.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PsdFrame">
            <summary>This class represents a frame of the PSD format.</summary>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdFrame.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdFrame" /> class instance. You can associate a bitmap with this frame here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.PsdReader" draft="yes">
            <summary>This class enables you to read PSD images.</summary>
            <remarks><para>
              PSD is the native bitmap file format of the Adobe Photoshop graphics editor. This format is standard de facto for designers all over the world. This format is rather complex and stores a lot of data (image layers, text, effects, etc). It is rather complex task to parse it and merge all the layers as they are displayed in the Photoshop. The good news is that PSD file always stores image where all the layers are merged in correct way. Graphics Mill for .NET can load this merged layer, so you can work with PSD files as well as with other image formats.</para></remarks>
            <example><para>The code sample below extracts EXIF and IPTC metadata from the PSD file and displays it. It also demonstrates the usage of the <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class.</para><code language="VB" source="FileFormatsVB/form1.vb#PsdMetadata"></code><code language="CS" source="FileFormatsCS/form1.cs#PsdMetadata"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdReader.AdobeResources" draft="yes">
            <summary>Gets Adobe image resource blocks from file.</summary>
            <value>Not currently implemented, so NULL is always returned.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdReader.Exif" draft="yes">
            <summary>Gets EXIF data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection obtained from the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdReader.Iptc">
            <summary>Gets IPTC data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection obtained from the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.PsdReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.PsdReader.OnOpen">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.PsdReader.Xmp" draft="yes">
            <summary>Gets the XML code containing the XMP metadata.</summary>
            <value>Not currently implemented, so NULL is always returned.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions">
            <summary>This class holds SWF encoder options.</summary>
            <remarks><para>
This class enables to initialize both entire SWF file and separate frames settings. Usually you can use this class from <see cref="E:Aurigma.GraphicsMill.Bitmap.Saving" /> event handler to modify both global and frames settings. If you set global settings for the same file multiple times, only settings specified at the first time are used.
</para><para>This table gives the explanation for all SWF settings:</para><list type="table"><listheader><term>Property</term><term>Description</term></listheader><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> (frame)</description><description>Specifies a compression type for the SWF frame.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> (frame)</description><description>Specifies a delay time for this frame.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod" /> (frame)</description><description>Specifies a disposal method for the frame (what to do with the screen when new frame is being displayed).</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> (frame)</description><description>Specifies a JPEG quality (used if compression type is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />).</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> (global)</description><description>Specifies a background color for the SWF movie.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width" /> (global)</description><description>Specifies a SWF movie width.</description></item><item><description><see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height" /> (global)</description><description>Specifies a SWF movie height.</description></item></list><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.SwfFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are used to specify offset of the frame relatively top left corner of the SWF movie.</para></remarks>
            <example><para>The code sample below converts JPEG file into the SWF image frame.</para><code language="VB" source="FileFormatsVB/form1.vb#SWFSync"></code><code language="CS" source="FileFormatsCS/form1.cs#SWFSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor">
            <summary>Gets/sets a background color for the SWF movie.</summary>
            <value>Background color for the SWF movie.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression">
            <summary>Gets/sets SWF compression type for the frame.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.CompressionType" /> value that specifies necessary SWF compression type.</value>
            <remarks><para>
SWF format allows to specify compression for each frame individually. Supported compression types are listed in the following table:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations. </description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" />.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay">
            <summary>Gets/sets a number of hundredths (1/100) of a second to wait after rendering the frame.</summary>
            <value>Number of hundredths (1/100) of a second to wait after rendering the frame.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod">
            <summary>Gets/sets disposal method, i.e. what to do with the screen when new frame is being displayed.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.</value>
            <remarks><para>SWF supports only <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" /> and <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.Previous" /> members of the <see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> enumeration.</para><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" />.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height">
            <summary>Gets/sets SWF movie height.</summary>
            <value>SWF movie height (in pixels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(Aurigma.GraphicsMill.RgbColor)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set movie background color here.</summary>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(Aurigma.GraphicsMill.RgbColor,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set frame compression type and movie background color here.</summary>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set JPEG compression quality here.</summary>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set delay and disposal method of the frame.</summary>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set delay and disposal method of the frame as well as JPEG quality.</summary>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.RgbColor,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set such movie parameters as dimensions, background color, and also frame delay.</summary>
            <param name="width">SWF movie width (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width" /> property.</param>
            <param name="height">SWF movie height (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height" /> property.</param>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.RgbColor,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set such movie parameters as dimensions, background color, and also frame delay and disposal method.</summary>
            <param name="width">SWF movie width (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width" /> property.</param>
            <param name="height">SWF movie height (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height" /> property.</param>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.RgbColor,System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set such movie parameters as dimensions, background color, and also frame delay and JPEG quality.</summary>
            <param name="width">SWF movie width (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width" /> property.</param>
            <param name="height">SWF movie height (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height" /> property.</param>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.RgbColor,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions" /> class instance. You can set such movie parameters as dimensions, background color, and also frame delay, disposal method and JPEG quality.</summary>
            <param name="width">SWF movie width (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width" /> property.</param>
            <param name="height">SWF movie height (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Height" /> property.</param>
            <param name="backgroundColor">Background color for the SWF movie. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.BackgroundColor" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</param>
            <param name="delay">Number of hundredths (1/100) of a second to wait after rendering the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Delay" /> property.</param>
            <param name="disposalMethod"><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.DisposalMethod" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Width">
            <summary>Gets/sets SWF movie width.</summary>
            <value>SWF movie width (in pixels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.SwfFrame">
            <summary>This class represents a frame of the SWF format.</summary>
            <example><para>To create an animated SWF movie we need to use the <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class. The movie is created from the several JPEG files.</para><code language="VB" source="FileFormatsVB/form1.vb#SWFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#SWFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Compression">
            <summary>Gets/sets SWF compression type for the frame.</summary>
            <value>Value that specifies necessary SWF compression type.</value>
            <remarks><para>
SWF format allows to specify compression for each frame individually. Supported compression types are listed in the following table:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations. </description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> property.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> unless you pass <see cref="P:Aurigma.GraphicsMill.Codecs.SwfEncoderOptions.Quality" /> into constructor.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Delay">
            <summary>Gets/sets a number of hundredths (1/100) of a second to wait after rendering the frame.</summary>
            <value>Number of hundredths (1/100) of a second to wait after rendering the frame.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfFrame.DisposalMethod">
            <summary>Gets/sets disposal method, i.e. what to do with the screen when new frame is being displayed.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> value that specifies a disposal method for the frame.</value>
            <remarks><para>SWF supports only <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" /> and <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.Previous" /> members of the <see cref="T:Aurigma.GraphicsMill.Codecs.DisposalMethod" /> enumeration.</para><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.DisposalMethod.None" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can associate a bitmap with this frame as well as set frame position here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can associate a bitmap with this frame as well as set JPEG compression quality and frame position here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can associate a bitmap with this frame as well as set frame position, delay, and disposal method.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="delay">Delay of the frame in hundredths (1/100) of a second. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Delay" /> property.</param>
            <param name="disposalMethod">Disposal method of the frame, i.e. how to replace this frame by the next one. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.DisposalMethod" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can associate a bitmap with this frame as well as set all SWF frame settings.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="delay">Delay of the frame in hundredths (1/100) of a second. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Delay" /> property.</param>
            <param name="disposalMethod">Disposal method of the frame, i.e. how to replace this frame by the next one. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.DisposalMethod" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can set frame position here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can specify frame position and JPEG compression quality here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can specify frame position, delay, and disposal method.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="delay">Delay of the frame in hundredths (1/100) of a second. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Delay" /> property.</param>
            <param name="disposalMethod">Disposal method of the frame, i.e. how to replace this frame by the next one. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.DisposalMethod" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.#ctor(System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Codecs.DisposalMethod,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance. You can set all SWF frame settings here.</summary>
            <param name="left">X-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Left" /> property.</param>
            <param name="top">Y-coordinate of the top left corner of the frame (in pixels). You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.Frame.Top" /> property.</param>
            <param name="delay">Delay of the frame in hundredths (1/100) of a second. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Delay" /> property.</param>
            <param name="disposalMethod">Disposal method of the frame, i.e. how to replace this frame by the next one. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.DisposalMethod" /> property.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfFrame.Quality">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.SwfWriter" draft="yes">
            <summary>This class enables you to write SWF movies.</summary>
            <remarks><para>
SWF format was developed by Macromedia Inc. It stands for "Shockwave File Format". The SWF file format is ideal for vector graphics that may have audio and may even be interactive. To open the SWF file the web browser may use the flash plug-in. 
</para><para>
  Graphics Mill for .NET allows creating SWF movies built from the multiple bitmaps. Bitmaps can be indexed or 8 bit per channel RGB images (both with and without alpha).
</para></remarks>
            <example><para>To create an animated SWF movie we need to use the <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class. The movie is created from the several JPEG files.</para><code language="VB" source="FileFormatsVB/form1.vb#SWFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#SWFAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfWriter.BackgroundColor">
            <summary>Gets/sets a background color for the SWF movie.</summary>
            <value>Background color for the SWF movie.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.SwfFrame" /> class instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Height">
            <summary>Gets/sets the entire SWF movie height.</summary>
            <value>The entire SWF movie height (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Height" /> properties you specify a "viewport" for the SWF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>If <b>0</b> is specified, the height of the bitmap stored in the first frame will be used.</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.SwfWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.SwfWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Width">
            <summary>Gets/sets the entire SWF movie width.</summary>
            <value>The entire SWF movie width (in pixels).</value>
            <remarks><para>
Using <see cref="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Width" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.SwfWriter.Height" /> properties you specify a "viewport" for the SWF file. If you put the frame which exceeds of these dimensions, it is cropped.
</para><para>If <b>0</b> is specified, the width of the bitmap stored in the first frame will be used.</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffChannelType" draft="yes">
            <summary>Contains possible extra channel types.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.TiffChannelType.Alpha" draft="yes">
            <summary>Unassociated alpha data stores transparency information that logically exists independent of an image.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.TiffChannelType.Color" draft="yes">
            <summary>Color data.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.TiffChannelType.PremultipliedAlpha" draft="yes">
            <summary>Associated alpha data stores opacity information which implies that not only alpha channel itself is stored in the file, but also color channels of each pixel are premultiplied with the corresponding alpha channel value.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.TiffChannelType.Undefined" draft="yes">
            <summary>Unspecified data stores some non-color information of the image.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions" draft="yes">
            <summary>This class holds TIFF encoder options.</summary>
            <remarks>The main TIFF encoder setting is a compression type. To change compression type use <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Compression" /> property. This property accepts members of the <see cref="T:Aurigma.GraphicsMill.Codecs.CompressionType" /> enumeration.
<para>
Another setting which can be specified is alpha premultiplication. This option has meaning only when saving image with alpha channel. You can turn it on or off using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.AlphaPremultiplied" /> property. The default value of this property is <b>false</b> and content of the alpha channel is simply stored along with color channels of the image by default. The second way is to store image with "associated" alpha channel. This way implies that not only alpha channel itself will be encoded into the file, but also color channels of each pixel will be premultiplied with the corresponding alpha channel value.
</para><para>You should use TIFF files with associated alpha if you have software which gain some benefit from them. For example, TIFF files with premultiplied alpha are correctly shown as partially transparent images in Adobe Photoshop, while images with unassociated alpha are shown as non transparent images with additional channel. But you should take into account that premultiplication process slows down encoding and introduces rounding error. So you should not set this property to <b>true</b> without reason.
</para><para></para><para>Also you can provide meta-information for encoding. Use <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.AdobeResources" />, <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Exif" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Iptc" /> properties to specify corresponding metadata objects.
</para><para><see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.MediaFormat" /> property of this class always returns value that equals to <see cref="F:Aurigma.GraphicsMill.Codecs.FormatManager.TiffFormat" /> static field of the <see cref="T:Aurigma.GraphicsMill.Codecs.FormatManager" /> class. <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Left" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.EncoderOptions.Top" /> are meaningless for TIFF and always set to 0.</para></remarks>
            <example><para>This code sample demonstrates how to save the TIFF with the single frame. It just converts the JPEG file into the TIFF format.</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFSync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFSync"></code><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.AlphaPremultiplied" draft="yes">
            <summary>Gets/sets the value that determines whether to premultiply image with alpha channel during image encoding or not.</summary>
            <value>The value which determines whether to premultiply color channels of each pixel with corresponding alpha channel during image encoding or not.</value>
            <remarks><para>The value of this property has meaning only when saving image with alpha channel.
</para><para>TIFF specification defines two ways of alpha channel encoding. 
<list type="bullet"><item>The first is so called "unassociated alpha" - when content of the alpha channel is simply stored along with color channels of the image. This is default behaviour.</item><item>The second way is to store image with "associated" alpha channel. This way implies that not only alpha channel itself will be encoded into the file, but also color channels of each pixel will be premultiplied with the corresponding alpha channel value.</item></list></para><para>
You should use TIFF files with associated alpha if you have software which gain some benefit from them (for example, unassociated alpha channel will be shown as separate channel in Adobe Photoshop, while image with associated alpha will be shown as image with transparency). But you should take into account that premultiplying process slows down encoding and introduces rounding error. So you should not set this property to <b>true</b> without reason.
</para><para>
There is no difference for you between files with "associated" and "unassociated" alpha if you process them with Graphics Mill for .NET. <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class implementation takes into account this option during image decoding and performs demultiplication if necessary. So you will always get usual <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object with "unassociated" alpha. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Compression">
            <summary>Gets/sets TIFF compression type.</summary>
            <value>Value that specifies necessary TIFF compression type.</value>
            <remarks><para>
TIFF format supports the following compression types:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt3" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt4" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.CcittRle" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Quality" /> property.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Rle" /> compression type.</term><description>Has no limitations, but works better with indexed images.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Lzw" /> compression type.</term><description>No limitations.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" />.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
            <example><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataSync"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.ExtraChannels" draft="yes">
            <summary>Gets/sets the collection containing extra channels associated with the TIFF file. Using this property you can write some channels in addition to primary ones.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection" /> class instance that contains extra channels associated with the TIFF file.</value>
            <seealso href="WorkingwithTIFFExtraChannels.htm" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Iptc">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
            <example><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataSync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataSync"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.#ctor(Aurigma.GraphicsMill.Codecs.CompressionType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions" /> class instance. You can specify compression type here.</summary>
            <param name="compression">Value that specifies necessary TIFF compression type. You can change it later through <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions" /> class instance. You can specify JPEG compression quality here.</summary>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Quality">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Xmp" draft="yes">
            <summary>Gets/sets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata.</value>
            <remarks><para>To modify the XMP data, you can use either the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or standard .NET XML-processing means according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" draft="yes">
            <summary>This class represents the TIFF extra channel.</summary>
            <remarks>One of the most important features of the TIFF image format is the extra channels support. Extra channels are typically used to specify non-color information (such as image opacity), highlight some image area, or apply additional inks (such as gold, silver, etc.) in printing solutions.</remarks>
            <seealso href="WorkingwithTIFFExtraChannels.htm">Working with TIFF Extra Channels</seealso>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.ChannelType" draft="yes">
            <summary>Gets/sets a type of the extra channel.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.TiffChannelType" /> enumeration member that specifies the extra channel type.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.GetBitmap(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Returns bitmap stored in this extra channel.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance stored in the extra channel.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.#ctor(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Codecs.TiffChannelType)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" /> class instance. You can associate a bitmap with this extra channel as well as set its type here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this extra channel. To put another bitmap into channel, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="channelType">Value that specifies necessary TIFF extra channel type. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.ChannelType" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannel.SetBitmap(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Puts a bitmap into the extra channel.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this extra channel.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection" draft="yes">
            <summary>This class represents a collection of TIFF extra channels.</summary>
            <remarks>The collection contains all extra channels associated with the TIFF page. Using this property you can either obtain all extra channels from the page or write some channels in addition to primary ones.</remarks>
            <seealso href="WorkingwithTIFFExtraChannels.htm" />
<seealso cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Add(Aurigma.GraphicsMill.Codecs.TiffExtraChannel)" draft="yes">
            <summary>Adds an extra channel to the collection.</summary>
            <param name="item">A <see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannel" /> class instance to add.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Clear" draft="yes">
            <summary>Removes all extra channels from the collection.</summary>
            <remarks>This method sets the <see cref="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Count" /> value to zero.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Contains(Aurigma.GraphicsMill.Codecs.TiffExtraChannel)" draft="yes">
            <summary>Determines whether an extra channel is in the collection.</summary>
            <param name="item">An extra channel to locate in the collection.</param>
            <returns><b>true</b> if the extra channel is found in the collection; otherwise, <b>false</b>.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Count" draft="yes">
            <summary>Gets the number of extra channels actually contained in the collection.</summary>
            <value>The number of extra channels actually contained in the collection.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.GetEnumerator" draft="yes">
            <summary>Returns an enumerator for the extra channels allowing the collection to be used in <b>foreach</b> blocks.</summary>
            <returns>An enumerator that implements the <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.IndexOf(Aurigma.GraphicsMill.Codecs.TiffExtraChannel)" draft="yes">
            <summary>Searches for the specified extra channel and returns the zero-based index of the first occurrence within the entire collection.</summary>
            <param name="item">The extra channel to locate in the collection.</param>
            <returns>A zero-based index of the first occurrence of the extra channel within the entire collection, if found; otherwise, -1.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Insert(System.Int32,Aurigma.GraphicsMill.Codecs.TiffExtraChannel)" draft="yes">
            <summary>Inserts an extra channel into the collection at the specified index.</summary>
            <param name="index">A zero-based index at which an extra collection should be added.</param>
            <param name="item">An extra channel to insert.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.IsFixedSize" draft="yes">
            <summary>Gets a value indicating whether the collection has a fixed size.</summary>
            <value><b>true</b> if the collection has a fixed size; otherwise, <b>false</b>. The default is <b>false</b>.</value>
            <remarks>A collection with a fixed size does not allow the addition or removal of extra channels after the collection is created, but it allows the modification of existing extra channels.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.IsReadOnly" draft="yes">
            <summary>Gets a value indicating whether the collection is read-only.</summary>
            <value><b>true</b> if the collection is read-only; otherwise, <b>false</b>. The default is <b>false</b>.</value>
            <remarks>A collection that is read-only does not allow the addition, removal, or modification of extra channels after the collection is created.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Item(System.Int32)" draft="yes">
            <summary>Gets/sets the extra channel at the specified index.</summary>
            <param name="index">The zero-based index of the extra channel to get or set.</param>
            <value>The extra channel at the specified index.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.Remove(Aurigma.GraphicsMill.Codecs.TiffExtraChannel)" draft="yes">
            <summary>Removes the first occurrence of a specific extra channel from the collection.</summary>
            <param name="item">An extra channel to remove from the collection.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection.RemoveAt(System.Int32)" draft="yes">
            <summary>Removes the extra channel at the specified index of the collection.</summary>
            <param name="index">The zero-based index of the extra channel to remove.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffFrame">
            <summary>This class represents a frame of the TIFF format.</summary>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFAsync"></code><para>To load the TIFF files that contains multiple frames, you should use a <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class. The code below demonstrates its usage. It reads multipage TIFF file and save each page into the separate JPEG file.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#Loading2"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Loading2"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Compression">
            <summary>Gets/sets TIFF compression type.</summary>
            <value>Value that specifies necessary TIFF compression type.</value>
            <remarks><para>
TIFF format supports the following compression types:
</para><list type="table"><listheader><term>Compression Type</term><description>Limitations</description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" /> compression type.</term><description>No limitations.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt3" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Ccitt4" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.CcittRle" /> compression type.</term><description>For 1-bit images only.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> compression type.</term><description>Can be used only with those pixel formats which are supported by JPEG (non-extended and non-indexed grayscale, RGB, and CMYK images). To adjust JPEG quality, use <see cref="P:Aurigma.GraphicsMill.Codecs.TiffEncoderOptions.Quality" /> property.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Rle" /> compression type.</term><description>Has no limitations, but works better with indexed images.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Lzw" /> compression type.</term><description>No limitations.</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Zip" /> compression type.</term><description>No limitations.</description></item></list><para>Default value is <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.None" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffFrame.ExtraChannels" draft="yes">
            <summary>Gets/sets the collection containing all extra channels associated with the frame. Using this property you can either obtain all extra channels from the TIFF page or write some channels in addition to primary ones.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.TiffExtraChannelCollection" /> class instance that contains all extra channels associated with the frame</value>
            <seealso href="WorkingwithTIFFExtraChannels.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.#ctor(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Codecs.CompressionType)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance. You can associate a bitmap with this frame as well as set compression type here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="compression">Value that specifies necessary TIFF compression type. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance. You can associate a bitmap and specify JPEG compression quality here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.#ctor(Aurigma.GraphicsMill.Codecs.CompressionType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance. You can set compression type here.</summary>
            <param name="compression">Value that specifies necessary TIFF compression type. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Compression" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance. You can specify JPEG compression quality here.</summary>
            <param name="quality">Number in range [0, 100] that specifies quality of JPEG compression. Large values means higher quality, but larger file size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Quality" /> property.</param>
            <remarks>If you use this constructor, <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Compression" /> property will be set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get frame settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffFrame.Quality">
            <summary>Gets/sets a JPEG quality if compression type is set to <see cref="F:Aurigma.GraphicsMill.Codecs.CompressionType.Jpeg" />.</summary>
            <value>Value in range [0, 100] specifying JPEG quality.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffReader" draft="yes">
            <summary>This class enables you to read TIFF images.</summary>
            <remarks><para>
TIFF format is one of the most comprehensive image formats. It was designed to promote the interchange of digital image data. The general scenario TIFF format was invented for, assumes that scanning or painting software creates a TIFF file, which can then be read and incorporated into a document or publication by an application such as a desktop publishing package. It is also widely used to retrieve facsimile messages.
</para><para>
  This image format is rather versatile and have a lot of modifications. It supports most Graphics Mill for .NET pixel formats even such exotic ones like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format80bppAcmyk" />. It also can store multiple images in the single file (mostly used for fax images and other documents stored as 1-bit bitmaps).
</para><para>TIFF files can also contain Adobe resources, XML, EXIF and IPTC data.</para></remarks>
            <example><para>To load the TIFF files that contains multiple frames, you should use a <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class. The code below demonstrates its usage. It reads multipage TIFF file and save each page into the separate JPEG file.</para><code language="VB" source="LoadingAndSavingVB/form1.vb#Loading2"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#Loading2"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffReader.AdobeResources" draft="yes">
            <summary>Gets Adobe image resource blocks from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks obtained from the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffReader.Exif">
            <summary>Gets EXIF data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection obtained from the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffReader.FirstExtraChannelIsAlpha" draft="yes">
            <summary>Gets/sets a value indicating whether the reader should interpret the first extra channel as alpha channel in pixel data.</summary>
            <value><b>true</b> if the reader interprets the first extra channel as alpha; otherwise, <b>false</b>.</value>
            <remarks><para>For example, assume you read an image contained three color channels (RGB) and two extra ones. If this property is <b>true</b>, the image loaded from frame using <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.GetBitmap(Aurigma.GraphicsMill.Bitmap)">Frame.GetBitmap(Bitmap)</see> method will be interpreted as ARGB (RGB + alpha). <see cref="P:Aurigma.GraphicsMill.Codecs.TiffFrame.ExtraChannels">TiffFrame.ExtraChannels</see> collection will contain one extra channel in this case. Otherwise, if the 
<see cref="P:Aurigma.GraphicsMill.Codecs.TiffReader.FirstExtraChannelIsAlpha" /> property is <b>false</b>, 
it will be interpreted as RGB with two extra channels.</para><para>Default value is <b>true</b>.</para></remarks>
            <seealso href="WorkingwithTIFFExtraChannels.htm" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffReader.Iptc">
            <summary>Gets IPTC data collection from file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains IPTC data collection obtained from the file.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffReader.OnOpen">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffReader.Xmp" draft="yes">
            <summary>Gets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata of the opened file.</value>
            <remarks><para>To get specific values of the XMP fields, you can either use the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or parse this XML manually according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.TiffWriter" draft="yes">
            <summary>This class enables you to write TIFF images.</summary>
            <remarks><para>
TIFF format is one of the most comprehensive image formats. It was designed to promote the interchange of digital image data. The general scenario TIFF format was invented for, assumes that scanning or painting software creates a TIFF file, which can then be read and incorporated into a document or publication by an application such as a desktop publishing package. It is also widely used to retrieve facsimile messages.
</para><para>
  This image format is rather versatile and have a lot of modifications. It supports most Graphics Mill for .NET pixel formats even such exotic ones like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format80bppAcmyk" />. It also can store multiple images in the single file (mostly used for fax images and other documents stored as 1-bit bitmaps).
</para><para>TIFF files can also contain Adobe resources, XMP, EXIF and IPTC data.</para></remarks>
            <example><para>You can use <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instead of the <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method of the <see cref="T:Aurigma.GraphicsMill.Bitmap" />. In particular it enables you to save the image asynchronously.</para><para>The <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class usage is demonstrated below:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFAsync"></code><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffWriter.AdobeResources" draft="yes">
            <summary>Gets/sets Adobe image resource blocks you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.AdobeResourceDictionary" /> class instance that contains Adobe image resource blocks you want to write into the file.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffWriter.AlphaPremultiplied" draft="yes">
            <summary>Gets/sets the value which determines whether to premultiply image with alpha channel during image encoding or not.</summary>
            <value>The value which determines whether to premultiply color channels of each pixel with corresponding alpha channel during image encoding or not.</value>
            <remarks><para>The value of this property has meaning only when saving image with alpha channel.
</para><para>TIFF specification defines two ways of alpha channel encoding. 
<list type="bullet"><item>The first is so called "unassociated alpha" - when content of the alpha channel is simply stored along with color channels of the image. This is default behaviour.</item><item>The second way is to store image with "associated" alpha channel. This way implies that not only alpha channel itself will be encoded into the file, but also color channels of each pixel will be premultiplied with the corresponding alpha channel value.</item></list></para><para>
You should use TIFF files with associated alpha if you have software which gain some benefit from them (for example, unassociated alpha channel will be shown as separate channel in Adobe Photoshop, while image with associated alpha will be shown as image with transparency). But you should take into account that premultiplying process slows down encoding and introduces rounding error. So you should not set this property to <b>true</b> without reason.
</para><para>
  There is no difference for you between files with "associated" and "unassociated" alpha if you process them with Graphics Mill for .NET. <see cref="T:Aurigma.GraphicsMill.Codecs.TiffReader" /> class implementation takes into account this option during image decoding and performs demultiplication if necessary. So you will always get usual <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object with "unassociated" alpha. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.Clone" draft="yes">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" />).</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffWriter.Exif" draft="yes">
            <summary>Gets/sets EXIF data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.ExifDictionary" /> class instance that contains EXIF data collection you want to write into the file.</value>
            <example><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataAsync"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.TiffFrame" /> class instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffWriter.Iptc">
            <summary>Gets/sets IPTC data collection you want to write into the file.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.IptcDictionary" /> class instance that contains IPTC data collection you want to write into the file.</value>
            <example><para>TIFF files can store EXIF and IPTC data blocks. Graphics Mill for .NET allows you extracting this data from the TIFF file and save it into another TIFF file (as well as into the other file format which supports EXIF and IPTC). This code sample demonstrates how to add the EXIF and IPTC data to the file:</para><code language="VB" source="FileFormatsVB/form1.vb#TIFFMetadataAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#TIFFMetadataAsync"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.TiffWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.OnBeforeAddFrame(Aurigma.GraphicsMill.Codecs.IFrame)" draft="yes">
            <summary>Called before the frame is added to the stream.</summary>
            <param name="frame">The frame which is being added.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.OnClose">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.OnExportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Exports encoder options.</summary>
            <param name="options">Encoder options object to get writer settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.TiffWriter.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Imports encoder options.</summary>
            <param name="options">Encoder options object which should be filled with writer settings.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.TiffWriter.Xmp" draft="yes">
            <summary>Gets/sets the XML code containing the XMP metadata.</summary>
            <value>XML code containing the XMP metadata.</value>
            <remarks><para>To modify the XMP data, you can use either the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class or standard .NET XML-processing means according to the <see href="http://partners.adobe.com/public/developer/en/xmp/sdk/XMPspecification.pdf">XMP specification</see>.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.WbmpEncoderOptions">
            <summary>This class represents WBMP format encoder options. Currently no WBMP encoder options are available.</summary>
            <remarks>You can use this class to specify WBMP file format by retrieving it into <see cref="M:Aurigma.GraphicsMill.Bitmap.Save(System.String,Aurigma.GraphicsMill.Codecs.IEncoderOptions)" /> method.</remarks>
            <example><para>This sample demonstrates how to convert a JPEG image into the WBMP. Draw attention, to be able to save to the WBMP format, we need to reduce colors to 1-bit color depth first.</para><code language="VB" source="FileFormatsVB/form1.vb#WBMPSync"></code><code language="CS" source="FileFormatsCS/form1.cs#WBMPSync"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpEncoderOptions.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpEncoderOptions" /> class instance.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpEncoderOptions.ToFrame">
            <summary>Creates and initalizes <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> class instance with these encoder options.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> initialized with parameters of these encoder options.</returns>
            <remarks>The frame returned with this method does not contain bitmap. So before retrieving it into <see cref="T:Aurigma.GraphicsMill.Codecs.FormatWriter" /> object, you should pass necessary bitmap into this frame.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.WbmpFrame">
            <summary>This class represents a frame of the WBMP format.</summary>
            <example><para>This sample demonstrates how to convert a JPEG image into the WBMP. Draw attention, to be able to save to the WBMP format, we need to reduce colors to 1-bit color depth first.</para><code language="VB" source="FileFormatsVB/form1.vb#WBMPAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#WBMPAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpFrame.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpFrame.CreateEmptyEncoderOptions">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpFrame.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpFrame" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpFrame" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpFrame.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpFrame" /> class instance. You can associate a bitmap with this frame here.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which should be associated with this frame. To put another bitmap into frame, you should use <see cref="M:Aurigma.GraphicsMill.Codecs.Frame.SetBitmap(Aurigma.GraphicsMill.Bitmap)" /> method.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpFrame.OnImportEncoderOptions(Aurigma.GraphicsMill.Codecs.IEncoderOptions)" draft="yes">
            <summary>Import encoder options.</summary>
            <param name="options">Encoder options object which should be filled with frame settings.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.WbmpReader">
            <summary>This class enables you to read WBMP images.</summary>
            <remarks>WBMP file format is defined in WAP (Wireless Application Protocol) specification and designed for use with applications that operate over wireless communication networks. It is one of the first standard image formats supported by cellular phones. This format is extremely simple: WBMP file can contain only one 1-bit (black-and-white) image.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" /> class instance.</summary>
            <returns>An object which contains full copy of this reader (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.#ctor" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" /> class instance. It also opens this reader on specified file.</summary>
            <param name="fileName">Name of the file to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpReader" /> class instance. It also opens this reader on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the reader on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.OnCheckForSupport(System.IO.Stream)" draft="yes">
            <summary>Checks if the codec can read the specified file.</summary>
            <param name="stream">The stream that contains the file to test.</param>
            <returns><b>true</b>, if the stream can be read by the codec, otherwise <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpReader.OnFrameLoad(System.Int32)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.WbmpWriter">
            <summary>This class enables you to write WBMP images.</summary>
            <remarks><para>WBMP file format is defined in WAP (Wireless Application Protocol) specification and designed for use with applications that operate over wireless communication networks. It is one of the first standard image formats supported by cellular phones. This format is extremely simple: WBMP file can contain only one 1-bit (black-and-white) image.</para></remarks>
            <example><para>This sample demonstrates how to convert a JPEG image into the WBMP. Draw attention, to be able to save to the WBMP format, we need to reduce colors to 1-bit color depth first.</para><code language="VB" source="FileFormatsVB/form1.vb#WBMPAsync"></code><code language="CS" source="FileFormatsCS/form1.cs#WBMPAsync"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" /> class instance.</summary>
            <returns>An object which contains full copy of this writer (actually it has type <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" />).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.GetEmptyFrame">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Codecs.Frame" /> descendant class of the format supported with this writer. Actually it is <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpFrame" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.#ctor(System.String)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" /> class instance. It also opens this writer on specified file.</summary>
            <param name="fileName">Name of the file to open the writer on.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.WbmpWriter.#ctor(System.IO.Stream)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Codecs.WbmpWriter" /> class instance. It also opens this writer on specified stream.</summary>
            <param name="stream"><see cref="T:System.IO.Stream" /> to open the writer on.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode">
            <summary>A class representing an XMP array.</summary>
            <remarks><para>You can use this class for all types of XMP arrays: ordered, unordered, and alternative.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Add(System.Object)">
            <summary>Adds an item to the array.</summary>
            <param name="node">The object to be added.</param>
            <returns>The position into which the new element was inserted.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Clear">
            <summary>Sets all elements in the array to zero, to <b>false</b>, or to a null reference (<b>Nothing</b> in Visual Basic), depending on the element type.</summary>
            <remarks><para>Reference-type elements are set to a null reference (<b>Nothing</b> in Visual Basic). Boolean-type elements are set to <b>false</b>. Other value-type elements are set to zero.</para><para>This method only clears the values of the elements; it does not delete the elements themselves.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Contains(System.Object)">
            <summary>Determines whether an element is in the array.</summary>
            <param name="node">The object to locate in the array. The element to locate can be a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns><b>true</b> if value is found in the array; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.CopyTo(System.Array,System.Int32)">
            <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 32-bit integer that represents the index in array at which copying begins.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Count">
            <summary>Gets the number of elements contained in the collection.</summary>
            <value>Number of elements contained in the collection.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for the palette entries allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.IndexOf(System.Object)">
            <summary>Searches for the specified object and returns the index of the first occurrence within the current one-dimensional instance.</summary>
            <param name="value">Object to locate in the current array.</param>
            <returns>Index of the first occurrence of value within the entire array, if found; otherwise, the lower bound of the array minus 1.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Insert(System.Int32,System.Object)">
            <summary>Inserts an item to the array at the specified position.</summary>
            <param name="index">Zero-based index at which value should be inserted.</param>
            <param name="node">Object to insert.</param>
            <remarks><para>If <paramref name="index" /> equals the number of items in the array, then value is appended to the end.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.IsFixedSize">
            <summary>Gets a value indicating whether the array has a fixed size.</summary>
            <value>Always <b>true</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.IsReadOnly">
            <summary>Gets a value indicating whether the array is read-only.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.IsSynchronized">
            <summary>Gets a value indicating whether access to the array is synchronized (thread-safe).</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Item(System.Int32)">
            <summary>Gets/sets the element at the specified index.</summary>
            <param name="index">Zero-based index of the element to get or set.</param>
            <value>Element at the specified index.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNodeType,Aurigma.GraphicsMill.Codecs.XmpNamespace,System.String)" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> instance in a specified namespace.</summary>
            <param name="nodeType">Type of a new node. It is used to specify the kind of the array.</param>
            <param name="ns">Namespace to which the new node belongs.</param>
            <param name="name">Name of the node.</param>
            <overloads><summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNodeType,System.String)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> instance.</summary>
            <param name="nodeType">Type of a new node. It is used to specify the kind of the array.</param>
            <param name="name">Name of the node.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.Remove(System.Object)">
            <summary>Removes the first occurrence of a specific object from the array.</summary>
            <param name="node">Object to remove.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpArrayNode.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index.</summary>
            <param name="index">Zero-based index of the item to remove.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpArrayNode.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access is not implemented).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpData" draft="yes">
            <summary>This class represents an XMP tree.</summary>
            <remarks><para>This class can be used for two purposes: </para><list type="number"><item><description>Parse XMP data and extract the specific fields values (nodes).</description></item><item><description>Build or modify existing XMP tree by adding/removing/editing nodes.</description></item></list><para>XMP is an XML-based tree-like format of metadata storage. This class allows to load XML containing XMP data (with a constructor or the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpData.Load(System.String)" /> method). After the XMP string is loaded, a hierarchical set of nodes is formed. You can iterate each node in the <see cref="P:Aurigma.GraphicsMill.Codecs.XmpData.Values" /> collection and drill down into its children to get information about some specific node. </para><para>To add nodes to this tree, use the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpData.AddNode(Aurigma.GraphicsMill.Codecs.XmpNode)" /> method. Any object that is a descendant of the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> class can be added to the tree. Items are removed with the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Remove(System.Object)" /> method. After you build a tree of XMP fields, you can get it as an XML string which can be passed to any writer object that supports XMP data (JPEG, TIFF).</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Add(System.Object,System.Object)">
            <summary>Adds a node to the top of the XMP tree.</summary>
            <param name="name">Qualified XMP node name.</param>
            <param name="node"><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> descendant.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.AddNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Adds a node to the XMP tree.</summary>
            <param name="node"><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> descendant.</param>
            <remarks><para>This method is more convenient than the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpData.Add(System.Object,System.Object)" /> method.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Clear">
            <summary>Sets all elements in the array to zero, to <b>false</b>, or to a null reference (<b>Nothing</b> in Visual Basic), depending on the element type.</summary>
            <remarks><para>Reference-type elements are set to a null reference (<b>Nothing</b> in Visual Basic). Boolean-type elements are set to <b>false</b>. Other value-type elements are set to zero.</para><para>This method only clears the values of the elements; it does not delete the elements themselves.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Contains(System.Object)">
            <summary>Determines whether a node is in the tree.</summary>
            <param name="name">Node to locate in the tree. The node to locate can be a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns><b>true</b> if value is found in the tree; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.CopyTo(System.Array,System.Int32)">
            <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 32-bit integer that represents the index in array at which copying begins.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.Count">
            <summary>Gets the number of nodes contained in the tree.</summary>
            <value>Number of nodes contained in the tree.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.FindKeysByNamespace(Aurigma.GraphicsMill.Codecs.XmpNamespace)">
            <summary>Finds tags which belong to the provided namespace on the top level of the current tree.</summary>
            <param name="ns">Namspace for which the tags should be returned.</param>
            <returns>Array of tag which belong to the provided namespace.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.IDictionary.GetEnumerator">
            <summary>Returns an enumerator for the tree nodes.</summary>
            <returns>Enumerator that implements the <see cref="T:System.Collections.IDictionaryEnumerator" /> interface.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for the tree nodes allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements the <see cref="T:System.Collections.IEnumerator" /> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.IsFixedSize">
            <summary>Indicates whether the tree has a fixed size.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.IsReadOnly">
            <summary>Indicates whether the tree is a read-only.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.IsSynchronized">
            <summary>Indicates whether the tree is synchronized.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.Item(System.Object)">
            <summary>Gets/sets a value for the specified tag.</summary>
            <param name="name">Tag for the value to get or set.</param>
            <value>Value to get or set.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.Keys">
            <summary>Returns a collection of tags stored in this tree.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains tags stored in this tree.</value>
            <remarks><para>Tag names are returned as strings.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Load(System.String)">
            <summary>Creates an XMP tree based on the provided XML code.</summary>
            <param name="xmp"><see cref="T:System.String" /> that contains XML code with the XMP data.</param>
            <remarks><para>Typically you get the string with XMP data from a JPEG or TIFF reader class. After that you pass this string to this method. As soon as XMP data is loaded to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> class, you can easily get specific fields value.</para><para>If you edit XMP data (add, remove, or modify nodes) and want to save it back, use the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpData.Save" /> method. It will return the XML string which you will be able to pass to the <b>Xmp</b> property of an appropriate writer.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.Namespaces">
            <summary>Returns a collection of namespaces stored in this tree.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> instances stored in this tree.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.#ctor">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> instance.</summary>
            <overloads><summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.#ctor(System.String)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> instance based on the passed XML code.</summary>
            <param name="xmp">XML code containing the XMP data.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Remove(System.Object)">
            <summary>Removes the first occurrence of a specific node from the tree.</summary>
            <param name="name">Tag name to remove.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.Save">
            <summary>Returns an XML code corresponding to the tree of XMP fields stored in this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpData" /> object.</summary>
            <returns><see cref="T:System.String" /> containing the XML code corresponding to the XMP data stored in this class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpData.SetNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Sets a new value for the specified tag.</summary>
            <param name="node">Node containing a new value.</param>
            <remarks><para>This method reads a tag name from the provided <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> and inserts it into the tree instead of the node with the same tag name.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access is not implemented).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpData.Values">
            <summary>Returns a collection of nodes stored in this tree.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> instances stored in this tree.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode">
            <summary>This is an abstract class that allows to access a node as a dictionary.</summary>
            <remarks><para>Several classes that are not arrays but can contain qualifiers inherit from this class.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Add(System.Object,System.Object)">
            <summary>Adds one item with the specified key.</summary>
            <param name="key">Key of the object to add.</param>
            <param name="value">An item to add into the dictionary.</param>
            <remarks><para>If item (or several items) are already stored at specified key, this method fails. To check whether the item with such key exists, use the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Contains(System.Object)" /> method.</para><para>An alternative way to add new entries into the dictionary is to use the <see cref="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Item(System.Object)" /> method. Unlike the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Add(System.Object,System.Object)" /> method, if the key is found in the dictionary, new item overwrites the old value. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.AddNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Adds a node to the dictionary.</summary>
            <param name="node"><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> descendant.</param>
            <remarks><para>This method is more convenient than the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Add(System.Object,System.Object)" /> method.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Clear">
            <summary>Sets all elements in the dictionary to zero, to <b>false</b>, or to a null reference (<b>Nothing</b> in Visual Basic), depending on the element type.</summary>
            <remarks><para>Reference-type elements are set to a null reference (<b>Nothing</b> in Visual Basic). Boolean-type elements are set to <b>false</b>. Other value-type elements are set to zero.</para><para>This method only clears the values of the elements; it does not delete the elements themselves.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Contains(System.Object)">
            <summary>Determines whether a node is in the dictionary.</summary>
            <param name="key">Node to locate in the dictionary. The node to locate can be a null reference (<b>Nothing</b> in Visual Basic).</param>
            <returns><b>true</b> if value is found in the tree; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.CopyTo(System.Array,System.Int32)">
            <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 32-bit integer that represents the index in array at which copying begins.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Count">
            <summary>Gets the number of nodes contained in the dictionary.</summary>
            <value>Number of nodes contained in the dictionary.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.FindKeysByNamespace(Aurigma.GraphicsMill.Codecs.XmpNamespace)">
            <summary>Finds tags belonging to the provided namespace in the current dictionary.</summary>
            <param name="ns">Namspace for which the tags should be returned.</param>
            <returns>Array of tags belonging to the provided namespace.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.IDictionary.GetEnumerator">
            <summary>Returns an enumerator for the dictionary items.</summary>
            <returns>Enumerator that implements the <see cref="T:System.Collections.IDictionaryEnumerator">System.Collections.IDictionaryEnumerator</see> interface.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for the dictionary items allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements the <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.IsFixedSize">
            <summary>Indicates whether the dictionary has a fixed size.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.IsReadOnly">
            <summary>Indicates whether the dictionary is a read-only.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.IsSynchronized">
            <summary>Indicates whether the dictionary is synchronized.</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Item(System.Object)">
            <summary>Gets/sets a value for the specified key.</summary>
            <param name="key">Key for the value to get or set.</param>
            <value>Value to get or set.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Keys">
            <summary>Returns a collection of keys stored in this dictionary.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains keys stored in this dictionary.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Namespaces">
            <summary>Returns a collection of namespaces stored in this dictionary.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> instances representing namespaces of all XMP fields stored in this dictionary.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.#ctor">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode" /> instance.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Remove(System.Object)">
            <summary>Removes the first occurrence of a specific node from the dictionary.</summary>
            <param name="key">Key of the object to remove.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.SetNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Sets a new value for the specified key.</summary>
            <param name="node">Node containing a new value.</param>
            <remarks><para>This method reads a key (tag name) from the provided <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> and inserts it into the dictionary instead of the node with the same tag name.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access is not implemented).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpDictionaryNode.Values">
            <summary>Returns a collection of values stored in this dictionary.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains values stored in this dictionary.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode">
            <summary>This class represents a localized text item node.</summary>
            <remarks><para>Nodes of this type are used to describe text items contain in <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode" />.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.CopyTo(System.Array,System.Int32)">
            <summary>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the current array.</param>
            <param name="index">A 32-bit integer that represents the index in array at which copying begins.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.Count">
            <summary>Gets the number of elements contained in the collection.</summary>
            <value>Number of elements contained in the collection.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for the palette entries allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.IsSynchronized">
            <summary>Gets a value indicating whether access to the array is synchronized (thread-safe).</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.Namespace">
            <summary>Returns a namespaces to which this item belongs.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> class instance which represents the namespace this item belongs to.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.#ctor(System.String,System.String)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> instance.</summary>
            <param name="name">Qualified XMP node name.</param>
            <param name="text">Localized text.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access is not implemented).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.ToString">
            <summary>Returns a string representation of this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> instance.</summary>
            <returns>Value containing a string representation of this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode.Value">
            <summary>Gets a value stored in this item.</summary>
            <value>Text that is stored in this node.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode">
            <summary>This class represents a localized text node.</summary>
            <remarks><para>Nodes of this type contain languages identifier, specifying the language in which the text is provided.</para><para>Nodes of this type are described by items of the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> type.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Add(System.Object,System.Object)">
            <summary>Adds one item with the specified key.</summary>
            <param name="key">Key of the object to add.</param>
            <param name="value">An <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> to add into the dictionary.</param>
            <remarks><para>An alternative way to add new entries into the dictionary is to use the <see cref="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Item(System.Object)" /> method. Unlike the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Add(System.Object,System.Object)" /> method, if the key is found in the dictionary, new item overwrites the old value. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.AddNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Adds a node to the collection.</summary>
            <param name="node"><see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> instance with the required text.</param>
            <remarks><para>This method is more convenient than the <see cref="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Add(System.Object,System.Object)" /> method.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.FindKeysByNamespace(Aurigma.GraphicsMill.Codecs.XmpNamespace)">
            <summary>Finds tags belonging to the provided namespace in the current collection.</summary>
            <param name="ns">Namspace for which the tags should be returned.</param>
            <returns>Array of tags belonging to the provided namespace.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Item(System.Object)">
            <summary>Gets/sets the element with the specified key.</summary>
            <param name="key">Key of the element to get or set.</param>
            <value>Element with the specified key.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.Namespaces">
            <summary>Returns a collection of namespaces stored in this dictionary.</summary>
            <value>Object that implements the <see cref="T:System.Collections.ICollection" /> interface and contains <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> instances representing namespaces of all XMP fields stored in this dictionary.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNamespace,System.String)" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode" /> instance using a specified namespace.</summary>
            <param name="ns">Namespace to which the new node belongs.</param>
            <param name="name">Name of the node.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.#ctor(System.String)" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode" /> instance.</summary>
            <param name="name">Name of the node.</param>
            <overloads><summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode.SetNode(Aurigma.GraphicsMill.Codecs.XmpNode)">
            <summary>Sets a new value for the specified tag.</summary>
            <param name="node">Node containing a new value.</param>
            <remarks><para>This method reads a tag name from the provided <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> and inserts it into the dictionary instead of the node with the same tag name.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpNamespace">
            <summary>This class represents an XMP namespace.</summary>
            <remarks><para>This class also contains a static collection of all namespaces used for the XMP docrument.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNamespace.AddNamespace(System.String,System.String)">
            <summary>Adds a namespace to the collection of namespaces.</summary>
            <param name="uri">Namespace URI.</param>
            <param name="prefix">Namespace prefix.</param>
            <returns>Namespace added to the collection.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNamespace.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNamespace.GetNamespaceByIndex(System.Int32)">
            <summary>Returns a namespace with the specified index.</summary>
            <param name="index">Index for which the namespace should be retrieved.</param>
            <returns>Namespace with the specified index.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNamespace.GetNamespaceByPrefix(System.String)">
            <summary>Returns a namespace with the specified prefix.</summary>
            <param name="prefix">Prefix of the namespace.</param>
            <returns>Namespace with the specified prefix.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNamespace.GetNamespaceByUri(System.String)">
            <summary>Returns a namespace with the specified URI.</summary>
            <param name="uri">URI of the namespace.</param>
            <returns>Namespace with the specified URI.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNamespace.NamespaceCount">
            <summary>Gets the number of namespaces stored in the static collection.</summary>
            <value>Total number of namespaces stored in the static collection.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNamespace.Prefix">
            <summary>Prefix of this particular <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> instance.</summary>
            <value>Namespace prefix.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNamespace.Uri">
            <summary>URI of this particular <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> instance.</summary>
            <value>Namespace URI.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpNode">
            <summary>This abstract class represents a single XMP property.</summary>
            <remarks><para>This is a generic representation of an XMP node.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.Count">
            <summary>Gets the number of elements contained in the collection.</summary>
            <value>Number of elements contained in the collection.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNode.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> with the specified object.</summary>
            <param name="other"><see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> instance. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" />, an exception will be raised.</param>
            <returns>Value specifying if the given object represents the same node as the current <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNode.IEnumerable.GetEnumerator">
            <summary>Returns an enumerator for the palette entries allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.IsSynchronized">
            <summary>Gets a value indicating whether access to the array is synchronized (thread-safe).</summary>
            <value>Always <b>false</b>.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.Name">
            <summary>Gets a qualified XMP node name.</summary>
            <value>Qualified XMP node name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.Namespace">
            <summary>Gets a namespace to which the node belongs.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNamespace" /> class instance which represents the namespace this item belongs to.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpNode.#ctor">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpNode" /> instance.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.NodeType">
            <summary>Gets an XMP type of the node.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Codecs.XmpNodeType" /> enumeration member that specifies the XMP node type.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpNode.SyncRoot">
            <summary>Gets an object for synchronized access.</summary>
            <value>Always returns <b>null</b> (synchronized access is not implemented).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpNodeType">
            <summary>Contains available XMP node types.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.AlternativeArray">
            <summary>An alternative array is a set of one or more values, one of which should be chosen. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.LocalizedText">
            <summary>A collection of localized text values. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.LocalizedTextItem">
            <summary>A single localized text value. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpLocalizedTextItemNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.OrderedArray">
            <summary>An ordered array is a list whose order is significant. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.Qualifier">
            <summary>Property qualifier. Any individual property value may have other properties attached to it; these attached properties are called property qualifiers. They are in effect "properties of properties." Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.SimpleProperty">
            <summary>A simple type has a single literal value. Simple types include familiar ones such as strings, booleans, integers and so on. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.Structure">
            <summary>A structured property consists of one or more named fields. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpStructNode" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Codecs.XmpNodeType.UnorderedArray">
            <summary>An unordered array is a list of values whose order does not have significance. Corresponds to the <see cref="T:Aurigma.GraphicsMill.Codecs.XmpArrayNode" /> class.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpStructNode">
            <summary>This class represents an XMP structured property.</summary>
            <remarks><para>A structured property consists of one or more named fields. A field in a structure can itself be a structure or an array.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpStructNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpStructNode.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpStructNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNamespace,System.String)" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpStructNode" /> instance using a specified namespace.</summary>
            <param name="ns">Namespace to which the new node belongs.</param>
            <param name="name">Name of the node.</param>
            <overloads><summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpStructNode" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpStructNode.#ctor(System.String)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpStructNode" /> instance.</summary>
            <param name="name">Name of the node.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpTagNames">
            <summary>This class can be used as an enumeration of standard XMP tags.</summary>
            <remarks><para>When constructing an XMP tree you may use this class members as enumeration values if you need to write standard tags but do not want to write tag names manually (which is error-prone).</para><para>The property values returned by this class already contain a namespace prefix.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.AuxLens">
            <summary>Gets the aux:Lens tag.</summary>
            <value>aux:Lens tag.</value>
            <remarks><para>Lens information. Belongs to the EXIF schema for additional EXIF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.AuxSerialNumber">
            <summary>Gets the aux:SerialNumber tag.</summary>
            <value>aux:SerialNumber tag.</value>
            <remarks><para>Serial number. Belongs to the EXIF schema for additional EXIF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsAutoBrightness">
            <summary>Gets the crs:AutoBrightness tag.</summary>
            <value>crs:AutoBrightness tag.</value>
            <remarks><para>A value indicating if "Brightness" is adjusted automatically. Belongs to the Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsAutoContrast">
            <summary>Gets the crs:AutoContrast tag.</summary>
            <value>crs:AutoContrast tag.</value>
            <remarks><para>A value indicating if "Contrast" is adjusted automatically. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsAutoExposure">
            <summary>Gets the crs:AutoExposure tag.</summary>
            <value>crs:AutoExposure tag.</value>
            <remarks><para>A value indicating if "Exposure" is adjusted automatically. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsAutoShadows">
            <summary>Gets the crs:AutoShadows tag.</summary>
            <value>crs:AutoShadows tag.</value>
            <remarks><para>A value indicating if "Shadows" is adjusted automatically. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsBlueHue">
            <summary>Gets the crs:BlueHue tag.</summary>
            <value>crs:BlueHue tag.</value>
            <remarks><para>"Blue Hue" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsBlueSaturation">
            <summary>Gets the crs:BlueSaturation tag.</summary>
            <value>crs:BlueSaturation tag.</value>
            <remarks><para>"Blue Saturation" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsBrightness">
            <summary>Gets the crs:Brightness tag.</summary>
            <value>crs:Brightness tag.</value>
            <remarks><para>"Brightness" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCameraProfile">
            <summary>Gets the crs:CameraProfile tag.</summary>
            <value>crs:CameraProfile tag.</value>
            <remarks><para>"Camera Profile" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsChromaticAberrationB">
            <summary>Gets the crs:ChromaticAberration tag.</summary>
            <value>crs:ChromaticAberration tag.</value>
            <remarks><para>"Chromatic Aberration, Fix Blue/Yellow Fringe" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsChromaticAberrationR">
            <summary>Gets the crs:ChromaticAberration tag.</summary>
            <value>crs:ChromaticAberration tag.</value>
            <remarks><para>"Chromatic Aberration, Fix Red/Cyan Fringe" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsColorNoiseReduction">
            <summary>Gets the crs:ColorNoiseReducton tag.</summary>
            <value>crs:ColorNoiseReducton tag.</value>
            <remarks><para>"Color Noise Reducton" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsContrast">
            <summary>Gets the crs:Contrast tag.</summary>
            <value>crs:Contrast tag.</value>
            <remarks><para>"Contrast" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropAngle">
            <summary>Gets the crs:CropAngle tag.</summary>
            <value>crs:CropAngle tag.</value>
            <remarks><para>Angle of crop rectangle. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropBottom">
            <summary>Gets the crs:CropBottom tag.</summary>
            <value>crs:CropBottom tag.</value>
            <remarks><para>Bottom of crop rectangle. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropHeight">
            <summary>Gets the crs:CropHeight tag.</summary>
            <value>crs:CropHeight tag.</value>
            <remarks><para>Height of resulting cropped image. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropLeft">
            <summary>Gets the crs:CropLeft tag.</summary>
            <value>crs:CropLeft tag.</value>
            <remarks><para>Left of crop rectangle. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropRight">
            <summary>Gets the crs:CropRight tag.</summary>
            <value>crs:CropRight tag.</value>
            <remarks><para>Right of crop rectangle. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropTop">
            <summary>Gets the crs:CropTop tag.</summary>
            <value>crs:CropTop tag.</value>
            <remarks><para>Top of crop rectangle. Belongs to the Photoshop Camera Raw schemaCrop.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropUnits">
            <summary>Gets the crs:CropUnits tag.</summary>
            <value>crs:CropUnits tag.</value>
            <remarks><para>Units for <see cref="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropWidth" /> and <see cref="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropHeight" />. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsCropWidth">
            <summary>Gets the crs:CropWidth tag.</summary>
            <value>crs:CropWidth tag.</value>
            <remarks><para>Width of resulting cropped image. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsExposure">
            <summary>Gets the crs:Exposure tag.</summary>
            <value>crs:Exposure tag.</value>
            <remarks><para>"Exposure" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsGreenHue">
            <summary>Gets the crs:GreenHue tag.</summary>
            <value>crs:GreenHue tag.</value>
            <remarks><para>"Green Hue" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsGreenSaturation">
            <summary>Gets the crs:GreenSaturation tag.</summary>
            <value>crs:GreenSaturation tag.</value>
            <remarks><para>"Green Saturation" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsHasCrop">
            <summary>Gets the crs:HasCrop tag.</summary>
            <value>crs:HasCrop tag.</value>
            <remarks><para>A value indicating if the image has a cropping rectangle. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsHasSettings">
            <summary>Gets the crs:HasSettings tag.</summary>
            <value>crs:HasSettings tag.</value>
            <remarks><para>A value indicating if non-default camera raw settings are used. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsLuminanceSmoothing">
            <summary>Gets the crs:LuminanceSmoothing tag.</summary>
            <value>crs:LuminanceSmoothing tag.</value>
            <remarks><para>"Luminance Smoothing" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsRawFileName">
            <summary>Gets the crs:RawFileName tag.</summary>
            <value>crs:RawFileName tag.</value>
            <remarks><para>A file name fo the raw file. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsRedHue">
            <summary>Gets the crs:RedHue tag.</summary>
            <value>crs:RedHue tag.</value>
            <remarks><para>"Red Hue" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsRedSaturation">
            <summary>Gets the crs:RedSaturation tag.</summary>
            <value>crs:RedSaturation tag.</value>
            <remarks><para>"Red Saturation" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsSaturation">
            <summary>Gets the crs:Saturation tag.</summary>
            <value>crs:Saturation tag.</value>
            <remarks><para>"Saturation" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsShadows">
            <summary>Gets the crs:Shadows tag.</summary>
            <value>crs:Shadows tag.</value>
            <remarks><para>"Shadows" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsShadowTint">
            <summary>Gets the crs:ShadowTint tag.</summary>
            <value>crs:ShadowTint tag.</value>
            <remarks><para>"Shadow Tint" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsSharpness">
            <summary>Gets the crs:Sharpness tag.</summary>
            <value>crs:Sharpness tag.</value>
            <remarks><para>"Sharpness" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsTemperature">
            <summary>Gets the crs:Temperature tag.</summary>
            <value>crs:Temperature tag.</value>
            <remarks><para>"Temperature" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsTint">
            <summary>Gets the crs:Tint tag.</summary>
            <value>crs:Tint tag.</value>
            <remarks><para>"Tint" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsToneCurve">
            <summary>Gets the crs:ToneCurve tag.</summary>
            <value>crs:ToneCurve tag.</value>
            <remarks><para>Tone curve. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsToneCurveName">
            <summary>Gets the crs:ToneCurveName tag.</summary>
            <value>crs:ToneCurveName tag.</value>
            <remarks><para>A name of the tone curve. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsVersion">
            <summary>Gets the crs:Version tag.</summary>
            <value>crs:Version tag.</value>
            <remarks><para>Version of a Camera Raw plugin. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsVignetteAmount">
            <summary>Gets the crs:VignettingAmount tag.</summary>
            <value>crs:VignettingAmount tag.</value>
            <remarks><para>"Vignetting Amount" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsVignetteMidpoint">
            <summary>Gets the crs:VignettingMidpoint tag.</summary>
            <value>crs:VignettingMidpoint tag.</value>
            <remarks><para>"Vignetting Midpoint" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.CrsWhiteBalance">
            <summary>Gets the crs:WhiteBalance tag.</summary>
            <value>crs:WhiteBalance tag.</value>
            <remarks><para>"White Balance" setting. Belongs to the Photoshop Camera Raw schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCContributor">
            <summary>Gets the dc:Contributor tag.</summary>
            <value>dc:Contributor tag.</value>
            <remarks><para>Contributors to the resource (other than the authors). Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCCoverage">
            <summary>Gets the dc:Coverage tag.</summary>
            <value>dc:Coverage tag.</value>
            <remarks><para>Extent or scope of the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCCreator">
            <summary>Gets the dc:Creator tag.</summary>
            <value>dc:Creator tag.</value>
            <remarks><para>Authors of the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCDate">
            <summary>Gets the dc:Date tag.</summary>
            <value>dc:Date tag.</value>
            <remarks><para>Date(s) that something interesting happened to the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCDescription">
            <summary>Gets the dc:Description tag.</summary>
            <value>dc:Description tag.</value>
            <remarks><para>Textual description of the content of the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCFormat">
            <summary>Gets the dc:Format tag.</summary>
            <value>dc:Format tag.</value>
            <remarks><para>A MIME type. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCIdentifier">
            <summary>Gets the dc:Identifier tag.</summary>
            <value>dc:Identifier tag.</value>
            <remarks><para>Unique identifier of the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCLanguage">
            <summary>Gets the dc:Language tag.</summary>
            <value>dc:Language tag.</value>
            <remarks><para>Languages used in the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCPublisher">
            <summary>Gets the dc:Publisher tag.</summary>
            <value>dc:Publisher tag.</value>
            <remarks><para>Publishers. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCRelation">
            <summary>Gets the dc:Relation tag.</summary>
            <value>dc:Relation tag.</value>
            <remarks><para>Relationships to other documents. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCRights">
            <summary>Gets the dc:Rights tag.</summary>
            <value>dc:Rights tag.</value>
            <remarks><para>Informal rights statement. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCSource">
            <summary>Gets the dc:Source tag.</summary>
            <value>dc:Source tag.</value>
            <remarks><para>Unique identifier of the work from which this resource was derived. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCSubject">
            <summary>Gets the dc:Subject tag.</summary>
            <value>dc:Subject tag.</value>
            <remarks><para>Topic of the content of the resource. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCTitle">
            <summary>Gets the dc:Title tag.</summary>
            <value>dc:Title tag.</value>
            <remarks><para>Title of the document. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.DCType">
            <summary>Gets the dc:Type tag.</summary>
            <value>dc:Type tag.</value>
            <remarks><para>Document type. Belongs to the Dublin Core schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifApertureValue">
            <summary>Gets the exif:ApertureValue tag.</summary>
            <value>exif:ApertureValue tag.</value>
            <remarks><para>EXIF tag 37378, 0x9202. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifBrightnessValue">
            <summary>Gets the exif:BrightnessValue tag.</summary>
            <value>exif:BrightnessValue tag.</value>
            <remarks><para>EXIF tag 37379, 0x9203. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifCFAPattern">
            <summary>Gets the exif:CFAPattern tag.</summary>
            <value>exif:CFAPattern tag.</value>
            <remarks><para>EXIF tag 41730, 0xA302. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifColorSpace">
            <summary>Gets the exif:ColorSpace tag.</summary>
            <value>exif:ColorSpace tag.</value>
            <remarks><para>EXIF tag 40961, 0xA001. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifComponentsConfiguration">
            <summary>Gets the exif:ComponentsConfiguration tag.</summary>
            <value>exif:ComponentsConfiguration tag.</value>
            <remarks><para>EXIF tag 37121, 0x9101. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifCompressedBitsPerPixel">
            <summary>Gets the exif:CompressedBitsPerPixel tag.</summary>
            <value>exif:CompressedBitsPerPixel tag.</value>
            <remarks><para>EXIF tag 37122, 0x9102. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifContrast">
            <summary>Gets the exif:Contrast tag.</summary>
            <value>exif:Contrast tag.</value>
            <remarks><para>EXIF tag 41992, 0xA408. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifCustomRendered">
            <summary>Gets the exif:CustomRendered tag.</summary>
            <value>exif:CustomRendered tag.</value>
            <remarks><para>EXIF tag 41985, 0xA401. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifDateTimeDigitized">
            <summary>Gets the exif:DateTimeDigitized tag.</summary>
            <value>exif:DateTimeDigitized tag.</value>
            <remarks><para>EXIF tag 36868, 0x9004 (primary) and 37522, 0x9292 (subseconds). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifDateTimeOriginal">
            <summary>Gets the exif:DateTimeOriginal tag.</summary>
            <value>exif:DateTimeOriginal tag.</value>
            <remarks><para>EXIF tag 36867, 0x9003 (primary) and 37521, 0x9291 (subseconds). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifDeviceSettingDescription">
            <summary>Gets the exif:DeviceSettingDescription tag.</summary>
            <value>exif:DeviceSettingDescription tag.</value>
            <remarks><para>EXIF tag 41995, 0xA40B. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifDigitalZoomRatio">
            <summary>Gets the exif:DigitalZoomRatio tag.</summary>
            <value>exif:DigitalZoomRatio tag.</value>
            <remarks><para>EXIF tag 41988, 0xA404. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExifVersion">
            <summary>Gets the exif:ExifVersion tag.</summary>
            <value>exif:ExifVersion tag.</value>
            <remarks><para>EXIF tag 36864, 0x9000. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExposureBiasValue">
            <summary>Gets the exif:ExposureBiasValue tag.</summary>
            <value>exif:ExposureBiasValue tag.</value>
            <remarks><para>EXIF tag 37380, 0x9204. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExposureIndex">
            <summary>Gets the exif:ExposureIndex tag.</summary>
            <value>exif:ExposureIndex tag.</value>
            <remarks><para>EXIF tag 41493, 0xA215. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExposureMode">
            <summary>Gets the exif:ExposureMode tag.</summary>
            <value>exif:ExposureMode tag.</value>
            <remarks><para>EXIF tag 41986, 0xA402. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExposureProgram">
            <summary>Gets the exif:ExposureProgram tag.</summary>
            <value>exif:ExposureProgram tag.</value>
            <remarks><para>EXIF tag 34850, 0x8822. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifExposureTime">
            <summary>Gets the exif:ExposureTime tag.</summary>
            <value>exif:ExposureTime tag.</value>
            <remarks><para>EXIF tag 33434, 0x829A. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFileSource">
            <summary>Gets the exif:FileSource tag.</summary>
            <value>exif:FileSource tag.</value>
            <remarks><para>EXIF tag 41728, 0xA300. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFlash">
            <summary>Gets the exif:Flash tag.</summary>
            <value>exif:Flash tag.</value>
            <remarks><para>EXIF tag 37385, 0x9209. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFlashEnergy">
            <summary>Gets the exif:FlashEnergy tag.</summary>
            <value>exif:FlashEnergy tag.</value>
            <remarks><para>EXIF tag 41483, 0xA20B. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFlashpixVersion">
            <summary>Gets the exif:FlashpixVersion tag.</summary>
            <value>exif:FlashpixVersion tag.</value>
            <remarks><para>EXIF tag 40960, 0xA000. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFNumber">
            <summary>Gets the exif:FNumber tag.</summary>
            <value>exif:FNumber tag.</value>
            <remarks><para>EXIF tag 33437, 0x829D. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFocalLength">
            <summary>Gets the exif:FocalLength tag.</summary>
            <value>exif:FocalLength tag.</value>
            <remarks><para>EXIF tag 37386, 0x920A. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFocalLengthIn35mmFilm">
            <summary>Gets the exif:FocalLengthIn35mmFilm tag.</summary>
            <value>exif:FocalLengthIn35mmFilm tag.</value>
            <remarks><para>EXIF tag 41989, 0xA405. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFocalPlaneResolutionUnit">
            <summary>Gets the exif:FocalPlaneResolutionUnit tag.</summary>
            <value>exif:FocalPlaneResolutionUnit tag.</value>
            <remarks><para>EXIF tag 41488, 0xA210. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFocalPlaneXResolution">
            <summary>Gets the exif:FocalPlaneXResolution tag.</summary>
            <value>exif:FocalPlaneXResolution tag.</value>
            <remarks><para>EXIF tag 41486, 0xA20E. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifFocalPlaneYResolution">
            <summary>Gets the exif:FocalPlaneYResolution tag.</summary>
            <value>exif:FocalPlaneYResolution tag.</value>
            <remarks><para>EXIF tag 41487, 0xA20F. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGainControl">
            <summary>Gets the exif:GainControl tag.</summary>
            <value>exif:GainControl tag.</value>
            <remarks><para>EXIF tag 41991, 0xA407. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsAltitude">
            <summary>Gets the exif:GpsAltitude tag.</summary>
            <value>exif:GpsAltitude tag.</value>
            <remarks><para>GPS tag 6, 0x06. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsAltitudeRef">
            <summary>Gets the exif:GpsAltitudeRef tag.</summary>
            <value>exif:GpsAltitudeRef tag.</value>
            <remarks><para>GPS tag 5, 0x5. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsAreaInformation">
            <summary>Gets the exif:GpsAreaInformation tag.</summary>
            <value>exif:GpsAreaInformation tag.</value>
            <remarks><para>GPS tag 28, 0x1C. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestBearing">
            <summary>Gets the exif:GpsDestBearing tag.</summary>
            <value>exif:GpsDestBearing tag.</value>
            <remarks><para>GPS tag 24, 0x18. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestBearingRef">
            <summary>Gets the exif:GpsDestBearingRef tag.</summary>
            <value>exif:GpsDestBearingRef tag.</value>
            <remarks><para>GPS tag 23, 0x17. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestDistance">
            <summary>Gets the exif:GpsDestDistance tag.</summary>
            <value>exif:GpsDestDistance tag.</value>
            <remarks><para>GPS tag 26, 0x1A. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestDistanceRef">
            <summary>Gets the exif:GpsDestDistanceRef tag.</summary>
            <value>exif:GpsDestDistanceRef tag.</value>
            <remarks><para>GPS tag 25, 0x19. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestLatitude">
            <summary>Gets the exif:GpsDestLatitude tag.</summary>
            <value>exif:GpsDestLatitude tag.</value>
            <remarks><para>GPS tag 20, 0x14 (position) and 19, 0x13 (North/South). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDestLongitude">
            <summary>Gets the exif:GpsDestLongitude tag.</summary>
            <value>exif:GpsDestLongitude tag.</value>
            <remarks><para>GPS tag 22, 0x16 (position) and 21, 0x15 (East/West). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDifferential">
            <summary>Gets the exif:GpsDifferential tag.</summary>
            <value>exif:GpsDifferential tag.</value>
            <remarks><para>GPS tag 30, 0x1E. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsDOP">
            <summary>Gets the exif:GpsDOP tag.</summary>
            <value>exif:GpsDOP tag.</value>
            <remarks><para>GPS tag 11, 0x0B. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsImgDirection">
            <summary>Gets the exif:GpsImgDirection tag.</summary>
            <value>exif:GpsImgDirection tag.</value>
            <remarks><para>GPS tag 17, 0x11. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsImgDirectionRef">
            <summary>Gets the exif:GpsImgDirectionRef tag.</summary>
            <value>exif:GpsImgDirectionRef tag.</value>
            <remarks><para>GPS tag 16, 0x10. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsLatitude">
            <summary>Gets the exif:GpsLatitude tag.</summary>
            <value>exif:GpsLatitude tag.</value>
            <remarks><para>GPS tag 2, 0x02 (position) and 1, 0x01 (North/South). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsLongitude">
            <summary>Gets the exif:GpsLongitude tag.</summary>
            <value>exif:GpsLongitude tag.</value>
            <remarks><para>GPS tag 4, 0x04 (position) and 3, 0x03 (East/West). Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsMapDatum">
            <summary>Gets the exif:GpsMapDatum tag.</summary>
            <value>exif:GpsMapDatum tag.</value>
            <remarks><para>GPS tag 18, 0x12. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsMeasureMode">
            <summary>Gets the exif:GpsMeasureMode tag.</summary>
            <value>exif:GpsMeasureMode tag.</value>
            <remarks><para>GPS tag 10, 0x0A. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsProcessingMethod">
            <summary>Gets the exif:GpsProcessingMethod tag.</summary>
            <value>exif:GpsProcessingMethod tag.</value>
            <remarks><para>GPS tag 27, 0x1B. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsSatellites">
            <summary>Gets the exif:GpsSatellites tag.</summary>
            <value>exif:GpsSatellites tag.</value>
            <remarks><para>GPS tag 8, 0x08. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsSpeed">
            <summary>Gets the exif:GpsSpeed tag.</summary>
            <value>exif:GpsSpeed tag.</value>
            <remarks><para>GPS tag 13, 0x0D. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsSpeedRef">
            <summary>Gets the exif:GpsSpeedRef tag.</summary>
            <value>exif:GpsSpeedRef tag.</value>
            <remarks><para>GPS tag 12, 0x0C. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsStatus">
            <summary>Gets the exif:GpsStatus tag.</summary>
            <value>exif:GpsStatus tag.</value>
            <remarks><para>GPS tag 9, 0x09. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsTimeStamp">
            <summary>Gets the exif:GpsTimeStamp tag.</summary>
            <value>exif:GpsTimeStamp tag.</value>
            <remarks><para>GPS tag 29 (date), 0x1D, and, and GPS tag 7 (time), 0x07. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsTrack">
            <summary>Gets the exif:GpsTrack tag.</summary>
            <value>exif:GpsTrack tag.</value>
            <remarks><para>GPS tag 15, 0x0F. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsTrackRef">
            <summary>Gets the exif:GpsTrackRef tag.</summary>
            <value>exif:GpsTrackRef tag.</value>
            <remarks><para>GPS tag 14, 0x0E. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifGpsVersionID">
            <summary>Gets the exif:GpsVersionID tag.</summary>
            <value>exif:GpsVersionID tag.</value>
            <remarks><para>GPS tag 0, 0x00. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifImageUniqueID">
            <summary>Gets the exif:ImageUniqueID tag.</summary>
            <value>exif:ImageUniqueID tag.</value>
            <remarks><para>EXIF tag 42016, 0xA420. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifISOSpeedRatings">
            <summary>Gets the exif:ISOSpeedRatings tag.</summary>
            <value>exif:ISOSpeedRatings tag.</value>
            <remarks><para>EXIF tag 34855, 0x8827. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifLightSource">
            <summary>Gets the exif:LightSource tag.</summary>
            <value>exif:LightSource tag.</value>
            <remarks><para>EXIF tag 37384, 0x9208. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifMaxApertureValue">
            <summary>Gets the exif:MaxApertureValue tag.</summary>
            <value>exif:MaxApertureValue tag.</value>
            <remarks><para>EXIF tag 37381, 0x9205. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifMeteringMode">
            <summary>Gets the exif:MeteringMode tag.</summary>
            <value>exif:MeteringMode tag.</value>
            <remarks><para>EXIF tag 37383, 0x9207. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifOECF">
            <summary>Gets the exif:OECF tag.</summary>
            <value>exif:OECF tag.</value>
            <remarks><para>EXIF tag 34856, 0x8828. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifPixelXDimension">
            <summary>Gets the exif:PixelXDimension tag.</summary>
            <value>exif:PixelXDimension tag.</value>
            <remarks><para>EXIF tag 40962, 0xA002. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifPixelYDimension">
            <summary>Gets the exif:PixelYDimension tag.</summary>
            <value>exif:PixelYDimension tag.</value>
            <remarks><para>EXIF tag 40963, 0xA003. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifRelatedSoundFile">
            <summary>Gets the exif:RelatedSoundFile tag.</summary>
            <value>exif:RelatedSoundFile tag.</value>
            <remarks><para>EXIF tag 40964, 0xA004. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSaturation">
            <summary>Gets the exif:Saturation tag</summary>
            <value>exif:Saturation tag.</value>
            <remarks><para>EXIF tag 41993, 0xA409. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSceneCaptureType">
            <summary>Gets the exif:SceneCaptureType tag.</summary>
            <value>exif:SceneCaptureType tag.</value>
            <remarks><para>EXIF tag 41990, 0xA406. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSceneType">
            <summary>Gets the exif:SceneType tag.</summary>
            <value>exif:SceneType tag.</value>
            <remarks><para>EXIF tag 41729, 0xA301. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSensingMethod">
            <summary>Gets the exif:SensingMethod tag.</summary>
            <value>exif:SensingMethod tag.</value>
            <remarks><para>EXIF tag 41495, 0xA217. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSharpness">
            <summary>Gets the exif:Sharpness tag.</summary>
            <value>exif:Sharpness tag.</value>
            <remarks><para>EXIF tag 41994, 0xA40A. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifShutterSpeedValue">
            <summary>Gets the exif:ShutterSpeedValue tag.</summary>
            <value>exif:ShutterSpeedValue tag.</value>
            <remarks><para>EXIF tag 37377, 0x9201. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSpatialFrequencyResponse">
            <summary>Gets the exif:SpatialFrequencyResponse tag.</summary>
            <value>exif:SpatialFrequencyResponse tag.</value>
            <remarks><para>EXIF tag 41484, 0xA20C. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSpectralSensitivity">
            <summary>Gets the exif:SpectralSensitivity tag.</summary>
            <value>exif:SpectralSensitivity tag.</value>
            <remarks><para>EXIF tag 34852, 0x8824. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSubjectArea">
            <summary>Gets the exif:SubjectArea tag.</summary>
            <value>exif:SubjectArea tag.</value>
            <remarks><para>EXIF tag 37396, 0x9214. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSubjectDistance">
            <summary>Gets the exif:SubjectDistance tag.</summary>
            <value>exif:SubjectDistance tag.</value>
            <remarks><para>EXIF tag 37382, 0x9206. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSubjectDistanceRange">
            <summary>Gets the exif:SubjectDistanceRange tag.</summary>
            <value>exif:SubjectDistanceRange tag.</value>
            <remarks><para>EXIF tag 41996, 0xA40C. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifSubjectLocation">
            <summary>Gets the exif:SubjectLocation tag.</summary>
            <value>exif:SubjectLocation tag.</value>
            <remarks><para>EXIF tag 41492, 0xA214. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifUserComment">
            <summary>Gets the exif:UserComment tag.</summary>
            <value>exif:UserComment tag.</value>
            <remarks><para>EXIF tag 37510, 0x9286. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.ExifWhiteBalance">
            <summary>Gets the exif:WhiteBalance tag.</summary>
            <value>exif:WhiteBalance tag.</value>
            <remarks><para>EXIF tag 41987, 0xA403. Belongs to the EXIF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PdfKeywords">
            <summary>Gets the pdf:Keywords tag.</summary>
            <value>pdf:Keywords tag.</value>
            <remarks><para>Keywords. Belongs to the Adobe PDF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PdfPDFVersion">
            <summary>Gets the pdf:PDFVersion tag.</summary>
            <value>pdf:PDFVersion tag.</value>
            <remarks><para>PDF file version.Belongs to the Adobe PDF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PdfProducer">
            <summary>Gets the pdf:Producer tag.</summary>
            <value>pdf:Producer tag.</value>
            <remarks><para>Name of the tool that created the PDF document. Belongs to the Adobe PDF schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopAuthorsPosition">
            <summary>Gets the photoshop:AuthorsPosition tag.</summary>
            <value>photoshop:AuthorsPosition tag.</value>
            <remarks><para>By-line title.Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopCaptionWriter">
            <summary>Gets the photoshop:CaptionWriter tag.</summary>
            <value>photoshop:CaptionWriter tag.</value>
            <remarks><para>Writer/editor.Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopCategory">
            <summary>Gets the photoshop:Category tag..</summary>
            <value>photoshop:Category tag.</value>
            <remarks><para>Category. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopCity">
            <summary>Gets the photoshop:City tag.</summary>
            <value>photoshop:City tag.</value>
            <remarks><para>City. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopCountry">
            <summary>Gets the photoshop:Country tag.</summary>
            <value>photoshop:Country tag.</value>
            <remarks><para>Country/primary location. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopCredit">
            <summary>Gets the photoshop:Credit tag.</summary>
            <value>photoshop:Credit tag.</value>
            <remarks><para>Credit. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopDateCreated">
            <summary>Gets the photoshop:DateCreated tag.</summary>
            <value>photoshop:DateCreated tag.</value>
            <remarks><para>Date the intellectual content of the document was created. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopHeadline">
            <summary>Gets the photoshop:Headline tag.</summary>
            <value>photoshop:Headline tag.</value>
            <remarks><para>Headline. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopInstructions">
            <summary>Gets the photoshop:Instructions tag.</summary>
            <value>photoshop:Instructions tag.</value>
            <remarks><para>Special instructions. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopSource">
            <summary>Gets the photoshop:Source tag.</summary>
            <value>photoshop:Source tag.</value>
            <remarks><para>Source. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopState">
            <summary>Gets the photoshop:State tag.</summary>
            <value>photoshop:State tag.</value>
            <remarks><para>Province/state. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopSupplementalCategories">
            <summary>Gets the photoshop:SupplementalCategories tag.</summary>
            <value>photoshop:SupplementalCategories tag.</value>
            <remarks><para>Supplemental category. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopTransmissionReference">
            <summary>Gets the photoshop:TransmissionReference tag.</summary>
            <value>photoshop:TransmissionReference tag.</value>
            <remarks><para>Original transmission reference. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.PhotoshopUrgency">
            <summary>Gets the photoshop:Urgency tag.</summary>
            <value>photoshop:Urgency tag.</value>
            <remarks><para>Urgency. Belongs to the Photoshop schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffArtist">
            <summary>Gets the tiff:Artist tag.</summary>
            <value>tiff:Artist tag.</value>
            <remarks><para>TIFF tag 315, 0x13B. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffBitsPerSample">
            <summary>Gets the tiff:BitsPerSample tag.</summary>
            <value>tiff:BitsPerSample tag.</value>
            <remarks><para>TIFF tag 258, 0x102. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffCompression">
            <summary>Gets the tiff:Compression tag.</summary>
            <value>tiff:Compression tag.</value>
            <remarks><para>TIFF tag 259, 0x103. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffCopyright">
            <summary>Gets the tiff:Copyright tag.</summary>
            <value>tiff:Copyright tag.</value>
            <remarks><para>TIFF tag 33432, 0x8298. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffDateTime">
            <summary>Gets the tiff:DateTime tag.</summary>
            <value>tiff:DateTime tag.</value>
            <remarks><para>TIFF tag 306, 0x132 (primary) and EXIF tag 37520, 0x9290 (subseconds). Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffImageDescription">
            <summary>Gets the tiff:ImageDescription tag.</summary>
            <value>tiff:ImageDescription tag.</value>
            <remarks><para>TIFF tag 270, 0x10E. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffImageLength">
            <summary>Gets the tiff:ImageLength tag.</summary>
            <value>tiff:ImageLength tag.</value>
            <remarks><para>TIFF tag 257, 0x101. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffImageWidth">
            <summary>Gets the tiff:ImageWidth tag.</summary>
            <value>tiff:ImageWidth tag.</value>
            <remarks><para>TIFF tag 256, 0x100. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffMake">
            <summary>Gets the tiff:Make tag.</summary>
            <value>tiff:Make tag.</value>
            <remarks><para>TIFF tag 271, 0x10F. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffModel">
            <summary>Gets the tiff:Model tag.</summary>
            <value>tiff:Model tag.</value>
            <remarks><para>TIFF tag 272, 0x110. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffOrientation">
            <summary>Gets the tiff:Orientation tag.</summary>
            <value>tiff:Orientation tag.</value>
            <remarks><para>TIFF tag 274, 0x112. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffPhotometricInterpretation">
            <summary>Gets the tiff:PhotometricInterpretation tag.</summary>
            <value>tiff:PhotometricInterpretation tag.</value>
            <remarks><para>TIFF tag 262, 0x106. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffPlanarConfiguration">
            <summary>Gets the tiff:PlanarConfiguration tag.</summary>
            <value>tiff:PlanarConfiguration tag.</value>
            <remarks><para>TIFF tag 284, 0x11C. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffPrimaryChromaticities">
            <summary>Gets the tiff:PrimaryChromaticities tag.</summary>
            <value>tiff:PrimaryChromaticities tag.</value>
            <remarks><para>TIFF tag 319. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffReferenceBlackWhite">
            <summary>Gets the tiff:ReferenceBlackWhite tags.</summary>
            <value>tiff:ReferenceBlackWhite tag.</value>
            <remarks><para>TIFF tag 532, 0x214. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffResolutionUnit">
            <summary>Gets the tiff:ResolutionUnit tag.</summary>
            <value>tiff:ResolutionUnit tag.</value>
            <remarks><para>TIFF tag 296, 0x128. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffSamplesPerPixel">
            <summary>Gets the tiff:SamplesPerPixel tag.</summary>
            <value>tiff:SamplesPerPixel tag.</value>
            <remarks><para>TIFF tag 277, 0x115. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffSoftware">
            <summary>Gets the tiff:Software tag.</summary>
            <value>tiff:Software tag.</value>
            <remarks><para>TIFF tag 305, 0x131. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffTransferFunction">
            <summary>Gets the tiff:TransferFunction tag.</summary>
            <value>tiff:TransferFunction tag.</value>
            <remarks><para>TIFF tag 301, 0x12D. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffWhitePoint">
            <summary>Gets the tiff:WhitePoint tag.</summary>
            <value>tiff:WhitePoint tag.</value>
            <remarks><para>TIFF tag 318, 0x13E. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffXResolution">
            <summary>Gets the tiff:XResolution tag.</summary>
            <value>tiff:XResolution tag.</value>
            <remarks><para>TIFF tag 282, 0x11A. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffYCbCrCoefficients">
            <summary>Gets the tiff:YCbCrCoefficients tag.</summary>
            <value>tiff:YCbCrCoefficients tag.</value>
            <remarks><para>TIFF tag 529, 0x211. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffYCbCrPositioning">
            <summary>Gets the tiff:YCbCrPositioning tag.</summary>
            <value>tiff:YCbCrPositioning tag.</value>
            <remarks><para>TIFF tag 531, 0x213. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffYCbCrSubSampling">
            <summary>Gets the tiff:YCbCrSubSampling tag.</summary>
            <value>tiff:YCbCrSubSampling tag.</value>
            <remarks><para>TIFF tag 530, 0x212. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.TiffYResolution">
            <summary>Gets the tiff:YResolution tag.</summary>
            <value>tiff:YResolution tag.</value>
            <remarks><para>TIFF tag 283, 0x11B. Belongs to the EXIF schema for TIFF properties.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpAdvisory">
            <summary>Gets the xmp:Advisory tag.</summary>
            <value>xmp:Advisory tag.</value>
            <remarks><para>Properties that were edited outside the authoring application. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpBaseURL">
            <summary>Gets the xmp:BaseURL tag.</summary>
            <value>xmp:BaseURL tag.</value>
            <remarks><para>Base URL for relative URLs in the document content. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpBJJobRef">
            <summary>Gets the xmpBJ:JobRef tag.</summary>
            <value>xmpBJ:JobRef tag.</value>
            <remarks><para>External job management file. Belongs to the XMP basic job ticket schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpCreateDate">
            <summary>Gets the xmp:CreateDate tag.</summary>
            <value>xmp:CreateDate tag.</value>
            <remarks><para>ate and time the resource was originally created. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpCreatorTool">
            <summary>Gets the xmp:CreatorTool tag.</summary>
            <value>xmp:CreatorTool tag.</value>
            <remarks><para>Name of the first known tool used to create the resource. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAbsPeakAudioFilePath">
            <summary>Gets the xmpDM:AbsPeakAudioFilePath tag.</summary>
            <value>xmpDM:AbsPeakAudioFilePath tag.</value>
            <remarks><para>The absolute path to the file's peak audio file. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAlbum">
            <summary>Gets the xmpDM:Album tag.</summary>
            <value>xmpDM:Album tag.</value>
            <remarks><para>Name of the album. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAltTapeName">
            <summary>Gets the xmpDM:AltTapeName tag.</summary>
            <value>xmpDM:AltTapeName tag.</value>
            <remarks><para>Name of the tape from which the clip was captured. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAltTimecode">
            <summary>Gets the xmpDM:AltTimecode tag.</summary>
            <value>xmpDM:AltTimecode tag.</value>
            <remarks><para>Timecode set by the user. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMArtist">
            <summary>Gets the xmpDM:Artist tag.</summary>
            <value>xmpDM:Artist tag.</value>
            <remarks><para>Name of the artist or artists. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAudioChannelType">
            <summary>Gets the xmpDM:AudioChannelType tag.</summary>
            <value>xmpDM:AudioChannelType tag.</value>
            <remarks><para>Audio channel type. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAudioCompressor">
            <summary>Gets the xmpDM:AudioCompressor tag.</summary>
            <value>xmpDM:AudioCompressor tag.</value>
            <remarks><para>Audio compression used. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAudioModDate">
            <summary>Gets the xmpDM:AudioModDate tag.</summary>
            <value>xmpDM:AudioModDate tag.</value>
            <remarks><para>Date and time when the audio was last modified. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAudioSampleRate">
            <summary>Gets the xmpDM:AudioSampleRate tag.</summary>
            <value>xmpDM:AudioSampleRate tag.</value>
            <remarks><para>Audio sample rate. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMAudioSampleType">
            <summary>Gets the xmpDM:AudioSampleType tag.</summary>
            <value>xmpDM:AudioSampleType tag.</value>
            <remarks><para>Audio sample type. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMBeatSpliceParams">
            <summary>Gets the xmpDM:BeatSpliceParams tag.</summary>
            <value>xmpDM:BeatSpliceParams tag.</value>
            <remarks><para>Additional parameters for "Beat Splice" stretch mode. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMComposer">
            <summary>Gets the xmpDM:Composer tag.</summary>
            <value>xmpDM:Composer tag.</value>
            <remarks><para>Composer's name. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMContributedMedia">
            <summary>Gets the xmpDM:ContributedMedia tag.</summary>
            <value>xmpDM:ContributedMedia tag.</value>
            <remarks><para>Unordered list of all media used to create this media. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMCopyright">
            <summary>Gets the xmpDM:Copyright tag.</summary>
            <value>xmpDM:Copyright tag.</value>
            <remarks><para>Copyright information. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMDuration">
            <summary>Gets the xmpDM:Duration tag.</summary>
            <value>xmpDM:Duration tag.</value>
            <remarks><para>Duration of the media file. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMEngineer">
            <summary>Gets the xmpDM:Engineer tag.</summary>
            <value>xmpDM:Engineer tag.</value>
            <remarks><para>Engineer's name. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMFileDataRate">
            <summary>Gets the xmpDM:FileDataRate tag.</summary>
            <value>xmpDM:FileDataRate tag.</value>
            <remarks><para>File data rate in megabytes per second. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMGenre">
            <summary>Gets the xmpDM:Genre tag.</summary>
            <value>xmpDM:Genre tag.</value>
            <remarks><para>Name of the genre. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMInstrument">
            <summary>Gets the xmpDM:Instrument tag.</summary>
            <value>xmpDM:Instrument tag.</value>
            <remarks><para>Musical instrument. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMIntroTime">
            <summary>Gets the xmpDM:IntroTime tag.</summary>
            <value>xmpDM:IntroTime tag.</value>
            <remarks><para>Duration of lead time for queuing music. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMKey">
            <summary>Gets the xmpDM:Key tag.</summary>
            <value>xmpDM:Key tag.</value>
            <remarks><para>The audio's musical key. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMLogComment">
            <summary>Gets the xmpDM:LogComment tag.</summary>
            <value>xmpDM:LogComment tag.</value>
            <remarks><para>User's log comments. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMLoop">
            <summary>Gets the xmpDM:Loop tag.</summary>
            <value>xmpDM:Loop tag.</value>
            <remarks><para>Value indicating if the clip can be looped seamlessly. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMMarkers">
            <summary>Gets the xmpDM:Markers tag.</summary>
            <value>xmpDM:Markers tag.</value>
            <remarks><para>Ordered list of markers. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMMetadataModDate">
            <summary>Gets the xmpDM:MetadataModDate tag.</summary>
            <value>xmpDM:MetadataModDate tag.</value>
            <remarks><para>Date and time when the metadata was last modified. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMNumberOfBeats">
            <summary>Gets the xmpDM:NumberOfBeats tag.</summary>
            <value>xmpDM:NumberOfBeats tag.</value>
            <remarks><para>Number of beats. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMOutCue">
            <summary>Gets the xmpDM:OutCue tag.</summary>
            <value>xmpDM:OutCue tag.</value>
            <remarks><para>Time at which to fade out. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMProjectRef">
            <summary>Gets the xmpDM:ProjectRef tag.</summary>
            <value>xmpDM:ProjectRef tag.</value>
            <remarks><para>Reference to the project that created this file. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMPullDown">
            <summary>Gets the xmpDM:PullDown tag.</summary>
            <value>xmpDM:PullDown tag.</value>
            <remarks><para>Sampling phase of film to be converted to video (pull-down). Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMRelativePeakAudioFilePath">
            <summary>Gets the xmpDM:RelativePeakAudioFilePath tag.</summary>
            <value>xmpDM:RelativePeakAudioFilePath tag.</value>
            <remarks><para>Relative path to the file's peak audio file. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMRelativeTimestamp">
            <summary>Gets the xmpDM:RelativeTimestamp tag.</summary>
            <value>xmpDM:RelativeTimestamp tag.</value>
            <remarks><para>Start time of the media inside the audio project. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMReleaseDate">
            <summary>Gets the xmpDM:ReleaseDate tag.</summary>
            <value>xmpDM:ReleaseDate tag.</value>
            <remarks><para>Date the title was released. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMResampleParams">
            <summary>Gets the xmpDM:ResampleParams tag.</summary>
            <value>xmpDM:ResampleParams tag.</value>
            <remarks><para>Additional parameters for "Resample" stretch mode. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMScaleType">
            <summary>Gets the xmpDM:ScaleType tag.</summary>
            <value>xmpDM:ScaleType tag.</value>
            <remarks><para>Musical scale used in the music. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMScene">
            <summary>Gets the xmpDM:Scene tag.</summary>
            <value>xmpDM:Scene tag.</value>
            <remarks><para>Name of the scene. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMShotDate">
            <summary>Gets the xmpDM:ShotDate tag.</summary>
            <value>xmpDM:ShotDate tag.</value>
            <remarks><para>Date and time when the video was shot. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMShotLocation">
            <summary>Gets the xmpDM:ShotLocation tag.</summary>
            <value>xmpDM:ShotLocation tag.</value>
            <remarks><para>Name of the location where the video was shot. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMShotName">
            <summary>Gets the xmpDM:ShotName tag.</summary>
            <value>xmpDM:ShotName tag.</value>
            <remarks><para>Name of the shot or take. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMSpeakerPlacement">
            <summary>Gets the xmpDM:SpeakerPlacement tag.</summary>
            <value>xmpDM:SpeakerPlacement tag.</value>
            <remarks><para>Description of the speaker angles from center front in degrees. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMStartTimecode">
            <summary>Gets the xmpDM:StartTimecode tag.</summary>
            <value>xmpDM:StartTimecode tag.</value>
            <remarks><para>Timecode of the first frame of video in the file, as obtained from the device control. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMStretchMode">
            <summary>Gets the xmpDM:StretchMode tag.</summary>
            <value>xmpDM:StretchMode tag.</value>
            <remarks><para>Audio stretch mode. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMTapeName">
            <summary>Gets the xmpDM:TapeName tag.</summary>
            <value>xmpDM:TapeName tag.</value>
            <remarks><para>Name of the tape from which the clip was captured. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMTempo">
            <summary>Gets the xmpDM:Tempo tag.</summary>
            <value>xmpDM:Tempo tag.</value>
            <remarks><para>Audio's tempo. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMTimeScaleParams">
            <summary>Gets the xmpDM:TimeScaleParams tag.</summary>
            <value>xmpDM:TimeScaleParams tag.</value>
            <remarks><para>Additional parameters for "Time-Scale" stretch mode. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMTimeSignature">
            <summary>Gets the xmpDM:TimeSignature tag.</summary>
            <value>xmpDM:TimeSignature tag.</value>
            <remarks><para>Time signature of the music. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMTrackNumber">
            <summary>Gets the xmpDM:TrackNumber tag.</summary>
            <value>xmpDM:TrackNumber tag.</value>
            <remarks><para>Numeric value indicating the order of the audio file within its original recording. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoAlphaMode">
            <summary>Gets the xmpDM:VideoAlphaMode tag.</summary>
            <value>xmpDM:VideoAlphaMode tag.</value>
            <remarks><para>Alpha mode. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoAlphaPremultipleColor">
            <summary>Gets the xmpDM:VideoAlphaPremultipleColor tag.</summary>
            <value>xmpDM:VideoAlphaPremultipleColor tag.</value>
            <remarks><para>Color in CMYK or RGB to be used as the pre-multiple color when alpha mode is pre-multiplied. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoAlphaUnityIsTransparent">
            <summary>Gets the xmpDM:VideoAlphaUnityIsTransparent tag</summary>
            <value>xmpDM:VideoAlphaUnityIsTransparent tag.</value>
            <remarks><para>Value indicating if the unity is clear or opaque. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoColorSpace">
            <summary>Gets the xmpDM:VideoColorSpace tag.</summary>
            <value>xmpDM:VideoColorSpace tag.</value>
            <remarks><para>Color space. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoCompressor">
            <summary>Gets the xmpDM:VideoCompressor tag.</summary>
            <value>xmpDM:VideoCompressor tag.</value>
            <remarks><para>Video compression used. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoFrameRate">
            <summary>Gets the xmpDM:VideoFrameRate tag.</summary>
            <value>xmpDM:VideoFrameRate tag.</value>
            <remarks><para>Video frame rate. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoFrameSize">
            <summary>Gets the xmpDM:VideoFrameSize tag.</summary>
            <value>xmpDM:VideoFrameSize tag.</value>
            <remarks><para>Frame size. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoModDate">
            <summary>Gets the xmpDM:VideoModDate tag.</summary>
            <value>xmpDM:VideoModDate tag.</value>
            <remarks><para>Date and time when the video was last modified. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoPixelAspectRatio">
            <summary>Gets the xmpDM:VideoPixelAspectRatio tag.</summary>
            <value>xmpDM:VideoPixelAspectRatio tag.</value>
            <remarks><para>Aspect ratio, expressed as ht/wd. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpDMVideoPixelDepth">
            <summary>Gets the xmpDM:VideoPixelDepth tag.</summary>
            <value>xmpDM:VideoPixelDepth tag.</value>
            <remarks><para>Size in bits of each color component of a pixel. Belongs to the XMP dynamic media schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpIdentifier">
            <summary>Gets the xmp:Identifier tag.</summary>
            <value>xmp:Identifier tag.</value>
            <remarks><para>Unordered array of text strings that unambiguously identify the resource within a given context. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpIdqScheme">
            <summary>Gets the xmpidq:Scheme tag.</summary>
            <value>xmpidq:Scheme tag.</value>
            <remarks><para>Name of the formal identification system.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpLabel">
            <summary>Gets the xmp:Label tag.</summary>
            <value>xmp:Label tag.</value>
            <remarks><para>Word or short phrase that identifies a document as a member of a user-defined collection. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMetadataDate">
            <summary>Gets the xmp:MetadataDate tag.</summary>
            <value>xmp:MetadataDate tag.</value>
            <remarks><para>Date and time that any metadata for this resource was last changed.Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMDerivedFrom">
            <summary>Gets the xmpMM:DerivedFrom tag.</summary>
            <value>xmpMM:DerivedFrom tag.</value>
            <remarks><para>Reference to the original document from which this one is derived. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMDocumentID">
            <summary>Gets the xmpMM:DocumentID tag.</summary>
            <value>xmpMM:DocumentID tag.</value>
            <remarks><para>Common identifier for all versions and renditions of a document. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMHistory">
            <summary>Gets the xmpMM:History tag.</summary>
            <value>xmpMM:History tag.</value>
            <remarks><para>Ordered array of high-level user actions that resulted in this resource. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMLastURL">
            <summary>Gets the xmpMM:LastURL tag.</summary>
            <value>xmpMM:LastURL tag.</value>
            <remarks><para>The tag returned by this property is deprecated. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMManagedFrom">
            <summary>Gets the xmpMM:ManagedFrom tag.</summary>
            <value>xmpMM:ManagedFrom tag.</value>
            <remarks><para>Reference to the document as it was prior to becoming managed. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMManager">
            <summary>Gets the xmpMM:Manager tag.</summary>
            <value>xmpMM:Manager tag.</value>
            <remarks><para>Name of the asset management system that manages this resource. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMManagerVariant">
            <summary>Gets the xmpMM:ManagerVariant tag.</summary>
            <value>xmpMM:ManagerVariant tag.</value>
            <remarks><para>Particular variant of the asset management system. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMManageTo">
            <summary>Gets the xmpMM:ManageTo tag.</summary>
            <value>xmpMM:ManageTo tag.</value>
            <remarks><para>URI identifying the managed resource to the asset management system. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMManageUI">
            <summary>Gets the xmpMM:ManageUI tag.</summary>
            <value>xmpMM:ManageUI tag.</value>
            <remarks><para>URI that can be used to access information about the managed resource through a web browser. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMRenditionClass">
            <summary>Gets the xmpMM:RenditionClass tag.</summary>
            <value>xmpMM:RenditionClass tag.</value>
            <remarks><para>Rendition class name for this resource. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMRenditionOf">
            <summary>Gets the xmpMM:RenditionOf tag.</summary>
            <value>xmpMM:RenditionOf tag.</value>
            <remarks><para>The tag returned by this property is deprecated. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMRenditionParams">
            <summary>Gets the xmpMM:RenditionParams tag.</summary>
            <value>xmpMM:RenditionParams tag.</value>
            <remarks><para>Value that can be used to provide additional rendition parameters. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMSaveID">
            <summary>Gets the xmpMM:SaveID tag.</summary>
            <value>xmpMM:SaveID tag.</value>
            <remarks><para>The tag returned by this property is deprecated. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMVersionID">
            <summary>Gets the xmpMM:VersionID tag.</summary>
            <value>xmpMM:VersionID tag.</value>
            <remarks><para>Document version identifier for this resource. Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpMMVersions">
            <summary>Gets the xmpMM:Versions tag.</summary>
            <value>xmpMM:Versions tag.</value>
            <remarks><para>Version history associated with this resource.  Belongs to the XMP media management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpModifyDate">
            <summary>Gets the xmp:ModifyDate tag.</summary>
            <value>xmp:ModifyDate tag.</value>
            <remarks><para>Date and time the resource was last modified. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpNickname">
            <summary>Gets the xmp:Nickname tag.</summary>
            <value>xmp:Nickname tag.</value>
            <remarks><para>Short informal name for the resource. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRating">
            <summary>Gets the xmp:Rating tag.</summary>
            <value>xmp:Rating tag.</value>
            <remarks><para>Number that indicates a document's status relative to other documents. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRightsCertificate">
            <summary>Gets the xmpRights:Certificate tag.</summary>
            <value>xmpRights:Certificate tag.</value>
            <remarks><para>Online rights management certificate. Belongs to the XMP rights management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRightsMarked">
            <summary>Gets the xmpRights:Marked tag.</summary>
            <value>xmpRights:Marked tag.</value>
            <remarks><para>Value indicating that this is a rights-managed resource. Belongs to the XMP rights management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRightsOwner">
            <summary>Gets the xmpRights:Owner tag.</summary>
            <value>xmpRights:Owner tag.</value>
            <remarks><para>Legal owner(s) of the resource. Belongs to the XMP rights management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRightsUsageTerms">
            <summary>Gets the xmpRights:UsageTerms tag.</summary>
            <value>xmpRights:UsageTerms tag.</value>
            <remarks><para>Text instructions on how the resource can be legally used. Belongs to the XMP rights management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpRightsWebStatement">
            <summary>Gets the xmpRights:WebStatement tag.</summary>
            <value>xmpRights:WebStatement tag.</value>
            <remarks><para>Location of a web page describing the owner and/or rights statement for this resource. Belongs to the XMP rights management schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpThumbnails">
            <summary>Gets the xmp:Thumbnails tag.</summary>
            <value>xmp:Thumbnails tag.</value>
            <remarks><para>Thumbnail images for a file. Belongs to the basic XMP schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpTPgColorants">
            <summary>Gets the xmpTPg:Colorants tag.</summary>
            <value>xmpTPg:Colorants tag.</value>
            <remarks><para>Colorants (swatches) that are used in the document. Belongs to the XMP paged-text schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpTPgFonts">
            <summary>Gets the xmpTPg:Fonts tag.</summary>
            <value>xmpTPg:Fonts tag.</value>
            <remarks><para>Fonts that are used in the document. Belongs to the XMP paged-text schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpTPgMaxPageSize">
            <summary>Gets the xmpTPg:MaxPageSize tag.</summary>
            <value>xmpTPg:MaxPageSize tag.</value>
            <remarks><para>Size of the largest page in the document. Belongs to the XMP paged-text schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpTPgNPages">
            <summary>Gets the xmpTPg:NPages tag.</summary>
            <value>xmpTPg:NPages tag.</value>
            <remarks><para>Number of pages in the document. Belongs to the XMP paged-text schema.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpTagNames.XmpTPgPlateNames">
            <summary>Gets the xmpTPg:PlateNames tag.</summary>
            <value>xmpTPg:PlateNames tag.</value>
            <remarks><para>Plate names that are needed to print the document. Belongs to the XMP paged-text schema.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Codecs.XmpValueNode">
            <summary>This class represents a simple XMP property.</summary>
            <remarks><para>A simple type has a literal value. Simple types include familiar ones such as strings, booleans, integers and real numbers, and so on.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpValueNode.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpValueNode.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpValueNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNodeType,System.String,Aurigma.GraphicsMill.Codecs.XmpNamespace,System.String)" draft="yes">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> instance using a specified namespace.</summary>
            <param name="nodeType">Type of the node.</param>
            <param name="value">Value to be stored in the node.</param>
            <param name="ns">Namespace to which the new node belongs.</param>
            <param name="name">Name of the node.</param>
            <overloads><summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpValueNode.#ctor(Aurigma.GraphicsMill.Codecs.XmpNodeType,System.String,System.String)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> instance.</summary>
            <param name="nodeType">Type of the node.</param>
            <param name="value">Value to be stored in the node.</param>
            <param name="name">Name of the node.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Codecs.XmpValueNode.ToString">
            <summary>Returns a string representation of this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> instance.</summary>
            <returns>Value containing a string representation of this <see cref="T:Aurigma.GraphicsMill.Codecs.XmpValueNode" /> instance.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Codecs.XmpValueNode.Value">
            <summary>Gets a value stored in this item.</summary>
            <value>Value that is stored in this node.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Color">
            <summary>This is a base class for color values used in Graphics Mill for .NET.</summary>
            <remarks><para>
              This is a base class for all colors in Graphics Mill for .NET. It can be used as a class factory - you can create <see cref="T:Aurigma.GraphicsMill.RgbColor" /> with <see cref="M:Aurigma.GraphicsMill.Color.FromRgb(System.Byte,System.Byte,System.Byte)" />, <see cref="M:Aurigma.GraphicsMill.Color.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)" /> methods, and its siblings; <see cref="T:Aurigma.GraphicsMill.CmykColor" /> with <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk(System.Byte,System.Byte,System.Byte,System.Byte)" />, <see cref="M:Aurigma.GraphicsMill.Color.FromAcmyk(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />, etc; <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> with <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)" />, <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale(System.Byte,System.Byte)" />, etc. Also there are extended analogues, which have a suffix 32.
            </para><para>
              Also you can get components (channels) by index using <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" /> method. A number of components can be returned by <see cref="P:Aurigma.GraphicsMill.Color.ChannelCount" /> property.
            </para></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#CreateArgbSimple"></code><code language="CS" source="ColorConversionCS/form1.cs#CreateArgbSimple"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Color.A">
            <summary>Returns 8-bit alpha channel value (color opacity).</summary>
            <value>8-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Color.A32">
            <summary>Returns 16-bit  (extended) alpha channel value (color opacity).</summary>
            <value>16-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Color.ChannelCount">
            <summary>Returns number of channels available in this color.</summary>
            <value>Number of channels available in this color.</value>
            <remarks>Alpha channel is always available. That's why RGB colors always return 4 (three color channels + alpha channel), grayscale colors returns 2 (luminosity channel + alpha channel), etc.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Color.ColorSpace">
            <summary>Returns a color space of the color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value indicating color space of the color.</value>
            <remarks>Each class which derived from <see cref="T:Aurigma.GraphicsMill.Color" /> class represents its own color space. It means that if, for example, this property returns <see cref="F:Aurigma.GraphicsMill.ColorSpace.Rgb" />, you can cast this <see cref="T:Aurigma.GraphicsMill.Color" /> variable to <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class. However casting to derived classes is considered as bad style from object-oriented point of view, so it is recommended to use it only if it is necessary indeed.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)">
            <summary>Converts color value to another color space.</summary>
            <param name="colorSpace"><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value that specifies the color space to convert color to.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Color" /> class instance converted to specified color space.</returns>
            <remarks>No color management is applied during conversion with this method. That's why color conversion is quite fast, but inaccurate.</remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#ArgbToCmyk"></code><code language="CS" source="ColorConversionCS/form1.cs#ArgbToCmyk"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAcmyk(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from all 5 channels (alpha, cyan, magenta, yellow, and black).</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="cyan">Cyan channel value.</param>
            <param name="magenta">Magenta channel value.</param>
            <param name="yellow">Yellow channel value.</param>
            <param name="black">Black channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAcmyk32(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk(System.Byte,System.Byte,System.Byte,System.Byte)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAcmyk32(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from all 5 channels (alpha, cyan, magenta, yellow, and black).</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="cyan">Cyan channel value.</param>
            <param name="magenta">Magenta channel value.</param>
            <param name="yellow">Yellow channel value.</param>
            <param name="black">Black channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAcmyk(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk32(System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAGrayScale(System.Byte,System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given luminosity and alpha channel values.</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="gray">Luminosity channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale32(System.Int32,System.Int32)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAGrayScale32(System.Int32)" draft="yes">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from numeric 32-bit representation of grayscale value with alpha channel.</summary>
            <param name="alphaGrayScale">Numeric representation of the alpha grayscale value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given number.</returns>
            <remarks>Low byte of this 32-bit value contains intensity level, next byte contains alpha value. The rest higher bytes are ignored. You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale64(System.Int64)" />.</remarks>
            <overloads><summary>
              Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance.
            </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAGrayScale32(System.Int32,System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given luminosity and alpha channel values.</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="gray">Luminosity channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale(System.Byte,System.Byte)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale32(System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromAGrayScale64(System.Int64)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from numeric 64-bit representation of grayscale value with alpha channel.</summary>
            <param name="alphaGrayScale">Numeric representation of the alpha grayscale value (extended).</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance constructed from given number.</returns>
            <remarks>Low word (2 bytes) of this 64-bit value contains intensity level, next word contains alpha value. The rest higher words are ignored. You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale32(System.Int32)" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from all 4 channels (alpha, red, green, and blue).</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="red">Red channel value.</param>
            <param name="green">Green channel value.</param>
            <param name="blue">Blue channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromArgb32(System.Int32,System.Int32,System.Int32,System.Int32)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromRgb(System.Byte,System.Byte,System.Byte)" /> method.</remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#CreateArgbSimple"></code><code language="CS" source="ColorConversionCS/form1.cs#CreateArgbSimple"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromArgb32(System.Int32)" draft="yes">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from numeric 32-bit representation of RGB value with alpha channel.</summary>
            <param name="argb">Numeric representation of the ARGB value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given number.</returns>
            <remarks>Low byte of this 32-bit value contains blue channel, next byte contains green channel, next one is a red channel, and the high byte is an alpha channel. You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromArgb64(System.Int64)" />.</remarks>
            <overloads><summary>
              Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance.
            </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromArgb32(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from all 4 channels (alpha, red, green, and blue).</summary>
            <param name="alpha">Alpha channel value.</param>
            <param name="red">Red channel value.</param>
            <param name="green">Green channel value.</param>
            <param name="blue">Blue channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromRgb32(System.Int32,System.Int32,System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromArgb64(System.Int64)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from numeric 64-bit representation of RGB value with alpha channel.</summary>
            <param name="argb">Numeric representation of the ARGB value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given number.</returns>
            <remarks>Low word (2 bytes) of this 64-bit value contains blue channel, next word contains green channel, next one is a red channel, and the high word is an alpha channel. You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromArgb32(System.Int32)" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromCmyk(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from all 4 color channels (cyan, magenta, yellow, and black).</summary>
            <param name="cyan">Cyan channel value.</param>
            <param name="magenta">Magenta channel value.</param>
            <param name="yellow">Yellow channel value.</param>
            <param name="black">Black channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk32(System.Int32,System.Int32,System.Int32,System.Int32)" />. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromAcmyk(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" /> method.</remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#CreateCmyk"></code><code language="CS" source="ColorConversionCS/form1.cs#CreateCmyk"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromCmyk32(System.Int32)" draft="yes">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from numeric 32-bit representation of CMYK value without alpha channel.</summary>
            <param name="cmyk">Numeric representation of the CMYK value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given number.</returns>
            <remarks>Low byte of this 32-bit value contains black channel, next byte contains yellow channel, next one is a magenta channel, and the high byte is a cyan channel. Alpha channel cannot be passed into this method. You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk64(System.Int64)" />.</remarks>
            <overloads><summary>
              Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance.
            </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromCmyk32(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from all 4 color channels (cyan, magenta, yellow, and black).</summary>
            <param name="cyan">Cyan channel value.</param>
            <param name="magenta">Magenta channel value.</param>
            <param name="yellow">Yellow channel value.</param>
            <param name="black">Black channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk(System.Byte,System.Byte,System.Byte,System.Byte)" />. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromAcmyk32(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromCmyk64(System.Int64)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from numeric 32-bit representation of CMYK value without alpha channel.</summary>
            <param name="cmyk">Numeric representation of the CMYK value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance constructed from given number.</returns>
            <remarks>Low word (2 bytes) of this 64-bit value contains black channel, next word contains yellow channel, next one is a magenta channel, and the high word is a cyan channel. Alpha channel cannot be passed into this method. You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromCmyk32(System.Int32)" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromGdiplusColor(System.Drawing.Color)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</summary>
            <param name="color"><see cref="T:System.Drawing.Color">System.Drawing.Color</see> value to construct <see cref="T:Aurigma.GraphicsMill.RgbColor" /> from.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> constructed from specified luminosity level.</summary>
            <param name="gray">Luminosity level value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> constructed from specified luminosity level.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale32(System.Int32)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)" /> method. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale(System.Byte,System.Byte)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromGrayScale32(System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> constructed from specified luminosity level.</summary>
            <param name="gray">Luminosity level value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> constructed from specified luminosity level.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)" />. If you do not care about alpha channel, you can also use <see cref="M:Aurigma.GraphicsMill.Color.FromGrayScale(System.Byte)" /> method. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromAGrayScale32(System.Int32,System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromHsl(System.Single,System.Single,System.Single)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from hue, saturation, and lightness parameters.</summary>
            <param name="hue">The hue parameter. Means the angle at the color wheel, so meaningful values are in range [-1.0, 1.0].</param>
            <param name="saturation">The saturation parameter. It should be in range [-1.0, 1.0].</param>
            <param name="lightness">The lightness parameter. It should be in range [-1.0, 1.0].</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given HSL parameters.</returns>
            <example><code language="VB" source="ColorConversionVB/form1.vb#CreateArgbFromHsl"></code><code language="CS" source="ColorConversionCS/form1.cs#CreateArgbFromHsl"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromRgb(System.Byte,System.Byte,System.Byte)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from all 3 color channels (red, green, and blue).</summary>
            <param name="red">Red channel value.</param>
            <param name="green">Green channel value.</param>
            <param name="blue">Blue channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromRgb32(System.Int32,System.Int32,System.Int32)" />. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.FromRgb32(System.Int32,System.Int32,System.Int32)">
            <summary>Returns <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from all 3 color channels (red, green, and blue).</summary>
            <param name="red">Red channel value.</param>
            <param name="green">Green channel value.</param>
            <param name="blue">Blue channel value.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance constructed from given channels.</returns>
            <remarks>You can also use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.FromRgb(System.Byte,System.Byte,System.Byte)" />. If you need also supply alpha channel, you can use <see cref="M:Aurigma.GraphicsMill.Color.FromArgb32(System.Int32,System.Int32,System.Int32,System.Int32)" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.GetChannel(Aurigma.GraphicsMill.ColorChannel)" draft="yes">
            <summary>Gets value stored in specified channel of this color.</summary>
            <param name="colorChannel"><see cref="T:Aurigma.GraphicsMill.ColorChannel" /> value specifying an alias of channel to retrieve. Draw attention, it does not check color space, so if you pass, say, <see cref="F:Aurigma.GraphicsMill.ColorChannel.Yellow" /> to RGB color, you will get a value stored at the same index as yellow in CMYK (i.e. <see cref="F:Aurigma.GraphicsMill.ColorChannel.Green" />).</param>
            <returns>Non-extended (8-bit) value stored in specified channel.</returns>
            <remarks>You can also use extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.Color.GetChannel32(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.Color.GetChannel32(System.Int32)" /> returns extended (16-bit) value.</remarks>
            <overloads><summary>Gets value stored in specified channel of this color.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.GetChannel(System.Int32)">
            <summary>Gets value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Non-extended (8-bit) value stored in specified channel.</returns>
            <remarks>You can also use extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.Color.GetChannel32(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.Color.GetChannel32(System.Int32)" /> returns extended (16-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.GetChannel32(Aurigma.GraphicsMill.ColorChannel)" draft="yes">
            <summary>Gets extended (16-bit) value stored in specified channel of this color.</summary>
            <param name="colorChannel"><see cref="T:Aurigma.GraphicsMill.ColorChannel" /> value specifying an alias of channel to retrieve. Draw attention, it does not check color space, so if you pass, say, <see cref="F:Aurigma.GraphicsMill.ColorChannel.Yellow" /> to RGB color, you will get a value stored at the same index as yellow in CMYK (i.e. <see cref="F:Aurigma.GraphicsMill.ColorChannel.Green" />).</param>
            <returns>Extended (16-bit) value stored in specified channel.</returns>
            <remarks>You can also use non-extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.Color.GetChannel(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.Color.GetChannel(System.Int32)" /> returns non-extended (8-bit) value.</remarks>
            <overloads><summary>Gets extended (16-bit) value stored in specified channel of this color.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.GetChannel32(System.Int32)">
            <summary>Gets extended (16-bit) value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Extended (16-bit) value stored in specified channel.</returns>
            <remarks>You can also use non-extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.Color.GetChannel(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.Color.GetChannel(System.Int32)" /> returns non-extended (8-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.op_Implicit(Aurigma.GraphicsMill.Color)~System.Int32" draft="yes">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to 32-bit integer number.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to cast.</param>
            <returns>Numeric representation of the color. Note, 32-bit integer value can contain maximum 4 non-extended (8-bit) channels. So if you cast CMYK value, alpha channel (5th channel in ACMYK quintuple) will be truncated. If you need to get all channels, use <see cref="M:Aurigma.GraphicsMill.Color.ToArray" /> method.</returns>
            <overloads><summary>Casts color data format.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.op_Implicit(Aurigma.GraphicsMill.Color)~System.Int64">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to 64-bit long number.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to cast.</param>
            <returns>Numeric representation of the color. Note, 64-bit integer value can contain maximum 4 extended (16-bit) channels. So if you cast CMYK value, alpha channel (5th channel in ACMYK quintuple) will be truncated. If you need to get all channels, use <see cref="M:Aurigma.GraphicsMill.Color.ToArray32" /> method.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.op_Implicit(Aurigma.GraphicsMill.Color)~System.Drawing.Color">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance to cast.</param>
            <returns>Color value casted to <see cref="T:System.Drawing.Color">System.Drawing.Color</see>.</returns>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> is not belong to RGB color space, it is automatically converted to RGB using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.op_Implicit(System.Drawing.Color)~Aurigma.GraphicsMill.Color">
            <summary>Casts <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value to <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance.</summary>
            <param name="obj"><see cref="T:System.Drawing.Color">System.Drawing.Color</see> value which is being casted.</param>
            <returns>Casted <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> class instance.</returns>
            <remarks>Classes casted from <see cref="T:System.Drawing.Color">System.Drawing.Color</see> values always has <see cref="T:Aurigma.GraphicsMill.RgbColor" /> type.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ToArray">
            <summary>Returns a byte array that contains all channels of the color (8 bits per channel).</summary>
            <returns>Array that contains channels of the color.</returns>
            <remarks><para>
              The order of channels is the same as byte order in numeric representation of the color. The last item always contains alpha channel. Therefore the order is a following (from first array item to last):
            </para><list type="bullet"><item><term>RGB</term><description>blue, green, red, alpha;</description></item><item><term>CMYK</term><description>black, yellow, magenta, cyan, alpha;</description></item><item><term>Grayscale</term><description>intensity level, alpha;</description></item></list><para>
              Also, you can use extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.ToArray32" />.
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ToArray32">
            <summary>Returns an integer numbers array that contains all channels of the color (16 bits per channel).</summary>
            <returns>Array that contains channels of the color.</returns>
            <remarks><para>
              The order of channels is the same as word order in numeric representation of the color. The last item always contains alpha channel. Therefore the order is a following (from first array item to last):
            </para><list type="bullet"><item><term>RGB</term><description>blue, green, red, alpha;</description></item><item><term>CMYK</term><description>black, yellow, magenta, cyan, alpha;</description></item><item><term>Grayscale</term><description>intensity level, alpha;</description></item></list><para>
              Also, you can use non-extended version of this method, i.e. <see cref="M:Aurigma.GraphicsMill.Color.ToArray" />.
            </para><note type="note">Although the array contains 32-bit values, only low 16 bits are meaningful. High 16 bits are always initialized with zeros.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ToGdiplusColor">
            <summary>Returns <see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.Color" /> does.</summary>
            <returns><see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.Color" /> does.</returns>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Color">Aurigma.GraphicsMill.Color</see> is not belong to RGB color space, it is automatically converted to RGB using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ToInt32">
            <summary>Returns non-extended (8 bit per channel) numeric representation of the <see cref="T:Aurigma.GraphicsMill.Color" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.Color" />.</returns>
            <remarks>If color has larger than 4 channels, all extra channels will be truncated. For example, <see cref="T:Aurigma.GraphicsMill.CmykColor" /> will return only CMYK quad instead of ACMYK quintuple; alpha channel will be truncated.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Color.ToInt64">
            <summary>Returns extended (16 bit per channel) numeric representation of the <see cref="T:Aurigma.GraphicsMill.Color" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.Color" />.</returns>
            <remarks>If color has larger than 4 channels, all extra channels will be truncated. For example, <see cref="T:Aurigma.GraphicsMill.CmykColor" /> will return only CMYK quad instead of ACMYK quintuple; alpha channel will be truncated.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorAdjustmentProvider" draft="yes">
            <summary>This class contains methods and properties used by <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to apply color adjustment.</summary>
            <remarks><para>
              This class enables you to apply tone and color correction algorithms on the bitmap without creating appropriate transform object (contained in <see cref="N:Aurigma.GraphicsMill.Transforms" /> namespace). Therefore you can write only single line of code to make a tone correction. For example, instead of this code:
            </para><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslTransform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslTransform"></code><para>
              you can just use this code:
            </para><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslColorAdjustment"></code><para>
              The only drawback of this short syntax is that you can run transforms and effects through this class only in synchronous mode. If you need to use asynchronous mode, you should create transform class instances and set up the asynchronous mode settings for them.
            </para><para>
              Another difference of using of this class instead of transform objects is event handling. Unlike transform objects, you should assign event handlers directly to the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.
            </para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AdjustHsl(System.Single,System.Single,System.Single)">
            <summary>Adjusts hue, saturation, and lightness of the image.</summary>
            <param name="hue">Hue modifier. Should be in range [-1, 1].</param>
            <param name="saturation">Saturation modifier. Should be in range [-1, 1].</param>
            <param name="lightness">Lightness modifier. Should be in range [-1, 1].</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> class to apply this correction.
            </para><para>
              Such parameters as <i>saturation</i> and <i>lightness</i> are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method. Hue is normalized to 360. In other words, hue*360 means a degree on the color wheel.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslColorAdjustment"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.ApplyLut(Aurigma.GraphicsMill.Transforms.Lut)">
            <summary>Applies tone correction using specified look-up table (LUT).</summary>
            <param name="lut"><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance which specifies look-up table for this LUT transform.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class to apply this correction.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslColorAdjustment"></code></example>
            <overloads><summary>Applies tone correction using specified look-up table (LUT).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.ApplyLut(System.Boolean[],Aurigma.GraphicsMill.Transforms.Lut)">
            <summary>Applies tone correction using specified look-up table (LUT).</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="lut"><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance which specifies look-up table for this LUT transform.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoBrightness">
            <summary>Automatically adjusts brightness.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> property set to <b>true</b>).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AutoBrightnessColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AutoBrightnessColorAdjustment"></code></example>
            <overloads><summary>Automatically adjusts brightness.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoBrightness(System.Boolean[])">
            <summary>Automatically adjusts brightness.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> property set to <b>true</b>).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoContrast">
            <summary>Automatically adjusts contrast.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property set to <b>true</b>).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AutoContrastColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AutoContrastColorAdjustment"></code></example>
            <overloads><summary>Automatically adjusts contrast.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoContrast(System.Boolean[])">
            <summary>Automatically adjusts contrast.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property set to <b>true</b>).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels">
            <summary>Automatically applies levels adjustment.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AutoLevelsColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AutoLevelsColorAdjustment"></code></example>
            <overloads><summary>Automatically applies levels adjustment.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(Aurigma.GraphicsMill.HistogramMode)">
            <summary>Automatically applies levels adjustment.</summary>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" />value that specifies how to build histogram.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Boolean[])">
            <summary>Automatically applies levels adjustment.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Boolean[],Aurigma.GraphicsMill.HistogramMode)">
            <summary>Automatically applies levels adjustment.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" />value that specifies how to build histogram.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Double)">
            <summary>Automatically applies levels adjustment using a provided threshold level.</summary>
            <param name="threshold"><para>Threshold level of the automatic level correction algorithm (sensitivity).</para><para>The threshold value is used to define a percent of pixels on edges of the tonal range to discard. Threshold = 1 is 100% of pixels. To get more or less realistic result, use a value less than 1% (0.01). For example: </para><list type="bullet"><item><description>If you want to get a result similar to Photoshop 7, use 0.5% (0.005).</description></item><item><description>If you want a result similar to Photoshop CS or later, use 0.1% (0.001).</description></item></list></param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Double,Aurigma.GraphicsMill.HistogramMode)">
            <summary>Automatically applies levels adjustment using provided threshold level and histogram mode.</summary>
            <param name="threshold"><para>Threshold level of the automatic level correction algorithm (sensitivity).</para><para>The threshold value is used to define a percent of pixels on edges of the tonal range to discard. Threshold = 1 is 100% of pixels. To get more or less realistic result, use a value less than 1% (0.01). For example: </para><list type="bullet"><item><description>If you want to get a result similar to Photoshop 7, use 0.5% (0.005).</description></item><item><description>If you want a result similar to Photoshop CS or later, use 0.1% (0.001).</description></item></list></param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value that specifies how to build the image histogram.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Double,System.Boolean[])">
            <summary>Automatically applies levels adjustment to specified channels using a provided threshold level.</summary>
            <param name="threshold"><para>Threshold level of the automatic level correction algorithm (sensitivity).</para><para>The threshold value is used to define a percent of pixels on edges of the tonal range to discard. Threshold = 1 is 100% of pixels. To get more or less realistic result, use a value less than 1% (0.01). For example: </para><list type="bullet"><item><description>If you want to get a result similar to Photoshop 7, use 0.5% (0.005).</description></item><item><description>If you want a result similar to Photoshop CS or later, use 0.1% (0.001).</description></item></list></param>
            <param name="channels">Array of flags specifying what channels to apply effect at. If an array item is <b>true</b>, the transform will be applied at the channel with the appropriate index. Otherwise the channel is skipped.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.AutoLevels(System.Double,System.Boolean[],Aurigma.GraphicsMill.HistogramMode)">
            <summary>Automatically applies levels adjustment to specified channels using provided threshold level and histogram mode.</summary>
            <param name="threshold"><para>Threshold level of the automatic level correction algorithm (sensitivity).</para><para>The threshold value is used to define a percent of pixels on edges of the tonal range to discard. Threshold = 1 is 100% of pixels. To get more or less realistic result, use a value less than 1% (0.01). For example: </para><list type="bullet"><item><description>If you want to get a result similar to Photoshop 7, use 0.5% (0.005).</description></item><item><description>If you want a result similar to Photoshop CS or later, use 0.1% (0.001).</description></item></list></param>
            <param name="channels">Array of flags specifying what channels to apply effect at. If an array item is <b>true</b>, the transform will be applied at the channel with the appropriate index. Otherwise the channel is skipped.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value that specifies how to build the image histogram.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class to apply this correction (with <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property set to <b>true</b>).
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Brightness(System.Boolean[],System.Single)" draft="yes">
            <summary>Adjusts image brightness.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="amount">Value in range [-1, 1] that specifies brightness modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class to apply this correction.
            </para><para>
              Parameter <i>amount</i> is normalized to 1. Depending on pixel format it is scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <overloads><summary>Adjusts image brightness.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Brightness(System.Single)">
            <summary>Adjusts image brightness.</summary>
            <param name="amount">Value in range [-1, 1] that specifies brightness modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class to apply this correction.
            </para><para>
              Parameter <i>amount</i> is normalized to 1. Depending on pixel format it is scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#BrightnessColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#BrightnessColorAdjustment"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.BrightnessContrast(System.Boolean[],System.Single,System.Single)">
            <summary>Adjusts image brightness and contrast in single pass.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="brightnessAmount">Value in range [-1, 1] that specifies brightness modifier.</param>
            <param name="contrastAmount">Value in range [-1, 1] that specifies contrast modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class to apply this correction.
            </para><para>
              Both <i>brightnessAmount</i> and <i>contrastAmount</i> are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <overloads><summary>Adjusts image brightness and contrast in single pass.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.BrightnessContrast(System.Single,System.Single)">
            <summary>Adjusts image brightness and contrast in single pass.</summary>
            <param name="brightnessAmount">Value in range [-1, 1] that specifies brightness modifier.</param>
            <param name="contrastAmount">Value in range [-1, 1] that specifies contrast modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class to apply this correction.
            </para><para>
              Both <i>brightnessAmount</i> and <i>contrastAmount</i> are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#BrightnessContrastColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#BrightnessContrastColorAdjustment"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.ChannelBalance(System.Single[])">
            <summary>Adjusts balance between color channels (by adding a constant to each channel).</summary>
            <param name="levels">Each entry of array is a value varying in range [-1, 1].</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" /> class to apply this correction.
            </para><para>
              All values from <i>levels</i> parameter are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#ChannelBalanceColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ChannelBalanceColorAdjustment"></code></example>
            <overloads><summary>Adjusts balance between color channels (by adding a constant to each channel).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Contrast(System.Boolean[],System.Single)">
            <summary>Adjusts image contrast.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="amount">Value in range [-1, 1] that specifies contrast modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class to apply this correction.
            </para><para>
              Parameter <i>amount</i> is normalized to 1. Depending on pixel format it is scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <overloads><summary>Adjusts image contrast.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Contrast(System.Single)">
            <summary>Adjusts image contrast.</summary>
            <param name="amount">Value in range [-1, 1] that specifies contrast modifier.</param>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class to apply this correction.
            </para><para>
              Parameter <i>amount</i> is normalized to 1. Depending on pixel format it is scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#ContrastColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ContrastColorAdjustment"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Curves(System.Boolean[],System.Drawing.PointF[])" draft="yes">
            <summary>Applies tone correction using specified curve (analogue to Adobe Photoshop Curves command).</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="points">Array of points used to build the curve.</param>
            <remarks><para>
              Coordinates are normalized on 1. You specify values in range [0, 1] and they are stretched either to [0, 255] or [0, 65535] depending on pixel format (whether it is extended or not). Note, you still can specify values that are out of [0, 1] range, and algorithm automatically truncates the curve. If all points will be strictly inside of this range, algorithm will add points at:
            </para><list type="bullet"><item><description>x equal to 0 and y equal to Y-coordinate of the leftmost point.</description></item><item><description>x equal to 1 and y equal to Y-coordinate of the rightmost point.</description></item></list><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class to apply this correction.
            </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Curves(System.Drawing.PointF[])">
            <summary>Applies tone correction using specified curve (analogue to Adobe Photoshop Curves command).</summary>
            <param name="points">Array of points used to build the curve.</param>
            <remarks><para>
              Coordinates are normalized on 1. You specify values in range [0, 1] and they are stretched either to [0, 255] or [0, 65535] depending on pixel format (whether it is extended or not). Note, you still can specify values that are out of [0, 1] range, and algorithm automatically truncates the curve. If all points will be strictly inside of this range, algorithm will add points at:
            </para><list type="bullet"><item><description>x equal to 0 and y equal to Y-coordinate of the leftmost point.</description></item><item><description>x equal to 1 and y equal to Y-coordinate of the rightmost point.</description></item></list><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class to apply this correction.
            </para></remarks>
            <overloads><summary>Applies tone correction using specified curve (analogue to Adobe Photoshop Curves command).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Desaturate">
            <summary>Desaturates the image.</summary>
            <remarks><para>
              You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> class with <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Saturation" /> = -1 to get the desaturated image.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Desaturate"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Desaturate"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorAdjustmentProvider" />.</summary>
            <overloads><summary>
              Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorAdjustmentProvider" />.
            </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize">
            <summary>Applies histogram equalization to the bitmap. Histogram is taken from the bitmap automatically.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
            <overloads><summary>Applies histogram equalization to the bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize(Aurigma.GraphicsMill.Histogram)">
            <summary>Applies histogram equalization to the bitmap. Histogram is retrieved to this method.</summary>
            <param name="histogram"><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance containing a histogram to equalize. If you want to get histogram from the bitmap automatically, you should use <see cref="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize">overloaded version without this parameter</see>.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize(Aurigma.GraphicsMill.HistogramMode)">
            <summary>Applies histogram equalization to the bitmap. Histogram is calculated automatically (histogram calculation algorithm should be selected).</summary>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> enumeration member that specifies what histogram calculation algorithm to use.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize(System.Boolean[])">
            <summary>Applies histogram equalization to the bitmap. Histogram is taken from the bitmap automatically.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize(System.Boolean[],Aurigma.GraphicsMill.Histogram)">
            <summary>Applies histogram equalization to the bitmap. Histogram is retrieved to this method.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="histogram"><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance containing a histogram to equalize. If you want to get histogram from the bitmap automatically, you should use <see cref="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize">overloaded version without this parameter</see>.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.HistogramEqualize(System.Boolean[],Aurigma.GraphicsMill.HistogramMode)">
            <summary>Applies histogram equalization to the bitmap. Histogram is taken from the bitmap automatically.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> enumeration member that specifies what histogram calculation algorithm to use.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class to apply this correction.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Invert">
            <summary>Inverts all colors of the image.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Invert" /> class to get the negative image.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Invert"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Invert"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Levels(System.Boolean[],System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.HistogramMode)">
            <summary>Applies tone levels correction (the same as Adobe Photoshop Levels effect).</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="minimumLevel">Value in range [0, 1] that specifies minimum output level value.</param>
            <param name="maximumLevel">Value in range [0, 1] that specifies maximum output level value.</param>
            <param name="shadows">Value in range [0, 1] that specifies minimum input shadows level.</param>
            <param name="midtones">Value in range [0.1, 10] that specifies input midtones level.</param>
            <param name="highlights">Value in range [0, 1] that specifies maximum input highlights level.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value that specifies how to build histogram.</param>
            <remarks><para>
              All parameters that specify tone range (<i>minimumLevel</i>, <i>maximumLevel</i>, <i>shadows</i>, and <i>histogram</i>) are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <overloads><summary>Applies tone levels correction (the same as Adobe Photoshop Levels effect).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Levels(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.HistogramMode)">
            <summary>Applies tone levels correction (the same as Adobe Photoshop Levels effect).</summary>
            <param name="minimumLevel">Value in range [0, 1] that specifies minimum output level value.</param>
            <param name="maximumLevel">Value in range [0, 1] that specifies maximum output level value.</param>
            <param name="shadows">Value in range [0, 1] that specifies minimum input shadows level.</param>
            <param name="midtones">Value in range [0.1, 10] that specifies input midtones level.</param>
            <param name="highlights">Value in range [0, 1] that specifies maximum input highlights level.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value that specifies how to build histogram.</param>
            <remarks><para>
              All parameters that specify tone range (<i>minimumLevel</i>, <i>maximumLevel</i>, <i>shadows</i>, and <i>histogram</i>) are normalized to 1. Depending on pixel format they are scaled to 255 or 65355 inside of the method.
            </para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#LevelsColorAdjustment"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#LevelsColorAdjustment"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorAdjustmentProvider.Solarize">
            <summary>Applies solarize effect.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Solarize" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Solarize"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Solarize"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorAdjustmentProvider.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
              When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
            </para><para>
              Default value is -1 (infinite value).
            </para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorChannel">
            <summary>Contains aliases for numbers of color channels.</summary>
            <remarks>You can use it instead of channel indices in such classes as <see cref="T:Aurigma.GraphicsMill.Color" /> (and its descendant classes), <see cref="T:Aurigma.GraphicsMill.ChannelsProvider" />, etc.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Alpha">
            <summary>Alpha channel (for all).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Black">
            <summary>Black channel (for CMYK).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Blue">
            <summary>Blue channel (for RGB).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Cyan">
            <summary>Cyan channel (for CMYK).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Gray">
            <summary>Luminosity channel (for grayscale).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Green">
            <summary>Green channel (for RGB).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Magenta">
            <summary>Magenta channel (for CMYK).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Red">
            <summary>Red channel (for RGB).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorChannel.Yellow">
            <summary>Yellow channel (for CMYK).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorManagementProvider" draft="yes">
            <summary>This class contains methods and properties used by <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to provide color management and color conversion.</summary>
            <remarks><para>
              This class is accessible from <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorManagement" /> property of <see cref="T:Aurigma.GraphicsMill.Bitmap" />. You should use it if you need <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to apply color management during color conversions, drawing, and other operations where it is applicable.
            </para><para>
              To choose the color management engine, you should use property <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.ColorManagementEngine" />. You can specify such color management parameters as output profiles for each color space (<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.GrayScaleColorProfile" />, <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.RgbColorProfile" /> properties), profile for target device to produce chain color management (<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.TargetColorProfile" /> property). A color management intent parameter is accessible through <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.TransformationIntent" /> property.
            </para><para>
              After you set color management up, you can apply color conversions. This class applies two different kinds of color conversion: conversion to indexed pixel formats (color reduction) and conversion to continuous ones.
            </para></remarks>
            <example><para>This sample reduces the number of colors to 64:</para><code language="VB" source="ColorConversionVB/form1.vb#Gif64ErrorDiffusion"></code><code language="CS" source="ColorConversionCS/form1.cs#Gif64ErrorDiffusion"></code><para>Here is a code which applies the conversion between RGB and CMYK:</para><code language="VB" source="ColorConversionVB/form1.vb#RGBtoCMYKWithCM"></code><code language="CS" source="ColorConversionCS/form1.cs#RGBtoCMYKWithCM"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.BuildAdaptivePaletteWithAlpha">
            <summary>Gets/sets a value which specifies whether the alpha channel should be taken into account when building an adaptive palette.</summary>
            <value>Value which specifies whether the alpha channel should be taken into account. If <b>true</b>, alpha channel will be added to the palette if necessary.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.CmykColorProfile">
            <summary>Gets/sets output CMYK color profile.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output CMYK color profile.</value>
            <remarks>This color profile must support CMYK color space. If you try to set profile for another color space, exception will be raised.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.ColorManagementEngine" draft="yes">
            <summary>Gets/sets color management engine (module) which will be used during image transformation. Graphics Mill for .NET supports the following engines: LittleCMS and Adobe CMM. The property also allows to disable color management and perform transformation without color matching.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorManagementEngine" /> value specifying color management engine.</value>
            <remarks><para>Color management will be applied during transformation of image between color formats in case if all the following conditions are met:</para><list type="number"><item><description>This property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.LittleCms" /> or
<see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.AdobeCmm" />.</description></item><item><description><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which needs to be transformed has <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorProfile" /> initialized with correct color profile (e.g. it is embedded color profile loaded from image file, or this property was initialized after the image has been loaded).</description></item><item><description>An output color profile is also initialized. Depending on color space use <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.RgbColorProfile" />, or <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.GrayScaleColorProfile" /> properties. For example, if you need to translate image to CMYK color space, you need to set <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.CmykColorProfile" /> up with appropriate CMYK profile; if destination color space is RGB, <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.RgbColorProfile" /> property should be initialized etc.</description></item></list><para>If you do not need to apply color management during image transformation, set this property to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />.</para></remarks>
            <seealso href="ConvertingColorswiththeColorManagement.htm" />
<seealso href="UsingAdobeCMMwithGraphicsMill.htm" />
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.ColorQuantizationAlgorithm">
            <summary>Gets/sets a color quantiztion algorithm used to reduce colors.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm" /> value specifying the quantiztion algorithm used during color reduction.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.Convert(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Converts bitmap to specified pixel format.</summary>
            <param name="format">Target pixel format.</param>
            <remarks>During conversion it uses default conversion parameters such as dithering, palette type, etc. If you need more control (e.g. specify another dithering settings or provide custom palette), use the <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> object directly.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.ConvertToContinuous(Aurigma.GraphicsMill.ColorSpace,System.Boolean,System.Boolean)">
            <summary>Applies color conversion between various color spaces.</summary>
            <param name="colorSpace"><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value specifying target color space.</param>
            <param name="hasAlpha">Value specifying if to add (or remove) alpha channel. <note>If you pass <b>false</b> and current pixel format has alpha channel, Graphics Mill for .NET will not flatten alpha channel with image. It will just remove it. So if you need to flatten alpha channel with some color, you should use <see cref="M:Aurigma.GraphicsMill.ChannelsProvider.DiscardAlpha(Aurigma.GraphicsMill.Color)" /> method first.</note></param>
            <param name="isExtended">Value specifying if to convert to the extended pixel format (16 bits per channel).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.ConvertToIndexed(System.Int32,Aurigma.GraphicsMill.ColorPaletteType,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Applies color reduction to indexed pixel formats.</summary>
            <param name="bpp">Value specifying necessary bits per pixel. Valid values are 1, 4, and 8.</param>
            <param name="paletteType"><see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> value specifying how to generate palette.</param>
            <param name="customPalette"><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance which is used when <i>paletteType</i> is <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Custom" />.</param>
            <remarks>If you use this overload, <see cref="F:Aurigma.GraphicsMill.Transforms.DitheringType.FloydSteinberg" /> dithering algorithm will be always used.</remarks>
            <overloads><summary>Applies color reduction to indexed pixel formats.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorManagementProvider" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorManagementProvider" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.Dithering">
            <summary>Gets/sets a dithering algorithm used to emulate missing halftones.</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.Transforms.DitheringType" /> value specifying the dithering algorithm used during color reduction to emulate missing halftones.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.DitheringIntensity">
            <summary>Gets/sets dithering intensity.</summary>
            <value>A value in range [0, 1] specifying dithering intensity.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorManagementProvider.EnableColorManagementForHdc(System.IntPtr,System.Boolean)">
            <summary>Enables or disables color management for specified device context.</summary>
            <param name="hdc">Handle to device context.</param>
            <param name="enable">Value specifying if to enable or disable color management for this device context.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.GrayScaleColorProfile">
            <summary>Gets/sets output grayscale color profile.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output grayscale color profile.</value>
            <remarks>This color profile must support grayscale color space. If you try to set profile for another color space, exception will be raised.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.PaletteAlphaThreshold">
            <summary>Gets/sets a value which specifies the alpha threshold.</summary>
            <value>Threshold value.</value>
            <remarks><para>When building a palette during color reduction for an image which should be saved to GIF, you need to have only one transparent color. However during color reduction you may get a number of colors with a different level of transparency. To avoid this, use this property. All alpha channel values which are greater or equal to this value will be changed to 255 (fully opaque), otherwise it will be 0.
</para><note>If the <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.PaletteAlphaThresholdUsed" /> property is <b>false</b>, alpha threshold is not used, and therefore the palette may contain more than one transparent or semitransparent entry. Also, this value is disregarded if the <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.BuildAdaptivePaletteWithAlpha" /> property is set to <b>false</b> (i.e. alpha channel is ignored during color reduction).</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.PaletteAlphaThresholdUsed">
            <summary>Gets/sets a value which specifies whether the alpha threshold should be used when building an adaptive palette.</summary>
            <value>Value which specifies whether to apply alpha channel threshold.</value>
            <remarks><para>If the value of this property is <b>true</b>, and the value of the <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.BuildAdaptivePaletteWithAlpha" /> property is also <b>true</b>, then all alpha channel values will come to 0 or 255 depending on the <see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.PaletteAlphaThreshold" /> property value.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.PaletteEntryCount">
            <summary>Gets/sets the maximum number of colors in palette that should be used when performing conversion to an indexed pixel format.</summary>
            <value>A value that specifies the maximum number of entries in palette used when performing conversion to an indexed pixel format. If this value is 0, the algorithm automatically uses the maximum possible value for the target pixel format (see the <b>Remarks</b> section).</value>
            <remarks><para>When <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" />, this value should be equal or less 256. For the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format4bppIndexed" /> pixel format, 16 or less colors can be used. For <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format1bppIndexed" />, only 2 colors can be specified.</para><para>If you specify more colors than the palette supports, an exception will be raised.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bBitsUsed">
            <summary>Gets/sets the number of bits which are in fact used for this channel.</summary>
            <value>Number of bits used for the channel.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bOffset">
            <summary>Gets/sets the offset on which intensity of a pixel will be calculated.</summary>
            <value>Offset on which intensity of a pixel will be calculated.</value>
            <remarks><para>Any pixel intensity that is below the offset value is set to black. Any pixel intensity that is above <c>(<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bOffset" /> + (2^<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bScale" />))</c> is set to white. All remaining pixels therefore lie within the range 0 to 2^scale.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bScale">
            <summary>Gets/sets the range in which pixel intensity values will vary.</summary>
            <value>Scale which specifies the range of available pixel intensity values.</value>
            <remarks><para>Any pixel intensity that is below the offset value is set to black. Any pixel intensity that is above <c>(<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bOffset" /> + (2^<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bScale" />))</c> is set to white. All remaining pixels therefore lie within the range 0 to 2^scale.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.RgbColorProfile">
            <summary>Gets/sets output RGB color profile.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output RGB color profile.</value>
            <remarks>This color profile must support RGB color space. If you try to set profile for another color space, exception will be raised.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.TargetColorProfile">
            <summary>Gets/sets target device profile used for chain transformations.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying color profile of the target device.</value>
            <remarks>This profile is used to preview on one device how the image will be looking at another one. For example, let's assume you want to display on the screen how the image will be looking after being printed by specific printer. In this case set:
<list type="number"><item><term>Output profile (<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.RgbColorProfile" /> property)</term><description>to monitor profile.</description></item><item><term>Target device profile (<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.TargetColorProfile" /> property)</term><description>to printer profile.</description></item></list></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorManagementProvider.TransformationIntent">
            <summary>Gets/sets color management intent which defines gamut mapping method.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent" /> value specifying color management intent.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorPalette">
            <summary>This class represents palette, i.e. an array of color values. Used in indexed bitmaps.</summary>
            <remarks><para>Color palettes are used in indexed bitmaps to store colors. Each pixel of the indexed bitmap is an index you should pass to <see cref="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)" /> to get an actual color this pixel represents. These indices should not exceed total number of palette entries which you can get through <see cref="P:Aurigma.GraphicsMill.ColorPalette.Count" /> property.</para><para>You can <see cref="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.ColorPaletteType,System.Boolean)">create a predefined palette</see>, or <see cref="M:Aurigma.GraphicsMill.ColorPalette.#ctor(System.Int32,System.Boolean)">create an empty one</see>, and then import colors from array using <see cref="M:Aurigma.GraphicsMill.ColorPalette.Import(Aurigma.GraphicsMill.RgbColor[])" /> method. You can also export the palette into array using <see cref="M:Aurigma.GraphicsMill.ColorPalette.Export" /> method. </para><para>Since the palettes never store more than 256 entries, only few of 16 millions 24-bit RGB colors are available in the palette. That's why if you need change a color of some pixel, you cannot pass arbitrary color. You should find nearest color in the palette and pass its index instead. To convert the color into index in this palette, you can use <see cref="M:Aurigma.GraphicsMill.ColorPalette.FindNearestIndex(Aurigma.GraphicsMill.RgbColor)" /> method. Note, this method works quite slow, that's why you should cache nearest index if possible. </para><para>
              Graphics Mill for .NET fully supports palette entries with alpha channels. It means that if you put semi-transparent entries, they will be drawn and processed properly. However not all file formats support alpha channel in palettes. In particular GIF format can have only one transparent entry (so-called key color). That's why in such cases only first entry with zero alpha channel will be treated as transparent. So if you need to set transparent index of GIF file, you should use <see cref="M:Aurigma.GraphicsMill.ColorPalette.SetColorKey(System.Int32)" /> method instead of modifying alpha channel of the entry. </para></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#GeneratePredefined"></code><code language="CS" source="ColorConversionCS/form1.cs#GeneratePredefined"></code></example>
            <seealso cref="P:Aurigma.GraphicsMill.Bitmap.Palette" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.Clone">
            <summary>Creates a full copy of the palette.</summary>
            <returns>A <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> object containing full copy of current object.</returns>
            <example><code language="VB" source="ColorConversionVB/form1.vb#ClonePalette"></code><code language="CS" source="ColorConversionCS/form1.cs#ClonePalette"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorPalette.Count">
            <summary>Returns a number of colors in the palette.</summary>
            <value>Palette entries count.</value>
            <remarks>A number of colors in palette depends on the color depth of the image where it is used. 1-bit bitmaps can have only 2 colors, 4-bit bitmaps - 16 colors, 8-bit bitmaps - 256 colors. 8 bit is a maximum bit depth for indexed images, so this property never exceed 256.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorPalette" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorPalette" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.Export">
            <summary>Exports the palette into array of <see cref="T:Aurigma.GraphicsMill.RgbColor" /> values.</summary>
            <returns>Array of <see cref="T:Aurigma.GraphicsMill.RgbColor" /> values.</returns>
            <example><code language="VB" source="ColorConversionVB/form1.vb#ExportToArray"></code><code language="CS" source="ColorConversionCS/form1.cs#ExportToArray"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.FindNearestIndex(Aurigma.GraphicsMill.RgbColor)">
            <summary>Searches index of the color closest to given one.</summary>
            <param name="color">Color value to find.</param>
            <returns>Index of the palette entry which is closest to given color value.</returns>
            <example><code language="VB" source="ColorConversionVB/form1.vb#FindNearestIndex"></code><code language="CS" source="ColorConversionCS/form1.cs#FindNearestIndex"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.GetEnumerator">
            <summary>Returns an enumerator for the palette entries allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorPalette.HasAlpha">
            <summary>Indicates if palette support transparency.</summary>
            <value>Value indicating if palette entries support alpha channel (information about pixel transparency).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.Import(Aurigma.GraphicsMill.RgbColor[])">
            <summary>Imports the palette from array of <see cref="T:Aurigma.GraphicsMill.RgbColor" /> values.</summary>
            <param name="array">Array of <see cref="T:Aurigma.GraphicsMill.RgbColor" /> values containing new entries for the palette. Note, array must have the same dimension as the palette (i.e. number of array elements must equal to <see cref="P:Aurigma.GraphicsMill.ColorPalette.Count" /> property of this palette).</param>
            <example>#CODE_VB_ColorConversionVB/form1.vb#ImportFromArray_CODE# #CODE_C#_ColorConversionCS/form1.cs#ImportFromArray_CODE#</example>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)">
            <summary>Gets/sets palette entry by index.</summary>
            <param name="itemIndex">Entry index you want to retrieve. It should vary in range [0, <see cref="P:Aurigma.GraphicsMill.ColorPalette.Count">entries count</see> - 1].</param>
            <value>Color value stored in the palette by given index.</value>
            <example><code language="VB" source="ColorConversionVB/form1.vb#Entries"></code><code language="CS" source="ColorConversionCS/form1.cs#Entries"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.Bitmap,System.Boolean)" draft="yes">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. Colors of this palette are generated from the specified bitmap.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance for which optimal palette is built.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm,System.Int32)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> instance. Colors of this palette are generated from the specified bitmap.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance for which an optimal palette is built.</param>
            <param name="entryCount">Number of colors in the palette.</param>
            <param name="quantizationAlgorithm">Color quantiztion algorithm used to reduce colors.</param>
            <param name="paletteAlphaThreshold">Value which specifies the alpha channel threshold.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. Colors of this palette are generated from the specified bitmap.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance for which optimal palette is built.</param>
            <param name="entryCount">Number of colors in the palette.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Boolean,Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm)">
            <summary>Creates and initializes a new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> instance. Colors of this palette are generated from the specified bitmap.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> instance for which an optimal palette is built.</param>
            <param name="entryCount">Number of colors in the palette.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
            <param name="quantizationAlgorithm">Color quantiztion algorithm used to reduce colors.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.ColorPaletteType,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. You can set palette type here.</summary>
            <param name="colorPaletteType"><see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> value that indicates palette type.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(Aurigma.GraphicsMill.RgbColor[],System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. You can initialize palette with given array entries here.</summary>
            <param name="entries">Array of colors to initialize the palette with.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(System.Int32,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. You can specify how much entries the palette should have.</summary>
            <param name="entryCount">Number of colors in the palette.</param>
            <param name="hasAlpha">Value indicating if palette entries should support alpha channel (information about pixel transparency).</param>
            <remarks>All entries of the palette created with this constructor will have the same color value (black). So you need fill the palette entries yourself using <see cref="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.#ctor(System.Drawing.Imaging.ColorPalette)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance. The palette is copied from specified <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> object.</summary>
            <param name="palette"><see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> class instance to copy color values from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.op_Implicit(Aurigma.GraphicsMill.ColorPalette)~System.Drawing.Imaging.ColorPalette" draft="yes">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.ColorPalette">Aurigma.GraphicsMill.ColorPalette</see> class instance to <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see>.</summary>
            <param name="palette"><see cref="T:Aurigma.GraphicsMill.ColorPalette">Aurigma.GraphicsMill.ColorPalette</see> class instance to cast.</param>
            <returns>Palette casted to <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see>.</returns>
            <overloads><summary>Casts this <see cref="T:Aurigma.GraphicsMill.ColorPalette">Aurigma.GraphicsMill.ColorPalette</see> class instance to <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.op_Implicit(System.Drawing.Imaging.ColorPalette)~Aurigma.GraphicsMill.ColorPalette">
            <summary>Casts this <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> class instance to <see cref="T:Aurigma.GraphicsMill.ColorPalette">Aurigma.GraphicsMill.ColorPalette</see>.</summary>
            <param name="palette"><see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> class instance to cast.</param>
            <returns>Palette casted to <see cref="T:Aurigma.GraphicsMill.ColorPalette">Aurigma.GraphicsMill.ColorPalette</see>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.SetColorKey(Aurigma.GraphicsMill.RgbColor)" draft="yes">
            <summary>Makes palette entry closest to given color transparent.</summary>
            <param name="color">Color which should be transparent in the bitmap.</param>
            <remarks><para>Alpha channel of given entry will be dropped to 0, alpha channels of all other entries will be set to 255. This way palette will contain only the single transparent index. This way palette will contain only the single transparent index. If you need more than one transparent entry, put transparent <see cref="T:Aurigma.GraphicsMill.RgbColor" /> into appropriate <see cref="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)" />.</para><para>
This method can be treated as analogue of <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" /> transform for non-indexed image.
</para><note type="implementnotes">
Setting transparent index works noticeable faster than setting transparent color (which actually calls slow <see cref="M:Aurigma.GraphicsMill.ColorPalette.FindNearestIndex(Aurigma.GraphicsMill.RgbColor)" /> method). That's why it is highly recommended to pass index instead of color where possible.
</note></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#SetTransparentColor"></code><code language="CS" source="ColorConversionCS/form1.cs#SetTransparentColor"></code></example>
            <overloads><summary>Makes palette entry.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.SetColorKey(System.Int32)">
            <summary>Makes palette entry with given index transparent.</summary>
            <param name="entryIndex">Index of the palette entry to make transparent.</param>
            <remarks><para>Alpha channel of given entry will be dropped to 0, alpha channels of all other entries will be set to 255. This way palette will contain only the single transparent index. If you need more than one transparent entry, put transparent <see cref="T:Aurigma.GraphicsMill.RgbColor" /> into appropriate <see cref="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)" />.</para><note type="implementnotes">
Setting transparent index works noticeable faster than setting transparent color (which actually calls slow <see cref="M:Aurigma.GraphicsMill.ColorPalette.FindNearestIndex(Aurigma.GraphicsMill.RgbColor)" /> method). That's why it is highly recommended to pass index instead of color where possible.
</note></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#SetTransparentIndex"></code><code language="CS" source="ColorConversionCS/form1.cs#SetTransparentIndex"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPalette.ToGdiplusColorPalette">
            <summary>Converts current palette to <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see> class which can be used in native .NET drawing classes.</summary>
            <returns>Copy of the palette converted to <see cref="T:System.Drawing.Imaging.ColorPalette">System.Drawing.Imaging.ColorPalette</see>.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorPalette.Type">
            <summary>Indicates how palette was created - either as some predefined palette or custom one.</summary>
            <value>Value indicating palette type.</value>
            <remarks>If you load any predefined palette, and change any entry (using <see cref="P:Aurigma.GraphicsMill.ColorPalette.Item(System.Int32)" /> property), palette type is set to <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Custom" />.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorPaletteEmptyException" draft="yes">
            <summary>This exception is thrown when you try to operate with empty palette (which is either <b>null</b> or has no any entries).</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPaletteEmptyException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ColorPaletteEmptyException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ColorPaletteEmptyException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPaletteEmptyException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ColorPaletteEmptyException" /> class with a specified error message.</summary>
            <param name="name">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPaletteEmptyException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ColorPaletteEmptyException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorPaletteEmptyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorPaletteType">
            <summary>Contains palette types used when generating palettes.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.Adaptive">
            <summary>Adaptive algorithm of palette matching.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.Bicolor">
            <summary>Black and white palette (predefined).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.Custom">
            <summary>Custom palette.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.GrayScale">
            <summary>Grayscale palette (predefined).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.Mac">
            <summary>Mac palette (predefined).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.WebSafe">
            <summary>WebSafe palette (predefined).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorPaletteType.Windows">
            <summary>Windows palette (predefined).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorProfile" draft="yes">
            <summary>This class represents ICC color profile used to provide color management.</summary>
            <remarks><para>This class encapsulates ICC color profile. Typically it is used as a parameter in color management classes/methods, however it also has a number of useful properties that allow obtaining extra details about the profile. In particular, you can get metainformation such as <see cref="P:Aurigma.GraphicsMill.ColorProfile.Copyright" />, <see cref="P:Aurigma.GraphicsMill.ColorProfile.Description" />, <see cref="P:Aurigma.GraphicsMill.ColorProfile.DeviceClass" /> (a device kind the profile is intended for), <see cref="P:Aurigma.GraphicsMill.ColorProfile.Info" />,  <see cref="P:Aurigma.GraphicsMill.ColorProfile.Manufacturer" />, <see cref="P:Aurigma.GraphicsMill.ColorProfile.Model" />, and <see cref="P:Aurigma.GraphicsMill.ColorProfile.Name" />. Also, you can get a <see cref="P:Aurigma.GraphicsMill.ColorProfile.ColorSpace" /> profile is made for. Static property <see cref="P:Aurigma.GraphicsMill.ColorProfile.ProfileDirectory" /> returns a system folder where all profiles should be stored.</para><para>You can create <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance in three ways: 
</para><list type="number"><item><term><see cref="M:Aurigma.GraphicsMill.ColorProfile.#ctor(System.String)">Constructor</see></term><description>creates a <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance from specified file. </description></item><item><term><see cref="M:Aurigma.GraphicsMill.ColorProfile.FromScreen" /></term><description>creates a <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance from the color profile associated with monitor.</description></item><item><term><see cref="M:Aurigma.GraphicsMill.ColorProfile.FromSrgb" /></term><description>Creates a <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance from  a standard sRGB color profile.</description></item></list></remarks>
            <example><code language="VB" source="ColorConversionVB/form1.vb#RGBtoCMYKWithCM"></code><code language="CS" source="ColorConversionCS/form1.cs#RGBtoCMYKWithCM"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.Clone">
            <summary>Returns a full copy of this <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> instance.</summary>
            <returns>An object which contains full copy of this color profile.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.ColorSpace">
            <summary>Indicates color space current profile designed for.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value indicating color space of the profile.</value>
            <remarks>It is important for color profile to match appropriate color space when converting image between color spaces. This way you cannot use, say, RGB profile to convert to CMYK.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Copyright">
            <summary>Gets copyright information stored in the color profile.</summary>
            <value>The string that contains copyright information stored in the color profile.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Description">
            <summary>Gets the profile description.</summary>
            <value>The string that contains the profile descriptions.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.DeviceClass">
            <summary>Gets profile device class (i.e. what kind of devices it is intended for).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfileClass" /> value that indicates a profile device class.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorProfile" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.ColorProfile" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.FileName">
            <summary>Returns color profile file name.</summary>
            <value>A string containing color profile file name.</value>
            <remarks><para>Color profile always has file name even if you work with embedded profile. In this case profile is copied to temporary file and its name is returned.
</para><note>
When you attach color profile to the <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorProfile">Bitmap.ColorProfile</see>, profile file will be copied to temporary folder. That's why file name returned by this property and file name returned by <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorProfile">Bitmap.ColorProfile</see> will differ.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.FromHdc(System.IntPtr)">
            <summary>Returns color profile associated with the specified device context.</summary>
            <param name="hdc">Handle to device context.</param>
            <returns>Color profile associated with the device context.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.FromScreen">
            <summary>Returns color profile associated with the monitor.</summary>
            <returns>Color profile associated with the monitor.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.FromSrgb">
            <summary>Creates <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance from standard sRGB color profile.</summary>
            <returns>Color profile based on standard sRGB profile.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Info">
            <summary>Gets the additional profile details.</summary>
            <value>The string that contains the additional profile details.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Manufacturer">
            <summary>Gets the device manufacturer name.</summary>
            <value>The string that contains the device manufacturer name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Model">
            <summary>Gets the device model name.</summary>
            <value>The string that contains the device model name.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.Name">
            <summary>Gets the profile name.</summary>
            <value>The string that contains the profile name.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.#ctor(System.String)">
            <summary>Creates <see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance from given file.</summary>
            <param name="fileName">File name of the profile.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.ColorProfile.ProfileDirectory">
            <summary>Returns a name of the standard Windows folder which stores color profiles.</summary>
            <value>Path to the standard Windows folder containing color profiles.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.Save(System.String)">
            <summary>Saves the color profile to specified file.</summary>
            <param name="fileName">The string which specifies the name of the output file.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ColorProfile.Save(System.IO.Stream)" draft="yes">
            <summary>Saves the color profile to specified <see cref="T:System.IO.Stream" />.</summary>
            <param name="stream">The output <see cref="T:System.IO.Stream" /> object.</param>
            <overloads><summary>Saves the color profile to specified <see cref="T:System.IO.Stream" /> or file.</summary></overloads>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorProfileClass">
            <summary>Contains possible values for profile device class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Abstract">
            <summary>Abstract profile. These profiles are adjusted to suit a user's particular preferences.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.ColorSpace">
            <summary>Color space profiles. These profiles describe a device-independent color space.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Display">
            <summary>Display profiles. This category of profiles includes all the profiles accosiated with display.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Input">
            <summary>Input profiles. This category of profiles includes all the profiles accosiated with input, e.g. scanners.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Link">
            <summary>Device link profile. These profiles describe the color space of a particular device.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.NamedColor">
            <summary>Named color profile. These profiles are intended for a color space that consists of named colors.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Output">
            <summary>Output profiles. This category of profiles includes all the profiles accosiated with hardcopy output, e.g. printers.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorProfileClass.Unknown">
            <summary>Unsupported kind of color profiles.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ColorSpace">
            <summary>Contains color spaces supported with Graphics Mill for .NET.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorSpace.Cmyk">
            <summary>CMYK.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorSpace.GrayScale">
            <summary>Grayscale.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorSpace.Rgb">
            <summary>RGB</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.ColorSpace.Unknown">
            <summary>Undefined color space (returned when bitmap is not initialized).</summary>
        </member>
        <member name="N:Aurigma.GraphicsMill.Drawing" draft="yes">
            <summary>The <see cref="N:Aurigma.GraphicsMill.Drawing" /> namespace contains classes intended to: draw lines, curves, shapes and outlined text; use various pens and brushes to outline and fill shapes.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.Brush">
            <summary>Base class for Graphics Mill for .NET brushes.</summary>
            <remarks><para>This class is abstract, so you cannot directly instantiate it. You should create some of derived classes (e.g. <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> or <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" />). You can also cast some brush classes from <see cref="N:System.Drawing">System.Drawing</see> namespace (and vice versa). </para><para>
You can get an invisible brush (which actually do nothing) using <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> property. To check whether the brush is empty, use property <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.IsEmpty" />.
</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Brush.Empty">
            <summary>Returns an empty brush (which does not fill anything).</summary>
            <value>An empty brush.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Brush.IsEmpty">
            <summary>Indicates if the brush is empty.</summary>
            <value>Values specifying if the brush is empty.</value>
            <remarks>Empty brushes do not fill anything.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Brush.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Brush.op_Implicit(Aurigma.GraphicsMill.Drawing.Brush)~System.Drawing.Brush" draft="yes">
            <summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.Brush">Aurigma.GraphicsMill.Drawing.Brush</see> to <see cref="T:System.Drawing.Brush">System.Drawing.Brush</see>.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush">Aurigma.GraphicsMill.Drawing.Brush</see> instance to cast.</param>
            <returns>Brush casted to <see cref="T:System.Drawing.Brush">System.Drawing.Brush</see>.</returns>
            <overloads><summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.Brush">Aurigma.GraphicsMill.Drawing.Brush</see> to <see cref="T:System.Drawing.Brush">System.Drawing.Brush</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Brush.op_Implicit(System.Drawing.Brush)~Aurigma.GraphicsMill.Drawing.Brush">
            <summary>Casts an instance of <see cref="T:System.Drawing.Brush">System.Drawing.Brush</see> to <see cref="T:Aurigma.GraphicsMill.Drawing.Brush">Aurigma.GraphicsMill.Drawing.Brush</see>.</summary>
            <param name="brush"><see cref="T:System.Drawing.Brush">System.Drawing.Brush</see> value which is being casted.</param>
            <returns>Brush casted to <see cref="T:Aurigma.GraphicsMill.Drawing.Brush">Aurigma.GraphicsMill.Drawing.Brush</see> class.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Brush.ToGdiplusBrush">
            <summary>Converts the brush to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</summary>
            <returns>Brush converted to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Brush.Type">
            <summary>Returns brush type.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.BrushType" /> value specifying type of the brush.</value>
            <remarks>Each class derived from <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> has its own type.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.BrushType">
            <summary>Contains possible brush types supported by <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. Brush type is a way of how Graphics Mill for .NET should fill shapes: with solid color, hatched pattern, etc.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.BrushType.Hatch">
            <summary>Hatched fill (based on pattern).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.BrushType.Solid">
            <summary>Solid fill.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.Charset">
            <summary>Contains values specifying charsets.</summary>
            <remarks>As usual you should use default charset (which uses charset used in system), but if you have problems with internationalization of your application, you may need to use specific charsets.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Ansi">
            <summary>ANSI charset. Used in the United States and Western Europe.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Arabic">
            <summary>Arabic charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Baltic">
            <summary>Baltic charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.ChineseBig5">
            <summary>Chinese BIG5 charset. Used in Taiwan (Traditional Chinese characters).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Default">
            <summary>Default charset. Actual charset is taken from system settings.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.EastEurope">
            <summary>East Europe charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Gb2312">
            <summary>GB2312 charset. Used in mainland China (Simplified Chinese characters).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Greek">
            <summary>Greek charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Hangul">
            <summary>Hangul charset. Used in Korea (Wansung).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Hebrew">
            <summary>Hebrew charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Johab">
            <summary>Johab charset. Used in Korea (Johab).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Mac">
            <summary>Macintosh charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Oem">
            <summary>OEM charset. Depends on the codepage of the operating system. The same charset is used by MS-DOS.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Russian">
            <summary>CharsetRussianCyrillic charset. Used in Russia, Belarus, Ukraine and some other slavic countries.
Cyrillic charset. Used in Russia, Belarus, Ukraine and some other slavic countries.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.ShiftJis">
            <summary>Shift-JIS (Japanese Industry Standard) charset. Used in Japan.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Symbol">
            <summary>Standard symbol charset. Used to display such fonts as Symbol or Wingdings.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Thai">
            <summary>Thai charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Turkish">
            <summary>Turkish charset.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Charset.Vietnamese">
            <summary>Vietnamese charset.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.Font">
            <summary>This class accumulates font and other text rendering settings. It also provides functionality for retrieving font metrics, and other font-related information.</summary>
            <remarks>You can use this class for two intentions. 
<list type="number"><item><description>First of all, you can set text rendering parameters here. These settings are used to draw the text or on window. This way you can specify font <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />, make it <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Bold" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Italic" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Underline" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Strikeout" />, etc. You can also adjust text rendering quality by using <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property. Using <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties you specify how to locate text relatively drawing coordinates. </description></item><item><description>Another application of this class is to accomplish text measurement. It is often important to know how much room text string with given settings will occupy. Method <see cref="M:Aurigma.GraphicsMill.Drawing.Font.MeasureString(System.String)" /> provides easy way to do it. Just fill necessary properties, and this method returns width and height of the text. If you need to know individual positions of each character in the text string, you can use <see cref="M:Aurigma.GraphicsMill.Drawing.Font.GetCharacterPositions(System.String,System.Single)" /> method. If you need more advanced calculations, this class provides you a number of font metrics, like <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Ascent" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Descent" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.AverageCharWidth" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.ExternalLeading" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Font.InternalLeading" />, and others. </description></item></list><para>
All space values (like font metrics, font size, etc) are returned in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased">
            <summary>Gets/sets value specifying if text should be antialiased.</summary>
            <value>The value specifying if text should be antialiased.</value>
            <remarks><para>Antialiased text is looking smooth, displayed with high quality. However it works slower than displaying text without antialiasing. </para><para>Antialiasing can be applied only to full-color bitmaps. When drawing on indexed bitmaps, antialiasing cannot be used by its nature.</para><note>If the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note><para>
Default value is <b>true</b>. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Ascent">
            <summary>Returns ascent of the current font.</summary>
            <value>Font ascent.</value>
            <remarks>Ascent is a maximum distance characters in this font extend above the base line.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontAscent"></code><code language="CS" source="DrawingCS/form1.cs#FontAscent"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.AverageCharWidth">
            <summary>Returns an average character width of the current font.</summary>
            <value>Average character width of the current font.</value>
            <remarks>As usual it is defined as a width of character "x". This value does not include the overhang required for bold or italic characters.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Bold">
            <summary>Gets/sets value specifying if font is bold.</summary>
            <value>Value specifying if font is bold.</value>
            <remarks>Default value is <b>false</b>.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.ClearType">
            <summary>Gets/sets value specifying if to use ClearType antialiasing for fonts (optimized for LCD monitors).</summary>
            <value>Value specifying if to use ClearType during text rendering.</value>
            <remarks>The following situations do not support ClearType antialiasing: 
<list type="bullet"><item><description>
Text rendered on a printer.
</description></item><item><description>
A display set for 256 colors or less.
</description></item><item><description>
Text rendered to a terminal server client.
</description></item><item><description>
The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType 
outlines, bitmap fonts, vector fonts, and device fonts.
</description></item><item><description>
The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.
</description></item></list><para>
Default value is <b>false</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object containing full copy of the current object.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.CreateSpecificFont(System.String,System.Boolean,System.Single)">
            <summary>Returns a font with the requested name.</summary>
            <param name="fontName">Name of the font installed on the computer.</param>
            <param name="postScriptName">A value that specifies if <paramref name="fontName" /> is in the PostScript format.</param>
            <param name="size">Size of the requested font.</param>
            <returns>Requested font or <b>null</b> if no font with the <paramref name="fontName" /> name can be found.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Descent">
            <summary>Returns descent of the current font.</summary>
            <value>Font descent.</value>
            <remarks>Descent is a maximum distance characters in this font extend below the base line.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontDescent"></code><code language="CS" source="DrawingCS/form1.cs#FontDescent"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Drawing.Font" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Drawing.Font" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.EmHeight">
            <summary>Returns em height of the font (also known as em square or em size).</summary>
            <value>Em height of the font.</value>
            <remarks>This parameter means size of the glyphs in design units. Width and height of the glyph are always the same, that's why sometimes it is called em square.
<para>
Typically this size is divisible to 1024 (usually 1024 or 2048).
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontEmSquare"></code><code language="CS" source="DrawingCS/form1.cs#FontEmSquare"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.ExternalLeading">
            <summary>Returns external leading of the current font.</summary>
            <value>External leading of the current font.</value>
            <remarks>This value specifies the amount of extra leading (space) that the application adds between rows. The font designer may set this value to zero.</remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightBold">
            <summary>Bold weight. Always 700.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightDontCare">
            <summary>Default weight. Always 0.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightExtrabold">
            <summary>Extra bold weight. Always 800.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightExtraLight">
            <summary>Extra light weight. Always 200.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightHeavy">
            <summary>Heavy weight. Always 900.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightLight">
            <summary>Light weight. Always 300.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightMedium">
            <summary>Medium weight. Always 500.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightNormal">
            <summary>Normal weight. Always 400.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightSemibold">
            <summary>Semibold weight. Always 600.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightThin">
            <summary>Thin weight. Always 100.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.GdiCharset">
            <summary>Gets/sets charset for displaying non-Unicode characters.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.Charset" /> value specifying string charset.</value>
            <remarks>You can use this property in cases when you have non-Unicode text string (for example, taken from legacy software or database) and need to display it correctly. Otherwise you should not change this property. 
<para>
Default value is <see cref="F:Aurigma.GraphicsMill.Drawing.Charset.Default" /> (i.e. charset depends on locale settings). 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetA(System.Char)">
            <summary>Returns A spacing from ABC metric for given character.</summary>
            <param name="symbol">Character to retrieve A spacing for.</param>
            <returns>Value containing A spacing from ABC metrics for given character.</returns>
            <remarks>ABC metric is defined for TrueType fonts in the following way: 
<list type="bullet"><item><term>
A spacing 
</term><description>
the distance to add to the current position before drawing the character glyph.
</description></item><item><term>
B spacing
</term><description>
the width of the drawn portion of the character glyph.
</description></item><item><term>
C spacing
</term><description>
the distance to add to the current position to provide white space to the right of the character glyph.
</description></item></list>
The total width of a character is the summation of the A, B, and C spaces. Either the A or the C space can be negative to indicate underhangs or overhangs. 
<para>
ABC metric makes no sense for non-TrueType fonts. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetB(System.Char)">
            <summary>Returns B spacing from ABC metric for given character.</summary>
            <param name="symbol">Character to retrieve B spacing for.</param>
            <returns>Value containing B spacing from ABC metrics for given character.</returns>
            <remarks>ABC metric is defined for TrueType fonts in the following way: 
<list type="bullet"><item><term>
A spacing 
</term><description>
the distance to add to the current position before drawing the character glyph.
</description></item><item><term>
B spacing
</term><description>
the width of the drawn portion of the character glyph.
</description></item><item><term>
C spacing
</term><description>
the distance to add to the current position to provide white space to the right of the character glyph.
</description></item></list>
The total width of a character is the summation of the A, B, and C spaces. Either the A or the C space can be negative to indicate underhangs or overhangs. 
<para>
ABC metric makes no sense for non-TrueType fonts. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetBlackBox(System.Char)">
            <summary>Returns a rectangle that describes the character black box.</summary>
            <param name="symbol">Character to retrieve black box for.</param>
            <returns>The rectangle that describes the character black box.</returns>
            <remarks><para>Character black box is a tightest bounding rectangle of the glyph in the character cell. This way you can calculate actual height of the character without any leading whitespaces.</para></remarks>
            <overloads><summary>Returns a rectangle that describes the character or string black box.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetBlackBox(System.String)">
            <summary>Returns a rectangle that describes the string black box.</summary>
            <param name="string">String to retrieve black box for.</param>
            <returns>The rectangle that describes the string black box.</returns>
            <remarks><para>String black box is a tightest bounding rectangle of glyphs in cells of all characters in a string. This way you can calculate actual height of the character without any leading whitespaces.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetBlackBox(System.String,System.Single[])">
            <summary>Returns a rectangle that describes the string black box.</summary>
            <param name="string">String to retrieve black box for.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <returns>The rectangle that describes the string black box.</returns>
            <remarks><para>String black box is a tightest bounding rectangle of glyphs in cells of all characters in a string. This way you can calculate actual height of the character without any leading whitespaces.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetC(System.Char)">
            <summary>Returns C spacing from ABC metric for given character.</summary>
            <param name="symbol">Character to retrieve C spacing for.</param>
            <returns>Value containing C spacing from ABC metrics for given character.</returns>
            <remarks>ABC metric is defined for TrueType fonts in the following way: 
<list type="bullet"><item><term>
A spacing 
</term><description>
the distance to add to the current position before drawing the character glyph.
</description></item><item><term>
B spacing
</term><description>
the width of the drawn portion of the character glyph.
</description></item><item><term>
C spacing
</term><description>
the distance to add to the current position to provide white space to the right of the character glyph.
</description></item></list>
The total width of a character is the summation of the A, B, and C spaces. Either the A or the C space can be negative to indicate underhangs or overhangs. 
<para>
ABC metric makes no sense for non-TrueType fonts. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetCharacterPositions(System.String,System.Single)">
            <summary>Returns an array of horizontal positions of each character in given text string.</summary>
            <param name="text">Text string to retrieve character positions from.</param>
            <param name="startX">Position of the beginning of the string (regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" />).</param>
            <returns>An array containing X-coordinates of the characters of given string.</returns>
            <remarks><note><see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> can have <see cref="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Transform" /> matrix initialized. This way you can draw text rotated, scaled, or sheared. However this method does not take it into account and returns values as if <see cref="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Transform" /> is reset to identity matrix (sets no transformation). 
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetKerning(System.Char,System.Char)">
            <summary>Returns kerning value for given pair of characters.</summary>
            <param name="symbol1">First character.</param>
            <param name="symbol2">Second character.</param>
            <returns>Kerning value for given pair of characters.</returns>
            <remarks><para>
Fonts can be divided into two groups - fixed fonts and variable fonts. All characters in the fixed fonts (e.g. <i>Courier New</i>) has the same width and distance between characters is always the same. Kerning for any pair of characters in such fonts is always 0. Variable fonts (e.g. <i>Times New Roman</i>) has more natural appearance: "narrow" letters like "i", "t", or "l" takes less space than "wide" ones, like "w", "M", or "O". Besides of that, distances between different pairs of characters varies. For example, when you draw "fi" with variable font, the distance between characters is less than when you draw "pi".
</para><para>
This distance between characters is called kerning. Kerning pairs are specified with font designer and even if font is variable, they may be defined not for all pairs of characters.
</para><para>
You can provide your own kernings when drawing text by supplying <i>kernings</i> argument in <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32[])" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.GetVerticalResolution">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" draft="yes">
            <summary>Gets/sets horizontal text alignment, i.e. value specifying how to locate the text string relatively X-coordinate of the point of text output (which is retrieved to <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32)" /> method).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.HorizontalAlignment" /> value specifying horizontal alignment.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.Left" />.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString2"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString2"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.InternalLeading">
            <summary>Returns internal leading of the current font.</summary>
            <value>Internal leading for the current font.</value>
            <remarks>This value specifies the amount of leading (space) inside the bounds set by the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" /> property. Accent marks and other diacritical characters may occur in this area. The font designer may set this value to zero.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Italic">
            <summary>Gets/sets value specifying if font is italic.</summary>
            <value>Value specifying if font is italic.</value>
            <remarks>Default value is <b>false</b>.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.LineGap">
            <summary>Returns line gap of the current font.</summary>
            <value>Line gap of the current font.</value>
            <remarks>Line gap means a spacing between two lines when they are displayed one under another.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontLineGap"></code><code language="CS" source="DrawingCS/form1.cs#FontLineGap"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.MaximumCharWidth">
            <summary>Returns the width of the widest character in the font.</summary>
            <value>Maximum character width for the current font.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText(System.String,System.Int32,System.Int32,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given formatted text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</summary>
            <param name="text">Multiline formatted text you want to measure.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with formatted text when it will be drawn.</returns>
            <remarks><para>Width and height parameters specify the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />
<seealso href="MeasuringTextSize.htm" />
            <overloads><summary>Gets extent of the given formatted text (both width and height) when it will be drawn with the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText(System.String,System.Single,System.Single,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given formatted text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</summary>
            <param name="text">Multiline formatted text you want to measure.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with formatted text when it will be drawn.</returns>
            <remarks><para>Width and height parameters specify the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />
<seealso href="MeasuringTextSize.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText(System.String,System.Drawing.Size,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given formatted text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</summary>
            <param name="text">Multiline formatted text you want to measure.</param>
            <param name="size">Width and height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with formatted text when it will be drawn.</returns>
            <remarks><para>Size parameter specifies the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />
<seealso href="MeasuringTextSize.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText(System.String,System.Drawing.SizeF,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given formatted text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</summary>
            <param name="text">Multiline formatted text you want to measure.</param>
            <param name="size">Width and height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with formatted text when it will be drawn.</returns>
            <remarks><para>Size parameter specifies the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText">GdiGraphics.DrawFormattedText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />
<seealso href="MeasuringTextSize.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureString(System.String)" draft="yes">
            <summary>Gets the extent (both width and height) of the string draw by the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString">GdiGraphics.DrawString</see> method.</summary>
            <param name="text">String you want to measure.</param>
            <returns>Dimensions of the rectangle occupied with string when it will be drawn.</returns>
            <example><code language="VB" source="DrawingVB/form1.vb#MeasuringTextSize1"></code><code language="CS" source="DrawingCS/form1.cs#MeasuringTextSize1"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureText(System.String,System.Int32,System.Int32,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given text (both width and height) when it will be drawn with the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</summary>
            <param name="text">Multiline text you want to measure.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with text when it will be drawn.</returns>
            <remarks><para>Width and height parameters specify the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />
<seealso href="MeasuringTextSize.htm" />
            <overloads><summary>Gets given text extent (both width and height) when it will be drawn with the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureText(System.String,System.Single,System.Single,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</summary>
            <param name="text">Multiline text you want to measure.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with text when it will be drawn.</returns>
            <remarks><para>Width and height parameters specify the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso href="MeasuringTextSize.htm" />
<seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureText(System.String,System.Drawing.Size,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</summary>
            <param name="text">Multiline text you want to measure.</param>
            <param name="size">Width and height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with text when it will be drawn.</returns>
            <remarks><para>Size parameter specifies the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso href="MeasuringTextSize.htm" />
<seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.MeasureText(System.String,System.Drawing.SizeF,System.Boolean,System.Int32)" draft="yes">
            <summary>Gets extent of the given text (both width and height) when it will be drawn with the 
<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</summary>
            <param name="text">Multiline text you want to measure.</param>
            <param name="size">Width and height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to take into account the destination rectangle. If this value is <b>false</b> the whole text is processed, otherwise only the part which fits the destination rectangle will be measured.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <returns>Dimensions of the rectangle occupied with text when it will be drawn.</returns>
            <remarks><para>Size parameter specifies the desired rectangle you want to display the text inside. The return value is the actual dimensions of the rectangle the text will occupy when displaying.</para><para>To get a valid text size, parameters values passed to this method should be identical to the respective parameters of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText">GdiGraphics.DrawText</see> method.</para><para>All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</para></remarks>
            <seealso href="MeasuringTextSize.htm" />
<seealso cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Name">
            <summary>Gets typeface name of the font.</summary>
            <value>String containing font name.</value>
            <remarks>If font with specified typeface name is not found, system uses the first font which matches other settings (as usual it is "Arial").
<para>
Default value is "Arial".
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name and its size.</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single,Aurigma.GraphicsMill.UnitConverterObject)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name and its size.</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
            <param name="unitConverter">A <see cref="T:Aurigma.GraphicsMill.UnitConverterObject" /> descendant class which is used to grab resolution (DPI) and unit.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name, its size, and if font should be bold and/or italic.</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
            <param name="bold">Value specifying if font should be bold. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Bold" />.</param>
            <param name="italic">Value specifying if font should be italic. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Italic" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single,System.Boolean,System.Boolean,Aurigma.GraphicsMill.UnitConverterObject)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name, its size, and if font should be bold and/or italic.</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
            <param name="bold">Value specifying if font should be bold. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Bold" />.</param>
            <param name="italic">Value specifying if font should be italic. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Italic" />.</param>
            <param name="unitConverter">A <see cref="T:Aurigma.GraphicsMill.UnitConverterObject" /> descendant class which is used to grab resolution (DPI) and unit.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single,System.Boolean,System.Boolean,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name, its size, and if font should be bold and/or italic. You can also specify resolution here (necessary if you are using units other than <see cref="F:Aurigma.GraphicsMill.Unit.Pixel" />).</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
            <param name="bold">Value specifying if font should be bold. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Bold" />.</param>
            <param name="italic">Value specifying if font should be italic. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Italic" />.</param>
            <param name="horizontalResolution">Horizontal resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.HorizontalResolution" />.</param>
            <param name="verticalResolution">Vertical resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.VerticalResolution" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.String,System.Single,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. Here you can specify font typeface name and its size. You can also specify resolution here (necessary if you are using units other than <see cref="F:Aurigma.GraphicsMill.Unit.Pixel" />).</summary>
            <param name="familyName">Font typeface name. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Name" />.</param>
            <param name="size">Font size. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Size" />.</param>
            <param name="horizontalResolution">Horizontal resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.HorizontalResolution" />.</param>
            <param name="verticalResolution">Vertical resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.VerticalResolution" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.Drawing.Font)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. This constructor copies font settings from given <see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance.</summary>
            <param name="font"><see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance which is used to take settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.Drawing.Font,Aurigma.GraphicsMill.UnitConverterObject)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. This constructor copies font settings from given <see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance.</summary>
            <param name="font"><see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance which is used to take settings from.</param>
            <param name="unitConverter">A <see cref="T:Aurigma.GraphicsMill.UnitConverterObject" /> descendant class which is used to grab resolution (DPI) and unit.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.#ctor(System.Drawing.Font,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> class instance. This constructor copies font settings from given <see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance. You can also specify resolution here (necessary if you are using units other than <see cref="F:Aurigma.GraphicsMill.Unit.Pixel" />).</summary>
            <param name="font"><see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance which is used to take settings from.</param>
            <param name="horizontalResolution">Horizontal resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.HorizontalResolution" />.</param>
            <param name="verticalResolution">Vertical resolution (dots per inch - DPI). You can change this value later through property <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.VerticalResolution" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.op_Implicit(Aurigma.GraphicsMill.Drawing.Font)~System.Drawing.Font" draft="yes">
            <summary>Casts <see cref="T:Aurigma.GraphicsMill.Drawing.Font">Aurigma.GraphicsMill.Drawing.Font</see> class instance to <see cref="T:System.Drawing.Font">System.Drawing.Font</see>.</summary>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font">Aurigma.GraphicsMill.Drawing.Font</see> value which is being casted.</param>
            <returns>Font casted to <see cref="T:System.Drawing.Font">System.Drawing.Font</see>.</returns>
            <overloads><summary>Casts <see cref="T:Aurigma.GraphicsMill.Drawing.Font">Aurigma.GraphicsMill.Drawing.Font</see> class instance to <see cref="T:System.Drawing.Font">System.Drawing.Font</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.op_Implicit(System.Drawing.Font)~Aurigma.GraphicsMill.Drawing.Font">
            <summary>Casts <see cref="T:System.Drawing.Font">System.Drawing.Font</see> class instance to <see cref="T:Aurigma.GraphicsMill.Drawing.Font">Aurigma.GraphicsMill.Drawing.Font</see>.</summary>
            <param name="font"><see cref="T:System.Drawing.Font">System.Drawing.Font</see> value which is being casted.</param>
            <returns>Font casted to <see cref="T:Aurigma.GraphicsMill.Drawing.Font">Aurigma.GraphicsMill.Drawing.Font</see>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.SetHorizontalResolution(System.Single)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.SetVerticalResolution(System.Single)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Size">
            <summary>Gets/sets font size.</summary>
            <value>Font size.</value>
            <remarks>Default value is 10.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Strikeout">
            <summary>Gets/sets value specifying if font is stroke out.</summary>
            <value>Value specifying if font is stroke out.</value>
            <remarks>Default value is <b>false</b>.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Font.ToGdiplusFont">
            <summary>Converts the font to the <see cref="T:System.Drawing.Pen">System.Drawing.Font</see> class.</summary>
            <returns>Font converted to <see cref="T:System.Drawing.Pen">System.Drawing.Font</see> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Tracking">
            <summary>Gets/sets font tracking (also known as intercharacter spacing).</summary>
            <value>Font tracking.</value>
            <remarks>Font tracking is a spacing between characters when text string is drawn. It is added to each character, including break characters, when method <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32)" /> writes a line of text.
<para>
Default value is 0. 
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontFontTracking"></code><code language="CS" source="DrawingCS/form1.cs#FontFontTracking"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Underline">
            <summary>Gets/sets value specifying if font is underlined.</summary>
            <value>Value specifying if font is underlined.</value>
            <remarks>Default value is <b>false</b>.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString1"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString1"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment">
            <summary>Gets/sets vertical text alignment, i.e. value specifying how to locate the text string relatively Y-coordinate of the point of text output (which is retrieved to <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32)" /> method).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.VerticalAlignment" /> value specifying vertical alignment.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Drawing.VerticalAlignment.Top" />.</remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingTextString3"></code><code language="CS" source="DrawingCS/form1.cs#DrawingTextString3"></code></example>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Font.Weight">
            <summary>Gets/sets a font weight.</summary>
            <value>An integer value that specifies the weight of the font in the range [0,1000]. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</value>
            <remarks><para>You can use predefined constants for font weight for convenience.</para><list type="table"><listheader><term> Constant </term><description> Weight </description></listheader><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightDontCare" /></term><description>0</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightThin" /></term><description>100</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightExtraLight" /></term><description>200</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightLight" /></term><description>300</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightNormal" /></term><description>400</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightMedium" /></term><description>500</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightSemibold" /></term><description>600</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightBold" /></term><description>700</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightExtrabold" /></term><description>800</description></item><item><term><see cref="F:Aurigma.GraphicsMill.Drawing.Font.FontWeightHeavy" /></term><description>900</description></item></list></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" draft="yes">
            <summary>This class represents drawing functionality provided with Graphics Mill for .NET.</summary>
            <remarks>This class enables you to draw lines, curves, and shapes as well as text at the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> or device context (it can be a window, printer, etc). Drawing methods can be divided into two groups: outlining and filling ones. Outlining methods draw an outline and has a prefix <i>Draw</i>. E.g.
<list type="bullet"><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawArc" /></term><description>Draws an arc.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBezier" /></term><description>Draws a Bezier spline.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse" /></term><description>Draws an outline for ellipse.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine" /></term><description>Draws a line.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie" /></term><description>Draws an outline for a pie.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLines" /></term><description>Draws a polyline.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon" /></term><description>Draws an outline for polygon.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle" /></term><description>Draws an outline for a rectangle.</description></item></list><para>Filling methods are drawing filled shapes without outline:</para><list type="bullet"><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse" /></term><description>Draws a filled ellipse.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie" /></term><description>Draws a filled pie.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon" /></term><description>Draws a filled polygon.</description></item><item><term><see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle" /></term><description>Draws a filled rectangle.</description></item></list><para>This class also provides wide functionality for text output. There are a number of overloads of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString" /> method: <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single)">draw simple string filled with solid color</see>, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32)">draw outlined text</see>, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)">draw multiline text</see>, etc.</para><para>Also, you can draw image through this class. It can be done with overloads of the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage" /> method.</para><para>Sometimes you need to prevent some parts of the bitmap or the device context to be drawn at (i.e. clip the drawing that is outside of some region). Fortunately <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> have a built-in clipping support. You can specify clipping region through the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip" /> method, and apply set-theory operations (<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip" /> and  <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip" /> methods), reset clipping region (<see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" />), move it (<see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip" />), etc. </para><para>If <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> features are not enough for you, you can use a power of Windows GDI. Using <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetHdc" /> method you can get a HDC this graphics represents, and use it in GDI functions.</para><note>GDI cannot handle bitmaps with an alpha channel when it draws anything on it. As the high byte of 4-byte color must be zero in GDI, each pixel drawn with GDI becomes transparent. So now, if you try to call any drawing methods for the bitmaps with an alpha channel when using GDI, the <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> exception will be thrown.</note></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Clear(Aurigma.GraphicsMill.RgbColor)">
            <summary>Clears the drawing surface and fills it with specified color.</summary>
            <param name="backgroundColor"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value which will be used to fill the drawing surface.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Clip">
            <summary>Returns clipping region defined for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance.</summary>
            <value><see cref="T:System.Drawing.Region" /> structure which contains clipping region defined for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance.</value>
            <remarks>If you modify <see cref="T:System.Drawing.Region" /> returned with this property clipping region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance will not be changed. To change clipping region use such methods as <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Region)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Region)" />, and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" />. Clip region can be reset with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> method.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.ClipBounds">
            <summary>Returns a bounding rectangle for clipping region specified for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <value><see cref="T:System.Drawing.RectangleF" /> structure specifying the bounding rectangle for clipping region set for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</value>
            <remarks>To check if clipping region is set to this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, use <see cref="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.IsClipEmpty" /> property.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawArc(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>Draws an arc.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an arc.</param>
            <param name="x">X-coordinate of the top left corner the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Arc is a part of the ellipse. In this method arc is defined with a tightest bounding rectangle of this ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <overloads><summary>Draws an arc.</summary><remarks>Arc is a parf of the ellipse. In this method arc is defined with a tightest bounding rectangle of this ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawArc(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws an arc.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an arc.</param>
            <param name="x">X-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Arc is a part of the ellipse. In this method arc is defined with a tightest bounding rectangle of this ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawArc(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)">
            <summary>Draws an arc.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an arc.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Arc is a part of the ellipse. In this method arc is defined with a tightest bounding rectangle of this ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawArc(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)">
            <summary>Draws an arc.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an arc.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Arc is a part of the ellipse. In this method arc is defined with a tightest bounding rectangle of this ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBezier(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draws a cubic Bezier spline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="x1">X-coordinate of the start spline point.</param>
            <param name="y1">Y-coordinate of the start spline point.</param>
            <param name="x2">X-coordinate of the first control point.</param>
            <param name="y2">Y-coordinate of the first control point.</param>
            <param name="x3">X-coordinate of the second control point.</param>
            <param name="y3">Y-coordinate of the second control point.</param>
            <param name="x4">X-coordinate of the end spline point.</param>
            <param name="y4">Y-coordinate of the end spline point.</param>
            <remarks>A Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <overloads><summary>Draws a cubic Bezier spline.</summary><remarks>A Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBezier(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws a cubic Bezier spline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="x1">X-coordinate of the start spline point.</param>
            <param name="y1">Y-coordinate of the start spline point.</param>
            <param name="x2">X-coordinate of the first control point.</param>
            <param name="y2">Y-coordinate of the first control point.</param>
            <param name="x3">X-coordinate of the second control point.</param>
            <param name="y3">Y-coordinate of the second control point.</param>
            <param name="x4">X-coordinate of the end spline point.</param>
            <param name="y4">Y-coordinate of the end spline point.</param>
            <remarks>A Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBezier(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)">
            <summary>Draws a cubic Bezier spline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="pt1">Start spline point.</param>
            <param name="pt2">First control point.</param>
            <param name="pt3">Second control point.</param>
            <param name="pt4">End spline point.</param>
            <remarks>A Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBezier(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Draws a cubic Bezier spline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="pt1">Start spline point.</param>
            <param name="pt2">First control point.</param>
            <param name="pt3">Second control point.</param>
            <param name="pt4">End spline point.</param>
            <remarks><para>
A Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBeziers(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])" draft="yes">
            <summary>Draws a sequence of connected Bezier splines.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="points">Array of coordinates of the splines start, end, and control points.</param>
            <remarks><para>
A single Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
</para><para>
The end point of each spline is a start point for the next one. So the <i>points</i> array should have at least 4 points and + 3 points for each extra spline.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingLinesAndCurvesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingLinesAndCurvesGdiGraphics"></code></example>
            <overloads><summary>Draws a sequence of connected Bezier splines.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawBeziers(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF[])">
            <summary>Draws a sequence of connected Bezier splines.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw an spline.</param>
            <param name="points">Array of coordinates of the splines start, end, and control points.</param>
            <remarks><para>
A single Bezier spline is defined with four points: first and last point specify beginning and end of the curve, second and third points specify so-called control points. The control points act as magnets, pulling the curve in certain directions to influence the way the Bezier spline bends. 
</para><para>
The end point of each spline is a start point for the next one. So the <i>points</i> array should have at least 4 points and + 3 points for each extra spline.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draws an ellipse.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline an ellipse.</param>
            <param name="x">X-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="width">Width of the bounding rectangle for the ellipse.</param>
            <param name="height">Height of the bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#PensAndBrushes4"></code><code language="CS" source="DrawingCS/form1.cs#PensAndBrushes4"></code></example>
            <overloads><summary>Draws an ellipse.</summary><remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws an ellipse.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline an ellipse.</param>
            <param name="x">X-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="width">Width of the bounding rectangle for the ellipse.</param>
            <param name="height">Height of the bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle)">
            <summary>Draws an ellipse.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline an ellipse.</param>
            <param name="rect">The bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF)" draft="yes">
            <summary>Draws an ellipse.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline an ellipse.</param>
            <param name="rect">The bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws formatted text according to its markup.</summary>
            <param name="s">Marked up text to draw. See <b>Remarks</b> section for details on text markup requirements.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying default text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing default font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>This method is quite similar to <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> with the exception of one difference. The text you want to draw using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method must be marked up with XML-like tags. 
            The following tags and document structure are allowed:
            </para><para><code>
&lt;root&gt;
  &lt;para [style="..."]&gt;
    [some text]
     &lt;span [style="..."]&gt;
       [some text]
         &lt;span [style="..."]&gt;
           [some text]
         &lt;/span&gt;
     &lt;/span&gt;
     ...
     &lt;span [style="..."]&gt;&lt;/span&gt;
  &lt;/para&gt;
  ...
  &lt;para [style="..."]&gt;&lt;/para&gt;
&lt;/root&gt;
              </code></para><para>Let us consider it more detailed:</para><para><b>root</b> is the root tag. It is exactly one all over the text and includes all characters inside. If you place some text ouside the <c>&lt;root&gt;&lt;/root&gt;</c> tags, the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> will throw an exception.</para><para><b>para</b> is a paragraph tag. All the text you want to draw should be divided into paragraphs (at least one) and each of them should be enclosed between <c>&lt;para&gt;</c> and <c>&lt;/para&gt;</c> tags. Otherwise, the text will not be parsed and drawn. It supports the <b>style</b> attribute (see below) to specify some text and color properties of this paragraph.</para><para><b>span</b> is a tag intended to define a new inline area. You can use it to highlight some text inside a paragraph. These tags can be embedded in the existing <c>&lt;span&gt;&lt;/span&gt;</c> tags. It supports the <b>style</b> attribute too.</para><note>All allowed tags are case insensitive, however, the name of every opening tag must have the same case as that of the corresponding closing tag. It means that <c>&lt;SpAn&gt;&lt;/SpAn&gt;</c> or <c>&lt;rOOt&gt;&lt;/rOOt&gt;</c> pairs will be parsed successfully, but pairs like <c>&lt;Para&gt;&lt;/parA&gt;</c> will cause an error.</note><para>The text layout mechanism used in the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method is based on CSS and uses <b>style</b> attributes to attach some font, color and text parameters to paragraphs and theirs parts. This attribute accepts a string contained style parameters and corresponded values. Its common syntax is shown below:</para><code>style="style-parameter1:value1; style-parameter2:value2; ...; style-parameterN:valueN"</code><note>The <b>style</b> attribute and its value are case insensitive, i.e. this style setting will be applied correctly: <c>StyLe="fOnT-faMily: CoUriEr NeW; FoNt-siZe: 18; cOlOr:RgB(100,10,10)"</c></note><para>All supported parameters are described in the following table:</para><list type="table"><listheader><term>Name</term><description>Description</description><description>Examples</description></listheader><item><term><b>font-family</b></term><description><para>
                    Specifies a typeface name of the font.
                  </para><para>
                    If font with specified typeface name is not found, system uses the first font which matches other settings (as usual it is "Arial").
                  </para></description><description><c>style="font-family:arial"</c></description></item><item><term><b>font-style</b></term><description><para>Selects between normal and italic faces within a font family.</para></description><description><para><c>style="font-style:normal"</c></para><para><c>style="font-style:italic"</c></para></description></item><item><term><b>font-weight</b></term><description><para>
                    Selects the weight of the font. The values <c>100</c> to <c>900</c>
                    form an ordered sequence, where each number indicates a weight that is at least as
                    dark as its predecessor. The keyword <c>normal</c> is synonymous with
                    <c>400</c>, and <c>bold</c> is synonymous with <c>700</c>.
                  </para></description><description><para><c>style="font-weight:normal"</c></para><para><c>style="font-weight:bold"</c></para><para><c>style="font-weight:600"</c></para></description></item><item><term><b>font-size</b></term><description><para>Specifies the font size.</para></description><description><para><c>style="font-size:12"</c></para></description></item><item><term><b>color</b></term><description><para>
                    Specifies the text color. A numerical RGB specification is used. No keywords (such as
                    <c>red</c>, <c>white</c>, etc) are supported.
                  </para></description><description><para><c>style="color:rgb(200, 0, 0)"</c></para></description></item><item><term><b>text-align</b></term><description><para>
                    Specifies the text alignment. The following alignment types are supported:
                  </para><list type="bullet"><item><term>center</term><description> aligns text along the center.</description></item><item><term>left</term><description> aligns text along the left edge.</description></item><item><term>right</term><description> aligns text along the right edge.</description></item><item><term>justify</term><description> aligns text along the left and right edges.</description></item></list><para>
                    If the <b>justify</b> alignment type is specified the last line of the text can be aligned using the <b>textAlignLast</b> parameter. This parameter can be one of the following values:
                  </para><list type="bullet"><item><term>center</term><description> aligns the last line of the text along the center.</description></item><item><term>left</term><description> aligns the last line of the text along the left edge.</description></item><item><term>right</term><description> aligns the last line of the text along the right edge.</description></item><item><term>justify</term><description> aligns the last line of the text along the left and right edges.</description></item></list><para>
                    If the <b>textAlignLast</b> parameter is not specified the last line of the text will be aligned along the left edge.
                  </para></description><description><para><c>style="text-align:left"</c></para><para><c>style="text-align:justify; textAlignLast:right"</c></para></description></item><item><term><b>_line-spacing</b></term><description><para>
                    Specifies the space between two adjacent lines of text.
                  </para></description><description><para><c>style="_line-spacing:10px"</c></para><para><c>style="_line-spacing:-15px"</c></para></description></item></list><p>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> supports the following XML predeclared entities:</p><list type="bullet"><item><term><c>&amp;amp;</c></term><description>&amp; ampersand;</description></item><item><term><c>&amp;lt;</c></term><description>&lt; less than;</description></item><item><term><c>&amp;gt;</c></term><description>&gt; greater than.</description></item></list><para>This method parses the tabulation character (<c>\t</c> in C# and <c>vbTab</c> in VB) as a sequence of whitespaces. 
Number of whitespaces to replace one tabulation character in the text can be specified with the <c>tabSize</c> parameter.</para><para>The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText">Font.MeasureFormattedText</see> method.</para><note><para>The  <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />, unlike the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />, does not support the newline character (<c>\n</c> in C# and <c>vbNewLine</c> in VB). To draw a string on a new line enclose it in  <c>&lt;para&gt;&lt;/para&gt;</c> tags.</para></note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText" />
<seealso href="DrawingFormattedText.htm" />
            <overloads><summary>Draws formatted text according to its markup.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws formatted text according to its markup.</summary>
            <param name="s">Marked up text to draw. See <b>Remarks</b> section for details on text markup requirements.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying default text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing default font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>This method is quite similar to <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> with the exception of one difference. The text you want to draw using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method must be marked up with XML-like tags.
              The following tags and document structure are allowed:
            </para><para><code>
&lt;root&gt;
  &lt;para [style="..."]&gt;
    [some text]
    &lt;span [style="..."]&gt;
      [some text]
        &lt;span [style="..."]&gt;
          [some text]
        &lt;/span&gt;
    &lt;/span&gt;
    ...
    &lt;span [style="..."]&gt;&lt;/span&gt;
  &lt;/para&gt;
  ...
  &lt;para [style="..."]&gt;&lt;/para&gt;
&lt;/root&gt;
              </code></para><para>Let us consider it more detailed:</para><para><b>root</b> is the root tag. It is exactly one all over the text and includes all characters inside. If you place some text ouside the <c>&lt;root&gt;&lt;/root&gt;</c> tags, the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> will throw an exception.
            </para><para><b>para</b> is a paragraph tag. All the text you want to draw should be divided into paragraphs (at least one) and each of them should be enclosed between <c>&lt;para&gt;</c> and <c>&lt;/para&gt;</c> tags. Otherwise, the text will not be parsed and drawn. It supports the <b>style</b> attribute (see below) to specify some text and color properties of this paragraph.
            </para><para><b>span</b> is a tag intended to define a new inline area. You can use it to highlight some text inside a paragraph. These tags can be embedded in the existing <c>&lt;span&gt;&lt;/span&gt;</c> tags. It supports the <b>style</b> attribute too.
            </para><note>
              All allowed tags are case insensitive, however, the name of every opening tag must have the same case as that of the corresponding closing tag. It means that <c>&lt;SpAn&gt;&lt;/SpAn&gt;</c> or <c>&lt;rOOt&gt;&lt;/rOOt&gt;</c> pairs will be parsed successfully, but pairs like <c>&lt;Para&gt;&lt;/parA&gt;</c> will cause an error.
            </note><para>
              The text layout mechanism used in the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method is based on CSS and uses <b>style</b> attributes to attach some font, color and text parameters to paragraphs and theirs parts. This attribute accepts a string contained style parameters and corresponded values. Its common syntax is shown below:
            </para><code>style="style-parameter1:value1; style-parameter2:value2; ...; style-parameterN:valueN"</code><note>
              The <b>style</b> attribute and its value are case insensitive, i.e. this style setting will be applied correctly: <c>StyLe="fOnT-faMily: CoUriEr NeW; FoNt-siZe: 18; cOlOr:RgB(100,10,10)"</c></note><para>All supported parameters are described in the following table:</para><list type="table"><listheader><term>Name</term><description>Description</description><description>Examples </description></listheader><item><term><b>font-family</b></term><description><para>
                    Specifies a typeface name of the font.
                  </para><para>
                    If font with specified typeface name is not found, system uses the first font which matches other settings (as usual it is "Arial").
                  </para></description><description><c>style="font-family:arial"</c></description></item><item><term><b>font-style</b></term><description><para>Selects between normal and italic faces within a font family.</para></description><description><para><c>style="font-style:normal"</c></para><para><c>style="font-style:italic"</c></para></description></item><item><term><b>font-weight</b></term><description><para>
                    Selects the weight of the font. The values <c>100</c> to <c>900</c>
                    form an ordered sequence, where each number indicates a weight that is at least as
                    dark as its predecessor. The keyword <c>normal</c> is synonymous with
                    <c>400</c>, and <c>bold</c> is synonymous with <c>700</c>.
                  </para></description><description><para><c>style="font-weight:normal"</c></para><para><c>style="font-weight:bold"</c></para><para><c>style="font-weight:600"</c></para></description></item><item><term><b>font-size</b></term><description><para>Specifies the font size.</para></description><description><para><c>style="font-size:12"</c></para></description></item><item><term><b>color</b></term><description><para>
                    Specifies the text color. A numerical RGB specification is used. No keywords (such as
                    <c>red</c>, <c>white</c>, etc) are supported.
                  </para></description><description><para><c>style="color:rgb(200, 0, 0)"</c></para></description></item><item><term><b>text-align</b></term><description><para>
                    Specifies the text alignment. The following alignment types are supported:
                  </para><list type="bullet"><item><term>center</term><description> aligns text along the center.</description></item><item><term>left</term><description> aligns text along the left edge.</description></item><item><term>right</term><description> aligns text along the right edge.</description></item><item><term>justify</term><description> aligns text along the left and right edges.</description></item></list><para>
                    If the <b>justify</b> alignment type is specified the last line of the text can be aligned using the <b>textAlignLast</b> parameter. This parameter can be one of the following values:
                  </para><list type="bullet"><item><term>center</term><description> aligns the last line of the text along the center.</description></item><item><term>left</term><description> aligns the last line of the text along the left edge.</description></item><item><term>right</term><description> aligns the last line of the text along the right edge.</description></item><item><term>justify</term><description> aligns the last line of the text along the left and right edges.</description></item></list><para>
                    If the <b>textAlignLast</b> parameter is not specified the last line of the text will be aligned along the left edge.
                  </para></description><description><para><c>style="text-align:left"</c></para><para><c>style="text-align:justify; textAlignLast:right"</c></para></description></item><item><term><b>_line-spacing</b></term><description><para>
                    Specifies the space between two adjacent lines of text.
                  </para></description><description><para><c>style="_line-spacing:10px"</c></para><para><c>style="_line-spacing:-15px"</c></para></description></item></list><p>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> supports the following XML predeclared entities:</p><list type="bullet"><item><term><c>&amp;amp;</c></term><description>&amp; ampersand;</description></item><item><term><c>&amp;lt;</c></term><description>&lt; less than;</description></item><item><term><c>&amp;gt;</c></term><description>&gt; greater than.</description></item></list><para>This method parses the tabulation character (<c>\t</c> in C# and <c>vbTab</c> in VB) as a sequence of whitespaces. 
Number of whitespaces to replace one tabulation character in the text can be specified with the <c>tabSize</c> parameter.</para><para>The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText">Font.MeasureFormattedText</see> method.</para><note><para>The  <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />, unlike the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />, does not support the newline character (<c>\n</c> in C# and <c>vbNewLine</c> in VB). To draw a string on a new line enclose it in  <c>&lt;para&gt;&lt;/para&gt;</c> tags.</para></note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText" />
<seealso href="DrawingFormattedText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Rectangle,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws formatted text according to its markup.</summary>
            <param name="s">Marked up text to draw. See <b>Remarks</b> section for details on text markup requirements.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying default text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing default font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
              This method is quite similar to <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> with the exception of one difference. The text you want to draw using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method must be marked up with XML-like tags.
              The following tags and document structure are allowed:
            </para><para><code>
&lt;root&gt;
  &lt;para [style="..."]&gt;
    [some text]
    &lt;span [style="..."]&gt;
      [some text]
      &lt;span [style="..."]&gt;
        [some text]
      &lt;/span&gt;
    &lt;/span&gt;
    ...
    &lt;span [style="..."]&gt;&lt;/span&gt;
  &lt;/para&gt;
  ...
  &lt;para [style="..."]&gt;&lt;/para&gt;
&lt;/root&gt;
              </code></para><para>Let us consider it more detailed:</para><para><b>root</b> is the root tag. It is exactly one all over the text and includes all characters inside. If you place some text ouside the <c>&lt;root&gt;&lt;/root&gt;</c> tags, the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> will throw an exception.
            </para><para><b>para</b> is a paragraph tag. All the text you want to draw should be divided into paragraphs (at least one) and each of them should be enclosed between <c>&lt;para&gt;</c> and <c>&lt;/para&gt;</c> tags. Otherwise, the text will not be parsed and drawn. It supports the <b>style</b> attribute (see below) to specify some text and color properties of this paragraph.
            </para><para><b>span</b> is a tag intended to define a new inline area. You can use it to highlight some text inside a paragraph. These tags can be embedded in the existing <c>&lt;span&gt;&lt;/span&gt;</c> tags. It supports the <b>style</b> attribute too.
            </para><note>
              All allowed tags are case insensitive, however, the name of every opening tag must have the same case as that of the corresponding closing tag. It means that <c>&lt;SpAn&gt;&lt;/SpAn&gt;</c> or <c>&lt;rOOt&gt;&lt;/rOOt&gt;</c> pairs will be parsed successfully, but pairs like <c>&lt;Para&gt;&lt;/parA&gt;</c> will cause an error.
            </note><para>
              The text layout mechanism used in the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method is based on CSS and uses <b>style</b> attributes to attach some font, color and text parameters to paragraphs and theirs parts. This attribute accepts a string contained style parameters and corresponded values. Its common syntax is shown below:
            </para><code>style="style-parameter1:value1; style-parameter2:value2; ...; style-parameterN:valueN"</code><note>
              The <b>style</b> attribute and its value are case insensitive, i.e. this style setting will be applied correctly: <c>StyLe="fOnT-faMily: CoUriEr NeW; FoNt-siZe: 18; cOlOr:RgB(100,10,10)"</c></note><para>All supported parameters are described in the following table:</para><list type="table"><listheader><term>Name</term><description>Description</description><description>Examples</description></listheader><item><term><b>font-family</b></term><description><para>
                    Specifies a typeface name of the font.
                  </para><para>
                    If font with specified typeface name is not found, system uses the first font which matches other settings (as usual it is "Arial").
                  </para></description><description><c>style="font-family:arial"</c></description></item><item><term><b>font-style</b></term><description><para>Selects between normal and italic faces within a font family.</para></description><description><para><c>style="font-style:normal"</c></para><para><c>style="font-style:italic"</c></para></description></item><item><term><b>font-weight</b></term><description><para>
                    Selects the weight of the font. The values <c>100</c> to <c>900</c>
                    form an ordered sequence, where each number indicates a weight that is at least as
                    dark as its predecessor. The keyword <c>normal</c> is synonymous with
                    <c>400</c>, and <c>bold</c> is synonymous with <c>700</c>.
                  </para></description><description><para><c>style="font-weight:normal"</c></para><para><c>style="font-weight:bold"</c></para><para><c>style="font-weight:600"</c></para></description></item><item><term><b>font-size</b></term><description><para>Specifies the font size.</para></description><description><para><c>style="font-size:12"</c></para></description></item><item><term><b>color</b></term><description><para>
                    Specifies the text color. A numerical RGB specification is used. No keywords (such as
                    <c>red</c>, <c>white</c>, etc) are supported.
                  </para></description><description><para><c>style="color:rgb(200, 0, 0)"</c></para></description></item><item><term><b>text-align</b></term><description><para>
                    Specifies the text alignment. The following alignment types are supported:
                  </para><list type="bullet"><item><term>center</term><description> aligns text along the center.</description></item><item><term>left</term><description> aligns text along the left edge.</description></item><item><term>right</term><description> aligns text along the right edge.</description></item><item><term>justify</term><description> aligns text along the left and right edges.</description></item></list><para>
                    If the <b>justify</b> alignment type is specified the last line of the text can be aligned using the <b>textAlignLast</b> parameter. This parameter can be one of the following values:
                  </para><list type="bullet"><item><term>center</term><description> aligns the last line of the text along the center.</description></item><item><term>left</term><description> aligns the last line of the text along the left edge.</description></item><item><term>right</term><description> aligns the last line of the text along the right edge.</description></item><item><term>justify</term><description> aligns the last line of the text along the left and right edges.</description></item></list><para>
                    If the <b>textAlignLast</b> parameter is not specified the last line of the text will be aligned along the left edge.
                  </para></description><description><para><c>style="text-align:left"</c></para><para><c>style="text-align:justify; textAlignLast:right"</c></para></description></item><item><term><b>_line-spacing</b></term><description><para>
                    Specifies the space between two adjacent lines of text.
                  </para></description><description><para><c>style="_line-spacing:10px"</c></para><para><c>style="_line-spacing:-15px"</c></para></description></item></list><p>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> supports the following XML predeclared entities:</p><list type="bullet"><item><term><c>&amp;amp;</c></term><description>&amp; ampersand;</description></item><item><term><c>&amp;lt;</c></term><description>&lt; less than;</description></item><item><term><c>&amp;gt;</c></term><description>&gt; greater than.</description></item></list><para>This method parses the tabulation character (<c>\t</c> in C# and <c>vbTab</c> in VB) as a sequence of whitespaces. 
Number of whitespaces to replace one tabulation character in the text can be specified with the <c>tabSize</c> parameter.</para><para>The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText">Font.MeasureFormattedText</see> method.</para><note><para>The  <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />, unlike the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />, does not support the newline character (<c>\n</c> in C# and <c>vbNewLine</c> in VB). To draw a string on a new line enclose it in  <c>&lt;para&gt;&lt;/para&gt;</c> tags.</para></note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText" />
<seealso href="DrawingFormattedText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.RectangleF,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws formatted text according to its markup.</summary>
            <param name="s">Marked up text to draw. See <b>Remarks</b> section for details on text markup requirements.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying default text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing default font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
              This method is quite similar to <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> with the exception of one difference. The text you want to draw using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method must be marked up with XML-like tags.
              The following tags and document structure are allowed:
            </para><para><code>
&lt;root&gt;
  &lt;para [style="..."]&gt;
    [some text]
    &lt;span [style="..."]&gt;
      [some text]
      &lt;span [style="..."]&gt;
        [some text]
      &lt;/span&gt;
    &lt;/span&gt;
    ...
    &lt;span [style="..."]&gt;&lt;/span&gt;
  &lt;/para&gt;
  ...
  &lt;para [style="..."]&gt;&lt;/para&gt;
&lt;/root&gt;
              </code></para><para>Let us consider it more detailed:</para><para><b>root</b> is the root tag. It is exactly one all over the text and includes all characters inside. If you place some text ouside the <c>&lt;root&gt;&lt;/root&gt;</c> tags, the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> will throw an exception.
            </para><para><b>para</b> is a paragraph tag. All the text you want to draw should be divided into paragraphs (at least one) and each of them should be enclosed between <c>&lt;para&gt;</c> and <c>&lt;/para&gt;</c> tags. Otherwise, the text will not be parsed and drawn. It supports the <b>style</b> attribute (see below) to specify some text and color properties of this paragraph.
            </para><para><b>span</b> is a tag intended to define a new inline area. You can use it to highlight some text inside a paragraph. These tags can be embedded in the existing <c>&lt;span&gt;&lt;/span&gt;</c> tags. It supports the <b>style</b> attribute too.
            </para><note>
              All allowed tags are case insensitive, however, the name of every opening tag must have the same case as that of the corresponding closing tag. It means that <c>&lt;SpAn&gt;&lt;/SpAn&gt;</c> or <c>&lt;rOOt&gt;&lt;/rOOt&gt;</c> pairs will be parsed successfully, but pairs like <c>&lt;Para&gt;&lt;/parA&gt;</c> will cause an error.
            </note><para>
              The text layout mechanism used in the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> method is based on CSS and uses <b>style</b> attributes to attach some font, color and text parameters to paragraphs and theirs parts. This attribute accepts a string contained style parameters and corresponded values. Its common syntax is shown below:
            </para><code>style="style-parameter1:value1; style-parameter2:value2; ...; style-parameterN:valueN"</code><note>
              The <b>style</b> attribute and its value are case insensitive, i.e. this style setting will be applied correctly: <c>StyLe="fOnT-faMily: CoUriEr NeW; FoNt-siZe: 18; cOlOr:RgB(100,10,10)"</c></note><para>All supported parameters are described in the following table:</para><list type="table"><listheader><term>Name</term><description>Description</description><description>Examples</description></listheader><item><term><b>font-family</b></term><description><para>
                    Specifies a typeface name of the font.
                  </para><para>
                    If font with specified typeface name is not found, system uses the first font which matches other settings (as usual it is "Arial").
                  </para></description><description><c>style="font-family:arial"</c></description></item><item><term><b>font-style</b></term><description><para>Selects between normal and italic faces within a font family.</para></description><description><para><c>style="font-style:normal"</c></para><para><c>style="font-style:italic"</c></para></description></item><item><term><b>font-weight</b></term><description><para>
                    Selects the weight of the font. The values <c>100</c> to <c>900</c>
                    form an ordered sequence, where each number indicates a weight that is at least as
                    dark as its predecessor. The keyword <c>normal</c> is synonymous with
                    <c>400</c>, and <c>bold</c> is synonymous with <c>700</c>.
                  </para></description><description><para><c>style="font-weight:normal"</c></para><para><c>style="font-weight:bold"</c></para><para><c>style="font-weight:600"</c></para></description></item><item><term><b>font-size</b></term><description><para>Specifies the font size.</para></description><description><para><c>style="font-size:12"</c></para></description></item><item><term><b>color</b></term><description><para>
                    Specifies the text color. A numerical RGB specification is used. No keywords (such as
                    <c>red</c>, <c>white</c>, etc) are supported.
                  </para></description><description><para><c>style="color:rgb(200, 0, 0)"</c></para></description></item><item><term><b>text-align</b></term><description><para>
                    Specifies the text alignment. The following alignment types are supported:
                  </para><list type="bullet"><item><term>center</term><description> aligns text along the center.</description></item><item><term>left</term><description> aligns text along the left edge.</description></item><item><term>right</term><description> aligns text along the right edge.</description></item><item><term>justify</term><description> aligns text along the left and right edges.</description></item></list><para>
                    If the <b>justify</b> alignment type is specified the last line of the text can be aligned using the <b>textAlignLast</b> parameter. This parameter can be one of the following values:
                  </para><list type="bullet"><item><term>center</term><description> aligns the last line of the text along the center.</description></item><item><term>left</term><description> aligns the last line of the text along the left edge.</description></item><item><term>right</term><description> aligns the last line of the text along the right edge.</description></item><item><term>justify</term><description> aligns the last line of the text along the left and right edges.</description></item></list><para>
                    If the <b>textAlignLast</b> parameter is not specified the last line of the text will be aligned along the left edge.
                  </para></description><description><para><c>style="text-align:left"</c></para><para><c>style="text-align:justify; textAlignLast:right"</c></para></description></item><item><term><b>_line-spacing</b></term><description><para>
                    Specifies the space between two adjacent lines of text.
                  </para></description><description><para><c>style="_line-spacing:10px"</c></para><para><c>style="_line-spacing:-15px"</c></para></description></item></list><p>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" /> supports the following XML predeclared entities:</p><list type="bullet"><item><term><c>&amp;amp;</c></term><description>&amp; ampersand;</description></item><item><term><c>&amp;lt;</c></term><description>&lt; less than;</description></item><item><term><c>&amp;gt;</c></term><description>&gt; greater than.</description></item></list><para>This method parses the tabulation character (<c>\t</c> in C# and <c>vbTab</c> in VB) as a sequence of whitespaces. 
Number of whitespaces to replace one tabulation character in the text can be specified with the <c>tabSize</c> parameter.</para><para>The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText">Font.MeasureFormattedText</see> method.</para><note><para>The  <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawFormattedText" />, unlike the <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" />, does not support the newline character (<c>\n</c> in C# and <c>vbNewLine</c> in VB). To draw a string on a new line enclose it in  <c>&lt;para&gt;&lt;/para&gt;</c> tags.</para></note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureFormattedText" />
<seealso href="DrawingFormattedText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the bitmap.</param>
            <param name="destinationY">Vertical position of left-top corner of the bitmap.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
            <overloads><summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary><seealso href="CombineModes.htm">Combine Modes</seealso></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Image is drawn from source rectangle on given bitmap to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If source rectangle dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically (both for source and destination rectangles) , you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the bitmap.</param>
            <param name="destinationY">Vertical position of left-top corner of the bitmap.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" draft="yes">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationX">Horizontal position of left-top corner of the destination rectangle.</param>
            <param name="destinationY">Vertical position of left-top corner of the destination rectangle.</param>
            <param name="destinationWidth">Width of the destination rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="destinationHeight">Height of the destination rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceX">Horizontal position of left-top corner of the source rectangle.</param>
            <param name="sourceY">Vertical position of left-top corner of the source rectangle.</param>
            <param name="sourceWidth">Width of the source rectangle. You can pass 0 to indicate that method should calculate width automatically (see <b>Remarks</b> section for details).</param>
            <param name="sourceHeight">Height of the source rectangle. You can pass 0 to indicate that method should calculate height automatically (see <b>Remarks</b> section for details).</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Image is drawn from source rectangle on given bitmap to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If source rectangle dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically (both for source and destination rectangles) , you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.Point,Aurigma.GraphicsMill.Transforms.CombineMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="point">The point specifying left-top corner of the bitmap.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.PointF,Aurigma.GraphicsMill.Transforms.CombineMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="point">The point specifying left-top corner of the bitmap.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <remarks><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para><note>If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationRect">The destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationRect">The destination rectangle.</param>
            <param name="sourceRect">The source rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Image is drawn from source rectangle on given bitmap to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If source rectangle dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically (both for source and destination rectangles) , you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationRect">The destination rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Bitmap is drawn to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If current bitmap dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically, you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawImage(Aurigma.GraphicsMill.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Draws a <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object you are going to draw.</param>
            <param name="destinationRect">The destination rectangle.</param>
            <param name="sourceRect">The source rectangle.</param>
            <param name="combine">Algorithm of images blending (plain pixels copying, alpha blending, bitwise operations, etc).</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</param>
            <param name="interpolationMode">Algorithm of resizing. Using this parameter you can select between speed and quality of resizing.</param>
            <remarks><para>
Image is drawn from source rectangle on given bitmap to destination rectangle on this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. If source rectangle dimensions differ from dimensions of destination rectangle, it is resized to have the same size as destination rectangle. 
</para><note>
If bitmap has pixel format which is not GDI-compatible (e.g. extended pixel formats, CMYK, etc) method will automatically create a copy converted to the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />. That's why you always get it drawn, but if you are going to call this method multiple times, it is recommended to convert it to some GDI-compatible format (like <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) to increase the performance.
</note><para>
If you want method to calculate width and height automatically (both for source and destination rectangles) , you can pass 0 to these arguments. It will be calculated with the following way:
</para><list type="number"><item><description>If both width and heigth are 0, it will take source image dimensions (<see cref="P:Aurigma.GraphicsMill.Bitmap.Width" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.Height" /> properties). This way no resize will be done during drawing.</description></item><item><description>If only one of arguments is 0, it will calculate this argument to save proportion. For example, source image is 800x600, and you pass 400 as width and 0 as height. Height will be calculated to preserve aspect ratio of the image, i.e. it will be equal to 300.</description></item></list><para>
All coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property of the bitmap.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draws a line.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a line.</param>
            <param name="x1">X-coordinate of the start point of the line.</param>
            <param name="y1">Y-coordinate of the start point of the line.</param>
            <param name="x2">X-coordinate of the end point of the line.</param>
            <param name="y2">Y-coordinate of the end point of the line.</param>
            <remarks>In this method line is defined with two points which should be connected with this line.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#Hdc"></code><code language="CS" source="DrawingCS/form1.cs#Hdc"></code></example>
            <overloads><summary>Draws a line.</summary><remarks>In this method line is defined with two points which should be connected with this line.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws a line.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a line.</param>
            <param name="x1">X-coordinate of the start point of the line.</param>
            <param name="y1">Y-coordinate of the start point of the line.</param>
            <param name="x2">X-coordinate of the end point of the line.</param>
            <param name="y2">Y-coordinate of the end point of the line.</param>
            <remarks>In this method line is defined with two points which should be connected with this line.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)">
            <summary>Draws a line.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a line.</param>
            <param name="point1">The start point of the line.</param>
            <param name="point2">The end point of the line.</param>
            <remarks>In this method line is defined with two points which should be connected with this line.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Draws a line.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a line.</param>
            <param name="point1">The start point of the line.</param>
            <param name="point2">The end point of the line.</param>
            <remarks>In this method line is defined with two points which should be connected with this line.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLines(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])">
            <summary>Draws a polyline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a polyline.</param>
            <param name="points">Array of coordinates of the polyline vertices.</param>
            <remarks>Polyline is a set of connected lines (end point of some polyline segment is a start point of the next segment). It is defined with an array of points which should be connected with this polyline (polyline vertices).
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingLinesAndCurvesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingLinesAndCurvesGdiGraphics"></code></example>
            <overloads><summary>Draws a polyline.</summary><remarks>Polyline is a set of connected lines (end point of some polyline segment is a start point of the next segment). It is defined with an array of points which should be connected with this polyline (polyline vertices).
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLines(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF[])">
            <summary>Draws a polyline.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to draw a polyline.</param>
            <param name="points">Array of coordinates of the polyline vertices.</param>
            <remarks>Polyline is a set of connected lines (end point of some polyline segment is a start point of the next segment). It is defined with an array of points which should be connected with this polyline (polyline vertices).
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draws a pie shape.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a pie.</param>
            <param name="x">X-coordinate of the top left corner the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
</para></remarks>
            <overloads><summary>Draws a pie shape.</summary><remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws a pie shape.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a pie.</param>
            <param name="x">X-coordinate of the top left corner the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)">
            <summary>Draws a pie shape.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a pie.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)">
            <summary>Draws a pie shape.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a pie.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])">
            <summary>Draws a polygon.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" /> method.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
            <overloads><summary>Draws a polygon.</summary><remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF[])">
            <summary>Draws a polygon.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To fill the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draws a rectangle.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a rectangle.</param>
            <param name="x">X-coordinate of the top left corner of the rectangle.</param>
            <param name="y">Y-coordinate of the top left corner of the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <remarks>To fill a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
            <overloads><summary>Draws a rectangle.</summary><remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)">
            <summary>Draws a rectangle.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a rectangle.</param>
            <param name="x">X-coordinate of the top left corner of the rectangle.</param>
            <param name="y">Y-coordinate of the top left corner of the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <remarks>To fill a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle)">
            <summary>Draws a rectangle.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a rectangle.</param>
            <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> object to draw.</param>
            <remarks>To fill a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF)">
            <summary>Draws a rectangle.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object which is used to outline a rectangle.</param>
            <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> object to draw.</param>
            <remarks>To fill a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32)" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#TextWithOutline1GdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#TextWithOutline1GdiGraphics"></code></example>
            <overloads><summary>Draws a text string.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32[])" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single)" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single[])" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Point)" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Point,System.Int32[])" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.PointF)" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.Pen,Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.PointF,System.Single[])" draft="yes">
            <summary>Draws an outlined text at specified position.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object used to outline the text. If you need only fill the string, pass an empty pen here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class).</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object used to fill the text. If you need only outline the string, pass an empty brush here (you can get it with static method <see cref="P:Aurigma.GraphicsMill.Drawing.Brush.Empty" /> of the <see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class).</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32)" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontFontTracking"></code><code language="CS" source="DrawingCS/form1.cs#FontFontTracking"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32,System.Int32[])" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#FontKernings"></code><code language="CS" source="DrawingCS/form1.cs#FontKernings"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)" draft="yes">
            <summary>Draws a string in specified rectangle (automatically wrapping it if necessary).</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="trim"><see cref="T:Aurigma.GraphicsMill.Drawing.TextTrimmingMode" /> value specifying how to handle situation when text does not fit given rectangle (where to insert ellipsis characters).</param>
            <param name="hotkeyPrefix">Value specifying if to handle hotkey prefix (ampersand sign). If <b>true</b>, ampersand is removed from the string and next character is underlined.</param>
            <param name="clipping">Value specifying if to clip the string when it does not fit the bounding rectangle.</param>
            <param name="wordWrap">Value specifying if to wrap the string inside the bounding rectangle.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single)" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single,System.Single[])" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="y">Y-coordinate of the text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)" draft="yes">
            <summary>Draws a string in specified rectangle (automatically wrapping it if necessary).</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="trim"><see cref="T:Aurigma.GraphicsMill.Drawing.TextTrimmingMode" /> value specifying how to handle situation when text does not fit given rectangle (where to insert ellipsis characters).</param>
            <param name="hotkeyPrefix">Value specifying if to handle hotkey prefix (ampersand sign). If <b>true</b>, ampersand is removed from the string and next character is underlined.</param>
            <param name="clipping">Value specifying if to clip the string when it does not fit the bounding rectangle.</param>
            <param name="wordWrap">Value specifying if to wrap the string inside the bounding rectangle.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Point)" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Point,System.Int32[])" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.PointF)" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.PointF,System.Single[])" draft="yes">
            <summary>Draws a text string without any special effects.</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="point">Text output point. Actual position of the text relatively this point is defined with <see cref="P:Aurigma.GraphicsMill.Drawing.Font.HorizontalAlignment" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Font.VerticalAlignment" /> properties of the <i>font</i> argument.</param>
            <param name="kernings">Array of kerning modifiers. The first entry of this array specify additional distance (may be negative) between first and second character of the string; the second entry specifies additional distance between second and third character, etc.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Rectangle,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)" draft="yes">
            <summary>Draws a string in specified rectangle (automatically wrapping it if necessary).</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="trim"><see cref="T:Aurigma.GraphicsMill.Drawing.TextTrimmingMode" /> value specifying how to handle situation when text does not fit given rectangle (where to insert ellipsis characters).</param>
            <param name="hotkeyPrefix">Value specifying if to handle hotkey prefix (ampersand sign). If <b>true</b>, ampersand is removed from the string and next character is underlined.</param>
            <param name="clipping">Value specifying if to clip the string when it does not fit the bounding rectangle.</param>
            <param name="wordWrap">Value specifying if to wrap the string inside the bounding rectangle.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.RectangleF,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)" draft="yes">
            <summary>Draws a string in specified rectangle (automatically wrapping it if necessary).</summary>
            <param name="s">String to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="trim"><see cref="T:Aurigma.GraphicsMill.Drawing.TextTrimmingMode" /> value specifying how to handle situation when text does not fit given rectangle (where to insert ellipsis characters).</param>
            <param name="hotkeyPrefix">Value specifying if to handle hotkey prefix (ampersand sign). If <b>true</b>, ampersand is removed from the string and next character is underlined.</param>
            <param name="clipping">Value specifying if to clip the string when it does not fit the bounding rectangle.</param>
            <param name="wordWrap">Value specifying if to wrap the string inside the bounding rectangle.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette. </note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws text in the specified rectangle taking into account its line breaks and justification.</summary>
            <param name="s">Multiline text to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property. If the destination rectangle width is 0 the text will not be wrapped during the drawing. The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText">Font.MeasureText</see> method.
</para><para>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> method supports newline (<c>\n</c> in C# and <c>vbNewLine</c> in VB) and tabulation (<c>\t</c> in C# and <c>vbTab</c> in VB) characters. It makes the characters after the newline symbol be displayed in a new line and replaces the tabulation character 
with the specified number of whitespaces.</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette.</note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText" />
<seealso href="DrawingMultilineText.htm" />
            <overloads><summary>Draws text in the specified rectangle taking into account its paragraphs and justification.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws text in the specified rectangle taking into account its line breaks and justification.</summary>
            <param name="s">Multiline text to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="x">X-coordinate of the left top corner of the destination rectangle.</param>
            <param name="y">Y-coordinate of the left top corner of the destination rectangle.</param>
            <param name="width">Width of the destination rectangle.</param>
            <param name="height">Height of the destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property. If the destination rectangle width is 0 the text will not be wrapped during the drawing. The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText">Font.MeasureText</see> method.
</para><para>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> method supports newline (<c>\n</c> in C# and <c>vbNewLine</c> in VB) and tabulation (<c>\t</c> in C# and <c>vbTab</c> in VB) characters. It makes the characters after the newline symbol be displayed in a new line and replaces the tabulation character 
with the specified number of whitespaces.</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette.</note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText" />
<seealso href="DrawingMultilineText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Rectangle,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws text in the specified rectangle taking into account its line breaks and justification.</summary>
            <param name="s">Multiline text to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property. If the destination rectangle width is 0 the text will not be wrapped during the drawing. The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText">Font.MeasureText</see> method.
</para><para>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> method supports newline (<c>\n</c> in C# and <c>vbNewLine</c> in VB) and tabulation (<c>\t</c> in C# and <c>vbTab</c> in VB) characters. It makes the characters after the newline symbol be displayed in a new line and replaces the tabulation character 
with the specified number of whitespaces.</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette.</note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText" />
<seealso href="DrawingMultilineText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.RectangleF,System.Boolean,System.Int32)" draft="yes">
            <summary>Draws text in the specified rectangle taking into account its line breaks and justification.</summary>
            <param name="s">Multiline text to draw.</param>
            <param name="font"><see cref="T:Aurigma.GraphicsMill.Drawing.Font" /> object specifying text rendering options.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing font color.</param>
            <param name="rect">Destination rectangle.</param>
            <param name="clipping">Value specifying whether to clip the text when it does not fit the bounding rectangle. If this value is <b>false</b> all the lines of the text will be rendered regardless of the destination rectangle.</param>
            <param name="tabSize">Value which specifies the number of whitespaces to replace one tabulation character in the text.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property. If the destination rectangle width is 0 the text will not be wrapped during the drawing. The extent of the text drawn by this method can be measured using the <see cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText">Font.MeasureText</see> method.
</para><para>The <see cref="Overload:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawText" /> method supports newline (<c>\n</c> in C# and <c>vbNewLine</c> in VB) and tabulation (<c>\t</c> in C# and <c>vbTab</c> in VB) characters. It makes the characters after the newline symbol be displayed in a new line and replaces the tabulation character 
with the specified number of whitespaces.</para><note>If you draw text on indexed bitmaps, antialiasing is disabled regardless to the <see cref="P:Aurigma.GraphicsMill.Drawing.Font.Antialiased" /> property value. Also, if the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> was created on the base of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> which has <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" /> pixel format, antialiasing will not be applied for text output. The reason of this issue is that GDI does not support grayscale bitmaps. That's why Graphics Mill for .NET represents this image as <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" /> bitmap with grayscale palette.</note></remarks>
            <seealso cref="Overload:Aurigma.GraphicsMill.Drawing.Font.MeasureText" />
<seealso href="DrawingMultilineText.htm" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Rectangle)">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by excluding given rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure which specifies the rectangular area to exclude from the clip region.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <overloads><summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by excluding given area.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.RectangleF)">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by excluding given rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.RectangleF" /> structure which specifies the rectangular area to exclude from the clip region.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Region)">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by excluding given <see cref="T:System.Drawing.Region" />.</summary>
            <param name="clipRegion"><see cref="T:System.Drawing.Region" /> structure which specifies the area to exclude from the clip region.</param>
            <remarks><note>
Unlike most methods of <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, the coordinates of the <see cref="T:System.Drawing.Region" /> are measured in pixels (not in in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Fills an ellipse.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill an ellipse.</param>
            <param name="x">X-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="width">Width of the bounding rectangle for the ellipse.</param>
            <param name="height">Height of the bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
            <overloads><summary>Fills an ellipse.</summary><remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)">
            <summary>Fills an ellipse.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill an ellipse.</param>
            <param name="x">X-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="y">Y-coordinate of the top left corner of the bounding rectangle for the ellipse.</param>
            <param name="width">Width of the bounding rectangle for the ellipse.</param>
            <param name="height">Height of the bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle)">
            <summary>Fills an ellipse.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill an ellipse.</param>
            <param name="rect">The bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillEllipse(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF)">
            <summary>Fills an ellipse.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill an ellipse.</param>
            <param name="rect">The bounding rectangle for the ellipse.</param>
            <remarks>Ellipse is defined by its tightest bounding rectangle. If you have an ellipse defined with central point and two radiuses, you can convert these parameters to rectangle in the following way:
<code language="CS">

// Let's assume we have centerX, centerY - coordinates of the ellipse center, 
// horizontalRadius and verticalRadius - radiuses of the ellipse.
// We are calculating rectX, rectY, rectWidth, and rectHeight which specify 
// bounding rectangle for ellipse.

rectX = centerX - horizontalRadius;
rectY = centerY - verticalRadius;
rectWidth = horizontalRadius * 2;
rectHeight = verticalRadius * 2;
</code><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline an ellipse, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawEllipse(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" draft="yes">
            <summary>Fills a pie shape.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a pie.</param>
            <param name="left">X-coordinate of the top left corner the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="top">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks>Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" /> method.
</para></remarks>
            <overloads><summary>Fills a pie shape.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Fills a pie shape.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a pie.</param>
            <param name="left">X-coordinate of the top left corner the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="top">Y-coordinate of the top left corner of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="width">Width of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="height">Height of the bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks><para>
Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)">
            <summary>Fills a pie shape.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a pie.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks><para>
Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPie(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF,System.Single,System.Single)">
            <summary>Fills a pie shape.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a pie.</param>
            <param name="rect">The bounding rectangle for the ellipse (see <b>Remarks</b> section).</param>
            <param name="startAngle">An angle between x-axis and the first radial line which defines a sector on the ellipse.</param>
            <param name="sweepAngle">An angle between first and second radial line which defines a sector on the ellipse.</param>
            <remarks><para>
Pie is an arc + two lines connecting arc ends with the center of the ellipse. In other words pie is defined with a tightest bounding rectangle of the ellipse and two angles which specifies necessary ellipse sector. 
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline a pie shape, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPie(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Point[])">
            <summary>Fills a polygon.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])" /> method.
</para><para>
By default it uses <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" /> fill mode.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
            <overloads><summary>Fills a polygon.</summary><remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)">
            <summary>Fills a polygon.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <param name="fillMode"><see cref="T:System.Drawing.Drawing2D.FillMode" /> value specifying fill mode used to fill the polygon (how to treat self-intersections).</param>
            <remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.PointF[])">
            <summary>Fills a polygon.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <remarks><para>
Polyline can be treated as closed polyline, where last point is connected with the first one. 
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF[])" /> method.
</para><para>
By default it uses <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" /> fill mode.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillPolygon(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)">
            <summary>Fills a polygon.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a polygon.</param>
            <param name="points">Array of coordinates of the polygon vertices.</param>
            <param name="fillMode"><see cref="T:System.Drawing.Drawing2D.FillMode" /> value specifying fill mode used to fill the polygon (how to treat self-intersections).</param>
            <remarks>Polyline can be treated as closed polyline, where last point is connected with the first one. 
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para><para>
To outline the polygon, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawPolygon(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.PointF[])" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Fills a rectangle.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a rectangle.</param>
            <param name="x">X-coordinate of the top left corner of the rectangle.</param>
            <param name="y">Y-coordinate of the top left corner of the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <remarks>To outline a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#DrawingShapesGdiGraphics"></code><code language="CS" source="DrawingCS/form1.cs#DrawingShapesGdiGraphics"></code></example>
            <overloads><summary>Fills a rectangle.</summary><remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)">
            <summary>Fills a rectangle.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a rectangle.</param>
            <param name="x">X-coordinate of the top left corner of the rectangle.</param>
            <param name="y">Y-coordinate of the top left corner of the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <remarks>To outline a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.Rectangle)">
            <summary>Fill a rectangle.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a rectangle.</param>
            <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> object to draw.</param>
            <remarks>To outline a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Rectangle)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FillRectangle(Aurigma.GraphicsMill.Drawing.Brush,System.Drawing.RectangleF)">
            <summary>Fill a rectangle.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> object which is used to fill a rectangle.</param>
            <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> object to draw.</param>
            <remarks>To outline a rectangle, use <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawRectangle(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.RectangleF)" /> method.
<para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Int32,System.Int32,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="x">X-coordinate of the point to start filling from.</param>
            <param name="y">Y-coordinate of the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
            <overloads><summary>Fills an arbitrary area with the specified color</summary><remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Int32,System.Int32,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="x">X-coordinate of the point to start filling from.</param>
            <param name="y">Y-coordinate of the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by the colors defined by filling brush.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors).</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Single,System.Single,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="x">X-coordinate of the point to start filling from.</param>
            <param name="y">Y-coordinate of the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Single,System.Single,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="x">X-coordinate of the point to start filling from.</param>
            <param name="y">Y-coordinate of the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by the colors defined by filling brush.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors).</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Drawing.Point,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="point"><see cref="T:System.Drawing.Point" /> structure specifying the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Drawing.Point,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="point"><see cref="T:System.Drawing.Point" /> structure specifying the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by the colors defined by filling brush.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors).</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Drawing.PointF,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="point"><see cref="T:System.Drawing.PointF" /> structure specifying the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FloodFill(System.Drawing.PointF,Aurigma.GraphicsMill.Drawing.Brush,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Fills an area of the display surface with the specified brush starting from specified point.</summary>
            <param name="point"><see cref="T:System.Drawing.PointF" /> structure specifying the point to start filling from.</param>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.Brush" /> class instance used to fill the surface. Currently only <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> is supported.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>).</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by the colors defined by filling brush.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors).</param>
            <remarks><note>
Flood fill can be applied only at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> which is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If you try to apply it at <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> associated with device context, method will throw an exception.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FromHdc(System.IntPtr)">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with the specified device context.</summary>
            <param name="hdc">Handle to a device context.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with the device context.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.FromHwnd(System.IntPtr)">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with the specified window handle.</summary>
            <param name="hwnd">Handle to a window.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object associated with the window.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetHdc">
            <summary>Gets the handle to the device context (HDC) associated with this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <returns>HDC associated with this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</returns>
            <remarks><para>
Using this method you can get access to Windows GDI-based structure called device context. It enables you to use the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with WinAPI functions.
</para><para>
You should never release this HDC with external means. This <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> will release it internally when being freed. It also means that this HDC is valid only while this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance is alive. If the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> is created at the <see cref="T:Aurigma.GraphicsMill.Bitmap" />, this bitmap also should be alive.
</para><para>
Unlike analogue method in <see cref="T:System.Drawing.Graphics" />, you still can call other methods of <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />. Moreover you can call this method multiple times (it will return the same value). However you should provide thread safety for access to this HDC. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetPixel(System.Int32,System.Int32)">
            <summary>Gets a color of a pixel at specified coordinates.</summary>
            <param name="x">Horizontal coordinate of the required pixel.</param>
            <param name="y">Vertical coordinate of the required pixel.</param>
            <returns>A color of the pixel at specified coordinates.</returns>
            <remarks><para>If the current <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> instance is opened for a device context, you should remember than not all devices have per-pixel access support. Also, the coordinates must be inside the clipping region.</para><note>This method works quite slow. It is ok to use it to get one color value, but if you need to process multiple pixels, it would be much faster to use direct access to memory.</note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetPixel(System.Int32,System.Int32,Aurigma.GraphicsMill.Color)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetVerticalResolution">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Height">
            <summary>Returns height of the drawing surface (in pixels).</summary>
            <value>Height of the drawing surface (in pixels).</value>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />, pixel height of this bitmap is returned. If it is associated with device context (DC), it returns DC pixel height.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Rectangle)" draft="yes">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by intersecting it with given rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure which specifies the rectangular area to intersect with the clip region.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <overloads><summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by intersecting it with given rectangular area or <see cref="T:System.Drawing.Region" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.RectangleF)">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by intersecting it with given rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.RectangleF" /> structure which specifies the rectangular area to intersect with the clip region.</param>
            <remarks><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Region)" draft="yes">
            <summary>Updates the clip region of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> by intersecting it with given <see cref="T:System.Drawing.Region" />.</summary>
            <param name="clipRegion"><see cref="T:System.Drawing.Region" /> structure which specifies the rectangular area to intersect with the clip region.</param>
            <remarks><note>
Unlike most methods of <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, the coordinates of the <see cref="T:System.Drawing.Region" /> are measured in pixels (not in in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.IsClipEmpty">
            <summary>Indicates if clipping region is empty for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />.</summary>
            <value>Value which equal to <b>true</b> when no clipping region is empty, <b>false</b> otherwise.</value>
            <remarks><para>
When clipping region is empty, all drawing functions do nothing.
</para><para>
To check if clipping region is larger than drawing surface (thus it does not affect nothing) use <see cref="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.IsClipInfinite" /> property.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.IsClipInfinite">
            <summary>Indicates if clipping region is larger than drawing surface.</summary>
            <value>Value which equal to <b>true</b> when no clipping region is infinite, <b>false</b> otherwise.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Lock">
            <summary>Locks the object.</summary>
            <remarks><para>
After calling this method this object is not accessible from any other thread (until <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Unlock" /> is called). You can safely check <see cref="P:Aurigma.GraphicsMill.LockableObject.Locked" /> property to ensure if object is locked.
</para><para>
When you access the object which has been locked, the thread stops and waits until it become unlocked. Using property <see cref="P:Aurigma.GraphicsMill.LockableObject.Timeout" /> you can specify how much time to wait.
</para><note>
All <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> method and properties already uses <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Lock" />/<see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.LogicalHeight">
            <summary>Returns height of the drawing surface (in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).</summary>
            <value>Height of the drawing surface (in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).</value>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />, height of this bitmap is returned. If it is associated with device context (DC), it returns DC height.
<para>
This value is measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.LogicalWidth">
            <summary>Returns width of the drawing surface (in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).</summary>
            <value>Width of the drawing surface (in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property).</value>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />, width of this bitmap is returned. If it is associated with device context (DC), it returns DC width.
<para>
This value is measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Mode">
            <summary>Gets the value that specifies whether the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> where opened at HDC or <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphicsMode" /> value that specifies whether the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> where opened at HDC or <see cref="T:Aurigma.GraphicsMill.Bitmap" />.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" /> object.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> object to associate this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> with.</param>
            <remarks><para>You cannot create several <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> instances associated with the same <see cref="T:Aurigma.GraphicsMill.Bitmap" />. If the <i>bitmap</i> argument is already used with some  <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, this constructor will fails. To release the bitmap from the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />, you should dispose it.</para><para>If you dispose the <i>bitmap</i> earlier than this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> instance, you will not be able to use it.  </para></remarks>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip">
            <summary>Resets clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class instance by setting it to infinite region (which absorbs this drawing surface).</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.Rectangle)">
            <summary>Replaces current clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with the rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure specifying new clipping region.</param>
            <remarks><para>
You can modify new clipping region later through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Rectangle)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Rectangle)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. It also can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
            <overloads><summary>Sets clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)">
            <summary>Combines current clipping region with given rectangle using specified set-theoretic operation.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure which is being combined with current clipping region.</param>
            <param name="combineMode"><see cref="T:System.Drawing.Drawing2D.CombineMode" /> value defining set-theoretic operation used to combine given rectangle with current clipping region.</param>
            <remarks><para>
You can also modify the clipping region through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Rectangle)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Rectangle)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. Clipping region can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.RectangleF)">
            <summary>Replaces current clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with the rectangular area.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure specifying new clipping region.</param>
            <remarks><para>
You can modify new clipping region later through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.RectangleF)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.RectangleF)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. It also can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)">
            <summary>Combines current clipping region with given rectangle using specified set-theoretic operation.</summary>
            <param name="clipRectangle"><see cref="T:System.Drawing.Rectangle" /> structure which is being combined with current clipping region.</param>
            <param name="combineMode"><see cref="T:System.Drawing.Drawing2D.CombineMode" /> value defining set-theoretic operation used to combine given rectangle with current clipping region.</param>
            <remarks><para>
You can also modify the clipping region through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Rectangle)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Rectangle)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. Clipping region can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
All the coordinates are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.Region)">
            <summary>Replaces current clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with given <see cref="T:System.Drawing.Region" />.</summary>
            <param name="clipRegion"><see cref="T:System.Drawing.Region" /> structure specifying new clipping region.</param>
            <remarks><para>
You can modify new clipping region later through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Region)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Region)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. It also can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
Unlike most other methods of the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class, coordinates of the region are measured in pixels.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)">
            <summary>Replaces current clipping region for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object with given <see cref="T:System.Drawing.Region" /> using specified set-theoretic operation.</summary>
            <param name="clipRegion"><see cref="T:System.Drawing.Region" /> structure specifying new clipping region.</param>
            <param name="combineMode"><see cref="T:System.Drawing.Drawing2D.CombineMode" /> value defining set-theoretic operation used to combine given rectangle with current clipping region.</param>
            <remarks><para>
You can also modify the clipping region later through <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ExcludeClip(System.Drawing.Region)" />, <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.IntersectClip(System.Drawing.Region)" /> and <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" /> methods. It also can be discarded with <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.ResetClip" /> property.
</para><para>
Unlike most other methods of the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class, coordinates of the region are measured in pixels.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetHorizontalResolution(System.Single)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetPixel(System.Int32,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Writes a color of a pixel at specified coordinates.</summary>
            <param name="x">Horizontal coordinate of the pixel you are changing.</param>
            <param name="y">Vertical coordinate of the pixel you are changing.</param>
            <param name="color">A color of the pixel you want to write to the specified coordinates.</param>
            <remarks><para>If the current <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> instance is opened for a device context, you should remember than not all devices have per-pixel access support. Also, the coordinates must be inside the clipping region.</para><note>This method works quite slow. It is ok to use it to write one color value, but if you need to process multiple pixels, it would be much faster to use direct access to memory.</note></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.GetPixel(System.Int32,System.Int32)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.SetVerticalResolution(System.Single)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Transform">
            <summary>Gets/sets world transformation for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
            <value><see cref="T:System.Drawing.Drawing2D.Matrix" /> structure defining affine transform for this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</value>
            <remarks>This transformation can be used to scale, rotate, shear, or translate graphics output. All the coordinates passed to drawing functions are multiplied on the matrix defining this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Int32,System.Int32)" draft="yes">
            <summary>Shifts the clipping region by given horizontal and vertical offset.</summary>
            <param name="dx">Horizontal offset of the clipping region.</param>
            <param name="dy">Vertical offset of the clipping region.</param>
            <overloads><summary>Shifts the clipping region by given horizontal and vertical offset.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.TranslateClip(System.Single,System.Single)">
            <summary>Shifts the clipping region by given horizontal and vertical offset.</summary>
            <param name="dx">Horizontal offset of the clipping region.</param>
            <param name="dy">Vertical offset of the clipping region.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Unlock">
            <summary>Unlocks the object previously locked with method <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" />.</summary>
            <remarks>Every time you call method <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Lock" /> object becomes unavailable until you call this method (the threads which access locked object are stopped until unlocking). That's why it is extremely important to call this method when you finished working with the object. 
<note>
All <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> method and properties already uses <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Lock" />/<see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.GdiGraphics.Width">
            <summary>Returns width of the drawing surface (in pixels).</summary>
            <value>Width of the drawing surface (in pixels).</value>
            <remarks>If this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> is associated with <see cref="T:Aurigma.GraphicsMill.Bitmap" />, pixel width of this bitmap is returned. If it is associated with device context (DC), it returns DC pixel width.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.GdiGraphicsMode">
            <summary>Contains modes of the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> object.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.GdiGraphicsMode.Bitmap">
            <summary>Bitmap.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.GdiGraphicsMode.Hdc">
            <summary>Handle to device context (HDC).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.HatchBrush">
            <summary>This class represents a brush which fills the shape with predefined pattern.</summary>
            <remarks><para>Hatch brush is defined with three parameters: hatch style or pattern (<see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.HatchStyle" /> property), foreground color, i.e. color of the pattern (<see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.ForegroundColor" /> property), and background color (<see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor" /> property). Besides of this, you can disable background with <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.TransparentBackground" /> property. In this case only pattern will be drawing with foreground on the underlying image.</para><para>
You can convert this brush instance into its analogue from <see cref="N:System.Drawing">System.Drawing</see> namespace using method <see cref="M:Aurigma.GraphicsMill.Drawing.HatchBrush.ToGdiplusBrush" />, or appropriate <see cref="M:Aurigma.GraphicsMill.Drawing.HatchBrush.op_Implicit(Aurigma.GraphicsMill.Drawing.HatchBrush)~System.Drawing.Drawing2D.HatchBrush">cast operator</see>.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#HatchBrush"></code><code language="CS" source="DrawingCS/form1.cs#HatchBrush"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor">
            <summary>Gets/sets background color for the hatch brush.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value specifying background color of the hatch brush.</value>
            <remarks>This value is used only if <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.TransparentBackground" /> property is set to <b>false</b>.
<para>
Classic GDI does not handle transparency, so it makes no sense to specify alpha channel for this color. 
</para><note type="caution">
For the same reason it is not recommended to draw with GDI on the images with 32-bit ARGB pixel format. It will fill alpha channel (which is treated with GDI as meaningless) with zeros. 
</note><para>
Default value is white color.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.HatchBrush.ForegroundColor">
            <summary>Gets/sets foreground color for the hatch brush. It is used to draw the hatch itself.</summary>
            <value>Foreground color for the hatch brush.</value>
            <remarks><para>
Classic GDI does not handle transparency, so it makes no sense to specify alpha channel for this color. 
</para><note type="caution">
For the same reason it is not recommended to draw with GDI on the images with 32-bit ARGB pixel format. It will fill alpha channel (which is treated with GDI as meaningless) with zeros. 
</note><para>
Default value is a black color.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.HatchBrush.HatchStyle">
            <summary>Gets/sets hatch style for this brush.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.HatchStyle" /> value specifying hatch style of the current brush.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Drawing.HatchStyle.Horizontal" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.#ctor" draft="yes">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> class.</summary>
            <overloads><summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.#ctor(Aurigma.GraphicsMill.Drawing.HatchStyle,Aurigma.GraphicsMill.RgbColor)">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> class. Here you construct hatch brush from hatch style and foreground color.</summary>
            <param name="hatchStyle"><see cref="T:Aurigma.GraphicsMill.Drawing.HatchStyle" /> value specifying hatch style of the brush. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.HatchStyle" />.</param>
            <param name="foreColor"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value specifying foreground color of the brush. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.ForegroundColor" />.</param>
            <remarks>When you create brush with this constructor, background is disabled. You can change this later by setting <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.TransparentBackground" /> property to <b>false</b> and specifying necessary value to the <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.#ctor(Aurigma.GraphicsMill.Drawing.HatchStyle,Aurigma.GraphicsMill.RgbColor,Aurigma.GraphicsMill.RgbColor)">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush" /> class. Here you construct hatch brush from hatch style and foreground color.</summary>
            <param name="hatchStyle"><see cref="T:Aurigma.GraphicsMill.Drawing.HatchStyle" /> value specifying hatch style of the brush. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.HatchStyle" />.</param>
            <param name="foreColor"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value specifying foreground color of the brush. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.ForegroundColor" />.</param>
            <param name="backColor"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value specifying background color of the brush. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor" />.</param>
            <remarks>When you create brush with this constructor, background is enabled. You can change this later by setting <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.TransparentBackground" /> property to <b>true</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.#ctor(System.Drawing.Drawing2D.HatchBrush)">
            <summary>Creates new hatch brush based on <see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> class instance.</summary>
            <param name="brush"><see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> class instance to copy brush data from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.op_Implicit(Aurigma.GraphicsMill.Drawing.HatchBrush)~System.Drawing.Drawing2D.HatchBrush" draft="yes">
            <summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush">Aurigma.GraphicsMill.Drawing.HatchBrush</see> to <see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see>.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush">Aurigma.GraphicsMill.Drawing.HatchBrush</see> value which is being casted.</param>
            <returns>Brush casted to <see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> class.</returns>
            <overloads><summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush">Aurigma.GraphicsMill.Drawing.HatchBrush</see> to <see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.op_Implicit(System.Drawing.Drawing2D.HatchBrush)~Aurigma.GraphicsMill.Drawing.HatchBrush">
            <summary>Casts an instance of <see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> to <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush">Aurigma.GraphicsMill.Drawing.HatchBrush</see>.</summary>
            <param name="brush"><see cref="T:System.Drawing.Drawing2D.HatchBrush">System.Drawing.Drawing2D.HatchBrush</see> value which is being casted.</param>
            <returns>Brush casted to <see cref="T:Aurigma.GraphicsMill.Drawing.HatchBrush">Aurigma.GraphicsMill.Drawing.HatchBrush</see> class.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.HatchBrush.ToGdiplusBrush">
            <summary>Converts the brush to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</summary>
            <returns>Brush converted to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.HatchBrush.TransparentBackground">
            <summary>Gets/sets the value which specifies whether to fill underlying image with the <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor" />. If <b>true</b>, brush will draw only hatch with <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.ForegroundColor" />.</summary>
            <value>Value specifying if to use <see cref="P:Aurigma.GraphicsMill.Drawing.HatchBrush.BackgroundColor" /> to fill background (<b>false</b>), or interpret it as transparent (<b>true</b>).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.HatchStyle">
            <summary>Contains hatch styles for hatch brush.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.BackwardDiagonal">
            <summary>Backward diagonal lines pattern.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.Cross">
            <summary>Crossed horizontal and vertical lines pattern.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.DiagonalCross">
            <summary>Crossed diagonal lines pattern.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.ForwardDiagonal">
            <summary>Forward diagonal lines pattern.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.Horizontal">
            <summary>Horizontal lines pattern.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HatchStyle.Vertical">
            <summary>Vertical lines pattern.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.HorizontalAlignment">
            <summary>Contains horizontal alignment types.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.Center" draft="yes">
            <summary>Align text along the center.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.JustifyAll" draft="yes">
            <summary>Align text along the left and right edges.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.JustifyCenter" draft="yes">
            <summary>Align text, except the last line of each paragraph, along the left and right edges. The last line has center alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.JustifyLeft" draft="yes">
            <summary>Align text, except the last line of each paragraph, along the left and right edges. The last line has left alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.JustifyRight" draft="yes">
            <summary>Align text, except the last line of each paragraph, along the left and right edges. The last line has right alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.Left" draft="yes">
            <summary>Align text along the left edge.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.HorizontalAlignment.Right" draft="yes">
            <summary>Align text along the right edge.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.LineCap">
            <summary>Contains line caps which are appended to the start and/or end of line drawn with <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> class.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.LineCap.Flat">
            <summary>Flat cap.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.LineCap.Round">
            <summary>Round cap.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.LineCap.Square">
            <summary>Square cap.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.Pen">
            <summary>This class defines settings of pen.</summary>
            <remarks><para>Pen is an object which is used to draw lines, curves, and outline shapes. You can specify a number of pen settings: <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Color" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Width" />, <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.DashStyle" />. Some properties are used to determine a behaviour of lines conjunctions, such as <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.LineJoin" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.MiterLimit" />. To specify a shape of the line ends, use <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.StartCap" /> and <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.EndCap" /> properties. </para><para>
When you draw closed shapes such as rectangles, ellipses, etc with a pen of large width (which is more than 1), there is an important parameter <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Alignment" /> that specifies the direction to widen the line (both directions evenly or inside the shape).
</para><para>If you need to get an invisible pen, use a static property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Empty" /> that returns empty pen. To check whether the pen is empty, use property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.IsEmpty" />.</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#PensAndBrushes1"></code><code language="CS" source="DrawingCS/form1.cs#PensAndBrushes1"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.Alignment">
            <summary>Gets/sets pen alignment.</summary>
            <value><see cref="T:System.Drawing.Drawing2D.PenAlignment">System.Drawing.Drawing2D.PenAlignment</see> value specifying current pen alignment.</value>
            <remarks>Pen alignment is necessary when pen <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Width" /> is more than 1. It means how line is positioned relatively to the pen center. Although <see cref="T:System.Drawing.Drawing2D.PenAlignment">System.Drawing.Drawing2D.PenAlignment</see> has five possible values, both GDI+ and Graphics Mill for .NET support only <see cref="F:System.Drawing.Drawing2D.PenAlignment.Center" /> and <see cref="F:System.Drawing.Drawing2D.PenAlignment.Inset" /> members. 
<para>
Default value is <see cref="F:System.Drawing.Drawing2D.PenAlignment.Center" />. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.Color">
            <summary>Gets/sets pen color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.RgbColor" /> value which is used to draw and outline with this pen.</value>
            <remarks>Classic GDI does not handle transparency, so it makes no sense to specify alpha channel for this color.
<note type="caution"> For the same reason it is not recommended to draw with GDI on the images with 32-bit ARGB pixel format. It will fill alpha channel (which is treated with GDI as meaningless) with zeros. From the other hand you can use it to emulate eraser tool functionality.</note><para>
Default pen color is black. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.DashStyle">
            <summary>Gets/sets style used for dashed lines drawn with this pen.</summary>
            <value><see cref="T:System.Drawing.Drawing2D.DashStyle" /> value representing dash style of the pen.</value>
            <remarks>Due GDI limitation you cannot use other dash style than <see cref="F:System.Drawing.Drawing2D.DashStyle.Solid" /> when pen width differs from 1.
<para>
Default value is <see cref="F:System.Drawing.Drawing2D.DashStyle.Solid" />.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.Empty">
            <summary>Returns an empty pen (which does not outline anything).</summary>
            <value>An empty pen.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.EndCap">
            <summary>Gets/sets a value specifying what cap to use at the end of lines drawn with this pen.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.LineCap" /> specifying a cap style of the line end.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Drawing.LineCap.Flat" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.IsEmpty">
            <summary>Indicates if the pen is empty.</summary>
            <value>Values specifying if the pen is empty.</value>
            <remarks>Empty pens do not outline anything.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.LineJoin">
            <summary>Gets/sets the join style for the ends of two consecutive lines drawn with this pen.</summary>
            <value><see cref="T:System.Drawing.Drawing2D.LineJoin" /> value specifying line join behaviour of the pen. <see cref="F:System.Drawing.Drawing2D.LineJoin.MiterClipped" /> value is not supported.</value>
            <remarks>This property affects only on those lines which are drawn with a single call (e.g. <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLines(Aurigma.GraphicsMill.Drawing.Pen,System.Drawing.Point[])" />). If you call <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawLine(Aurigma.GraphicsMill.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />multiple times, lines will not be joined.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.MiterLimit">
            <summary>Gets/sets the limit of the thickness of the join on a mitered corner.</summary>
            <value>The limit of the thickness of the join on a mitered corner.</value>
            <remarks>The miter length is the distance from the intersection of the line walls on the inside of the join to the intersection of the line walls outside of the join. The miter length can be large when the angle between two lines is small. The miter limit is the maximum allowed ratio of miter length to stroke width. The default value is 10.0.
<para>
If the miter length of the join of the intersection exceeds the limit of the join, then the join will be beveled to keep it within the limit of the join of the intersection. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.#ctor">
            <summary>Constructs new <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class instance.</summary>
            <overloads><summary>Constructs new <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class instance. </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.#ctor(Aurigma.GraphicsMill.RgbColor,System.Single)">
            <summary>Constructs new <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class instance. Such main pen settings of pen as width and color can be specified here.</summary>
            <param name="color">Color of the pen. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Color" />.</param>
            <param name="width">Width of the pen. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Width" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.#ctor(Aurigma.GraphicsMill.RgbColor,System.Single,System.Drawing.Drawing2D.DashStyle)">
            <summary>Constructs new <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class instance. You can set such parameters as pen width, color, and dash style.</summary>
            <param name="color">Color of the pen. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Color" />.</param>
            <param name="width">Width of the pen. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.Width" />.</param>
            <param name="style">Dash style of the pen. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.Pen.DashStyle" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.#ctor(System.Drawing.Pen)">
            <summary>Constructs new <see cref="T:Aurigma.GraphicsMill.Drawing.Pen" /> class instance. All pen settings are taken from standard <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> object.</summary>
            <param name="pen"><see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> class instance which is used to take settings from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.op_Implicit(Aurigma.GraphicsMill.Drawing.Pen)~System.Drawing.Pen" draft="yes">
            <summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.Pen">Aurigma.GraphicsMill.Drawing.Pen</see> to <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see>.</summary>
            <param name="pen"><see cref="T:Aurigma.GraphicsMill.Drawing.Pen">Aurigma.GraphicsMill.Drawing.Pen</see> value which is being casted.</param>
            <returns>Pen casted to <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> class.</returns>
            <overloads><summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.Pen">Aurigma.GraphicsMill.Drawing.Pen</see> to <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.op_Implicit(System.Drawing.Pen)~Aurigma.GraphicsMill.Drawing.Pen">
            <summary>Casts an instance of <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> to <see cref="T:Aurigma.GraphicsMill.Drawing.Pen">Aurigma.GraphicsMill.Drawing.Pen</see>.</summary>
            <param name="pen"><see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> value which is being casted.</param>
            <returns>Pen casted to <see cref="T:Aurigma.GraphicsMill.Drawing.Pen">Aurigma.GraphicsMill.Drawing.Pen</see> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.StartCap">
            <summary>Gets/sets a value specifying what cap to use at the beginning of lines drawn with this pen.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Drawing.LineCap" /> specifying a cap style of the line beginning.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.Pen.ToGdiplusPen">
            <summary>Converts the pen to <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> class.</summary>
            <returns>Pen converted to <see cref="T:System.Drawing.Pen">System.Drawing.Pen</see> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.Pen.Width">
            <summary>Gets/sets pen width.</summary>
            <value>The width of the pen.</value>
            <remarks><para>The width is measured in the same units as the <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> it is used at. Also, it uses the resolution of this <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" />.</para><para>Due GDI limitation you can use other dash style than <see cref="F:System.Drawing.Drawing2D.DashStyle.Solid" /> only when pen width is 1. </para><para>
Default value is 1. 
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.SolidBrush">
            <summary>Represents solid brush class.</summary>
            <remarks><para>
Solid brush is the simplest kind of brush. It fills the shape with solid color. This color is specified by property <see cref="P:Aurigma.GraphicsMill.Drawing.SolidBrush.Color" />. 
</para><para>
You can convert this brush instance into its analogue from <see cref="N:System.Drawing">System.Drawing</see> namespace using method <see cref="M:Aurigma.GraphicsMill.Drawing.SolidBrush.ToGdiplusBrush" />, or appropriate <see cref="M:Aurigma.GraphicsMill.Drawing.SolidBrush.op_Implicit(Aurigma.GraphicsMill.Drawing.SolidBrush)~System.Drawing.SolidBrush">cast operator</see>.
</para></remarks>
            <example><code language="VB" source="DrawingVB/form1.vb#PensAndBrushes3"></code><code language="CS" source="DrawingCS/form1.cs#PensAndBrushes3"></code></example>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Drawing.SolidBrush.Color">
            <summary>Gets/sets brush color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.RgbColor" /> instance which specifies color of the solid brush. Draw attention, you can use only RGB colors during drawing.</value>
            <remarks>Classic GDI does not handle transparency, so it makes no sense to specify alpha channel for this color. 
<note type="caution">
For the same reason it is not recommended to draw with GDI on the images with 32-bit ARGB pixel format. It will fill alpha channel (which is treated with GDI as meaningless) with zeros. From the other hand you can use it to emulate eraser tool functionality.
</note><para>
Default value is black color.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.#ctor">
            <summary>Creates new solid brush.</summary>
            <overloads><summary>Creates new solid brush.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.#ctor(Aurigma.GraphicsMill.RgbColor)">
            <summary>Creates new solid brush with given color.</summary>
            <param name="color">Brush color value. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Drawing.SolidBrush.Color" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.#ctor(System.Drawing.SolidBrush)">
            <summary>Creates new solid brush based on <see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> class instance.</summary>
            <param name="brush"><see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> class instance to copy brush data from.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.op_Implicit(Aurigma.GraphicsMill.Drawing.SolidBrush)~System.Drawing.SolidBrush" draft="yes">
            <summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush">Aurigma.GraphicsMill.Drawing.SolidBrush</see> to <see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see>.</summary>
            <param name="brush"><see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush">Aurigma.GraphicsMill.Drawing.SolidBrush</see> value which is being casted.</param>
            <returns>Brush casted to <see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> class.</returns>
            <overloads><summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush">Aurigma.GraphicsMill.Drawing.SolidBrush</see> to <see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.op_Implicit(System.Drawing.SolidBrush)~Aurigma.GraphicsMill.Drawing.SolidBrush">
            <summary>Casts an instance of <see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> to <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush">Aurigma.GraphicsMill.Drawing.SolidBrush</see>.</summary>
            <param name="brush"><see cref="T:System.Drawing.SolidBrush">System.Drawing.SolidBrush</see> value which is being casted.</param>
            <returns>Brush casted to <see cref="T:Aurigma.GraphicsMill.Drawing.SolidBrush">Aurigma.GraphicsMill.Drawing.SolidBrush</see> class.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Drawing.SolidBrush.ToGdiplusBrush">
            <summary>Converts the brush to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</summary>
            <returns>Brush converted to <see cref="T:System.Drawing.Pen">System.Drawing.Brush</see> class.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.TextTrimmingMode">
            <summary>Contains possible trimming modes which defines how to trim characters from a string so that the string fits into a layout rectangle (in <see cref="M:Aurigma.GraphicsMill.Drawing.GdiGraphics.DrawString(System.String,Aurigma.GraphicsMill.Drawing.Font,Aurigma.GraphicsMill.Drawing.SolidBrush,System.Drawing.Rectangle,Aurigma.GraphicsMill.Drawing.TextTrimmingMode,System.Boolean,System.Boolean,System.Boolean)" /> method).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.TextTrimmingMode.EndEllipsis">
            <summary>If the end of a string does not fit in the rectangle, it is truncated and ellipses are added. If a word that is not at the end of the string goes beyond the limits of the rectangle, it is truncated without ellipses.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.TextTrimmingMode.None">
            <summary>No ellipses are added.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.TextTrimmingMode.PathEllipsis">
            <summary>Replaces characters in the middle of the string with ellipses so that the result fits in the specified rectangle. If the string contains backslash (\) characters, this value preserves as much as possible of the text after the last backslash.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Drawing.VerticalAlignment">
            <summary>Contains vertical alignment types.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.VerticalAlignment.Baseline">
            <summary>Baseline alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.VerticalAlignment.Bottom">
            <summary>Bottom alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.VerticalAlignment.Center">
            <summary>Center alignment.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Drawing.VerticalAlignment.Top">
            <summary>Top alignment.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ErrorEventArgs">
            <summary>Provides data for events returning errors.</summary>
            <remarks>In particular errors are returned by <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ErrorEventArgs.Exception">
            <summary>Exception occured during the operation.</summary>
            <value>Exception occured during the operation.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ErrorEventArgs.#ctor(System.Exception)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ErrorEventArgs" /> class instance.</summary>
            <param name="exception">Exception occured during the operation.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Exception">
            <summary>The base exception of all the Graphics Mill for .NET exceptions.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.GetManagedException(System.IntPtr)">
            <summary>Converts unmanaged exception to managed. Should never used directly!</summary>
            <param name="unmanagedException">Pointer to unmanaged exception.</param>
            <returns>Managed exception.</returns>
            <remarks><para>This method is used by Graphics Mill for .NET infrastructure and should not be called directly. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Exception" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Exception" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Exception" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Exception.ThrowManagedException(System.IntPtr)">
            <summary>Used by Graphics Mill for .NET to convert internal unmanaged exception to managed ones. Do not call this method directly.</summary>
            <param name="unmanagedException">The pointer to the internal Graphics Mill for .NET unmanaged exception.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.GlobalSettings" draft="yes">
            <summary>This class provides access to the settings of Graphics Mill for .NET.</summary>
            <remarks>All the settings represented by this class properties affect Graphics Mill for .NET functionality on the whole. Also this class can expose some information about the system where Graphics Mill for .NET is launched.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GlobalSettings.Finalize">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.GlobalSettings.IsAdobeCmmAccessible" draft="yes">
            <summary>Indicates whether the Adobe CMM is installed on the computer.</summary>
            <remarks>If <b>true</b> the Adobe CMM is installed and accessible for use, otherwise it is <b>false</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.GlobalSettings.MultiProcessorSupport" draft="yes">
            <summary>Gets/sets a value which enables or disables multiprocessing.</summary>
            <value>Value specifying whether the multiprocessing should be enabled or not.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.GraphicsMillLibraryModule" draft="yes">
            <summary>This class represents Graphics Mill module.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.GraphicsMillLibraryModule.{dtor}" draft="yes">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.GraphicsMillLibraryModule.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.GraphicsMillLibraryModule.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.GraphicsMillLibraryModule.ShutDown" draft="yes">
            <summary>Explicitly deinitializes Graphics Mill module and releases all the temporary files created by this module.</summary>
            <remarks>Call this method after disposing all the created Graphics Mill objects and releasing all resources.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.GrayScaleColor">
            <summary>This class represents grayscale color value.</summary>
            <remarks><para>To get access to luminosity component use <see cref="P:Aurigma.GraphicsMill.GrayScaleColor.Gray" /> property. Alpha channel is available through <see cref="P:Aurigma.GraphicsMill.GrayScaleColor.A" /> property. Also there are extended versions of these properties (that returns 16-bit version of the component): <see cref="P:Aurigma.GraphicsMill.GrayScaleColor.Gray32" />, and <see cref="P:Aurigma.GraphicsMill.GrayScaleColor.A32" />.</para><para>Also you can get components by index using <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" /> method.</para><para>This class implements cast operator for other color types as well as for <see cref="T:System.Drawing.Color">System.Drawing.Color</see>. Note, when you convert colors, no color management is applied. To convert colors with color management, use <see cref="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.ColorProfile)" /> method of <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> class.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.A">
            <summary>Returns 8-bit alpha channel value (color opacity).</summary>
            <value>8-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.A32">
            <summary>Returns 16-bit  (extended) alpha channel value (color opacity).</summary>
            <value>16-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.ChannelCount">
            <summary>Returns number of channels available in this color.</summary>
            <value>Number of channels available in this color. <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> always returns 2 (alpha channel + luminosity channel).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.ColorSpace">
            <summary>Returns a color space of the color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value indicating color space of the color. <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> always returns <see cref="F:Aurigma.GraphicsMill.ColorSpace.GrayScale" />.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> with specified object.</summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />, exception will be raised.</param>
            <returns>Value specifying if given object represents the same color value as this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel(System.Int32)">
            <summary>Gets value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Non-extended (8-bit) value stored in specified channel.</returns>
            <remarks>You can also use extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel32(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel32(System.Int32)" /> returns extended (16-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel32(System.Int32)">
            <summary>Gets extended (16-bit) value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Extended (16-bit) value stored in specified channel.</returns>
            <remarks>You can also use non-extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.GrayScaleColor.GetChannel(System.Int32)" /> returns non-extended (8-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.GetHashCode">
            <summary>Returns a hash code for this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class.</summary>
            <returns>An integer value that specifies the hash code for this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.Gray">
            <summary>Returns 8-bit luminosity channel value.</summary>
            <value>Luminosity channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.GrayScaleColor.Gray32">
            <summary>Returns 16-bit luminosity channel value.</summary>
            <value>Luminosity channel value.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> instance. All channels are initialized with zeros, therefore this color will be represent absolutely black and transparent grayscale value.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(Aurigma.GraphicsMill.GrayScaleColor)~Aurigma.GraphicsMill.CmykColor" draft="yes">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> to <see cref="T:Aurigma.GraphicsMill.CmykColor" /> automatically converting it to CMYK color space.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
            <overloads><summary>Casts GrayScale color data format.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(Aurigma.GraphicsMill.GrayScaleColor)~Aurigma.GraphicsMill.RgbColor">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> to <see cref="T:Aurigma.GraphicsMill.RgbColor" /> automatically converting it to RGB color space.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(Aurigma.GraphicsMill.GrayScaleColor)~System.Int32">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to <see cref="T:System.Int32" /> containing extended numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to cast.</param>
            <returns><see cref="T:System.Int32" /> containing numerical representation of the color.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(Aurigma.GraphicsMill.GrayScaleColor)~System.Int64">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to <see cref="T:System.Int64" /> containing extended numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to cast.</param>
            <returns><see cref="T:System.Int64" /> containing extended numerical representation of the color.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(Aurigma.GraphicsMill.GrayScaleColor)~System.Drawing.Color">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance to cast.</param>
            <returns>Color value casted to <see cref="T:System.Drawing.Color">System.Drawing.Color</see>.</returns>
            <remarks>This <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> is always automatically converted from grayscale to RGB color space using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(System.Int32)~Aurigma.GraphicsMill.GrayScaleColor">
            <summary>Casts integer value to <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance.</summary>
            <param name="value"><see cref="T:System.Int32" /> containing numerical representation of the color.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance created from the integer value.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.op_Implicit(System.Int64)~Aurigma.GraphicsMill.GrayScaleColor">
            <summary>Casts long value to <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> class instance.</summary>
            <param name="value"><see cref="T:System.Int64" /> containing extended numerical representation of the color.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance created from the integer value.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.ToGdiplusColor">
            <summary>Returns <see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> does.</summary>
            <returns><see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> does.</returns>
            <remarks>This <see cref="T:Aurigma.GraphicsMill.GrayScaleColor">Aurigma.GraphicsMill.GrayScaleColor</see> is always automatically converted from grayscale to RGB color space using <see cref="M:Aurigma.GraphicsMill.Color.ConvertColorSpace(Aurigma.GraphicsMill.ColorSpace)" /> method. Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.ToInt32">
            <summary>Returns non-extended (8 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.ToInt64">
            <summary>Returns extended (16 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.GrayScaleColor.ToString">
            <summary>Returns a string representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</summary>
            <returns>Value containing a string representation of this <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" />.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.Histogram">
            <summary>This class represents bitmap histogram.</summary>
            <remarks><para>Histograms are widely used in imaging. It is represented as an array which has as much items as intensity levels are supported by bitmap (i.e. for 8 bit per channel bitmaps it will be 256, for 16 bit per channel - 65356).  Each histogram entry stores a number of bitmap pixels which have the same intensity level as index of this entry. For example, first histogram entry contains number of black pixels (i.e. pixels having zero intensity level). Entry at index 192 contains number of pixels with intensity level equal to 192. </para><para>
              When Graphics Mill for .NET builds a histogram for grayscale bitmap, it uses pixel value as an intensity level. For color bitmaps (RGB, CMYK) several algorithms for calculating intensity level of each pixel are available. Graphics Mill for .NET implements two of them:
            </para><list type="number"><item><term>Luminosity</term><description>Pixel color is converted to grayscale and this value is used as intensity level. This conversion is made by adding all channel values multiplied at weights (all weights are normalized at 1). These weights are selected with taking into consideration specifics of human vision, that's why it provides more precise result comparing to the <b>Sum</b> method. You can build luminosity histogram using <see cref="M:Aurigma.GraphicsMill.Histogram.BuildLuminosity(Aurigma.GraphicsMill.Bitmap)" /> method.</description></item><item><term>Sum</term><description>Graphics Mill for .NET calculates sum of all channels of the pixel and divides it by the count of channels. The advantage of this method is a possibility to exclude some channel from the intensity level calculation. This way you can get a histogram, e.g., for one or two channels. This method is implemented at Adobe Photoshop. To build sum histogram, use some of overload of <see cref="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Boolean[])" /> method.</description></item></list><para>Histogram enables you to estimate image contrast programmatically. Also you can get some other characteristics (<see cref="P:Aurigma.GraphicsMill.Histogram.Mean">mean brightness</see>, <see cref="P:Aurigma.GraphicsMill.Histogram.StandardDeviation">standard deviation</see>, <see cref="P:Aurigma.GraphicsMill.Histogram.Median">median</see>, etc). 
</para><para>
  Histogram is used (explicitly or implicitly) in number of Graphics Mill for .NET transforms, such as <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" />, <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" />, <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> (in automatic mode), etc.
</para></remarks>
            <example><code language="VB" source="LoadingAndSavingVB/form1.vb#GetHistogram"></code><code language="CS" source="LoadingAndSavingCS/form1.cs#GetHistogram"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildLuminosity(Aurigma.GraphicsMill.Bitmap)">
            <summary>Builds the histogram for specified bitmap. Histogram is based on pixels luminosity.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <overloads><summary>Builds the histogram for specified bitmap. Histogram is based on pixels luminosity.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildLuminosity(Aurigma.GraphicsMill.BitmapData)">
            <summary>Builds the histogram for specified bitmap data. Histogram is based on pixels luminosity.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Boolean[])">
            <summary>Builds the histogram for specified bitmap. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify what channels to include into this sum via <i>channels</i> argument.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="channels">Array of flags specifying what channels to use when calculating the histogram. If array item is <b>true</b>, the channel with appropriate index is used. Otherwise this channel is skipped.</param>
            <overloads><summary>Builds the histogram for specified bitmap. Histogram is based on average of pixel channels values.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Boolean)">
            <summary>Builds the histogram for specified bitmap. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify whether alpha channel should be included into this sum.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="useAlpha">If <b>true</b>, alpha channels is included (if available). Otherwise it is skipped. Typically alpha channel should be ignored when applying tone corrections.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Int32)">
            <summary>Builds the histogram for specified bitmap. Histogram is based on the value of channel at specified index.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="channel">Number of channel to build histogram for.</param>
            <remarks>This overload of <see cref="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Int32)" /> method can build histogram only for the single channel. If you need to build histogram for several channels (e.g. for two channels), you should use an <see cref="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.Bitmap,System.Boolean[])">overload with array of booleans</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.BitmapData,System.Boolean[])">
            <summary>Builds the histogram for specified bitmap data. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify what channels to include into this sum via <i>channels</i> argument.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="channels">Array of flags specifying what channels to use when calculating the histogram. If array item is <b>true</b>, the channel with appropriate index is used. Otherwise this channel is skipped.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.BitmapData,System.Boolean)">
            <summary>Builds the histogram for specified bitmap data. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify whether alpha channel should be included into this sum.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="useAlpha">If <b>true</b>, alpha channels is included (if available). Otherwise it is skipped. Typically alpha channel should be ignored when applying tone corrections.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.BitmapData,System.Int32)">
            <summary>Builds the histogram for specified bitmap data. Histogram is based on the value of channel at specified index.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="channel">Number of channel to build histogram for.</param>
            <remarks>This overload of <see cref="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.BitmapData,System.Int32)" /> method can build histogram only for the single channel. If you need to build histogram for several channels (e.g. for two channels), you should use an <see cref="M:Aurigma.GraphicsMill.Histogram.BuildSum(Aurigma.GraphicsMill.BitmapData,System.Boolean[])">overload with array of booleans</see>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Histogram" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Histogram" /> object containing full copy of the current object.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Histogram" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Histogram" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.GetEnumerator">
            <summary>Gets <see cref="T:System.Collections.IEnumerator" /> interface for iteration through this histogram entries.</summary>
            <returns><see cref="T:System.Collections.IEnumerator" /> interface for iteration through this histogram entries.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.IsEmpty">
            <summary>Indicates whether this object contains any data.</summary>
            <value>Value that indicates whether this object contains any data.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.IsExtended">
            <summary>Indicates whether the histogram entry is extended (16-bit).</summary>
            <value>Value that contains <b>true</b> when histogram entry is 16-bit, <b>false</b> is it is 8-bit.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.Item(System.Int32)">
            <summary>Gets/sets histogram entry by specified index.</summary>
            <param name="index">Index of the entry to get.</param>
            <value>Value that contains histogram entry at specified index.</value>
            <remarks>Maximum index value can be calculated as property <see cref="P:Aurigma.GraphicsMill.Histogram.Length" /> - 1.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.Length">
            <summary>Returns number of histogram entries.</summary>
            <value>Value that contains number of histogram entries. Depending on bitmap pixel format it is either 256 (if it is non-extended) or 65356 (if it is extended).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.Mean">
            <summary>Gets mean value of the histogram.</summary>
            <value>Value that contains mean value of the histogram.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.Median">
            <summary>Gets median value of the histogram.</summary>
            <value>Value that contains median value of the histogram.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.Bitmap)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap. Histogram is based on pixels luminosity.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.Bitmap,System.Boolean[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify what channels to include into this sum via <i>channels</i> argument.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="channels">Array of flags specifying what channels to use when calculating the histogram. If array item is <b>true</b>, the channel with appropriate index is used. Otherwise this channel is skipped.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.Bitmap,System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify whether alpha channel should be included into this sum.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="useAlpha">If <b>true</b>, alpha channels is included (if available). Otherwise it is skipped. Typically alpha channel should be ignored when applying tone corrections.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.Bitmap,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap. Histogram is based on the value of channel at specified index.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to build the histogram for.</param>
            <param name="channel">Number of channel to build histogram for.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.BitmapData)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap data. Histogram is based on pixels luminosity.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.BitmapData,System.Boolean[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap data. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify what channels to include into this sum via <i>channels</i> argument.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="channels">Array of flags specifying what channels to use when calculating the histogram. If array item is <b>true</b>, the channel with appropriate index is used. Otherwise this channel is skipped.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.BitmapData,System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap data. Histogram is based on average of pixel channels values (sum of these values divided at channels number). You can specify whether alpha channel should be included into this sum.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="useAlpha">If <b>true</b>, alpha channels is included (if available). Otherwise it is skipped. Typically alpha channel should be ignored when applying tone corrections.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Histogram.#ctor(Aurigma.GraphicsMill.BitmapData,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Histogram" /> instance and builds the histogram for specified bitmap data. Histogram is based on the value of channel at specified index.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance to build the histogram for.</param>
            <param name="channel">Number of channel to build histogram for.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Histogram.StandardDeviation">
            <summary>Gets standard deviation value of the histogram.</summary>
            <value>Value that contains standard deviation value of the histogram.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.HistogramMode">
            <summary>Contains modes for histogram building.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.HistogramMode.Luminosity">
            <summary>Histogram is built from pixels luminosity.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.HistogramMode.Sum">
            <summary>Histogram is built from average of pixels channels.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ILockable">
            <summary>This interface is implemented by all objects which are implementing thread-safe access.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ILockable.Lock">
            <summary>Locks the object.</summary>
            <remarks><para>
After calling this method this object is not accessible from any other thread (until <see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> is called). You can safely check <see cref="P:Aurigma.GraphicsMill.ILockable.Locked" /> property to ensure if object is locked.
</para><para>
When you access the object which has been locked, the thread stops and waits until it become unlocked. Using property <see cref="P:Aurigma.GraphicsMill.ILockable.Timeout" /> you can specify how much time to wait.
</para><note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" />/<see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ILockable.Locked">
            <summary>Indicates if the object has been locked.</summary>
            <value>Value indicating if the object has been locked.</value>
            <remarks>This property is always accessible (even if the object is locked). You can use it to check if method <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" /> was already executed, but <see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> was not.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ILockable.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ILockable.Unlock">
            <summary>Unlocks the object previously locked with method <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" />.</summary>
            <remarks>Every time you call method <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" /> object becomes unavailable until you call this method (the threads which access locked object are stopped until unlocking). That's why it is extremely important to call this method when you finished working with the object. 
<note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.ILockable.Lock" />/<see cref="M:Aurigma.GraphicsMill.ILockable.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.IPixelFormatSupport">
            <summary>This interface is implemented by all the objects which can accept bitmap as input argument (i.e. all transforms and encoders). It allows to check if this object can handle bitmap of specific pixel format.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.IPixelFormatSupport.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns whether the object can handle bitmaps with specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies a pixel format necessary to be checked.</param>
            <returns>Value that equal to <b>true</b> when specified pixel format is supported, or <b>false</b> otherwise.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.IPixelFormatSupport.SupportedPixelFormats">
            <summary>Returns an array of pixel formats which are supported with this object.</summary>
            <value>An array of <see cref="T:Aurigma.GraphicsMill.PixelFormat" /> values which are supported with this object.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.IStateNavigable">
            <summary>This interface should be implemented by classes which provide undo/redo functionality.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.CanRedo">
            <summary>Indicates if last reverted action can be redone.</summary>
            <value>Value specifying if last reverted action can be redone.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.CanUndo">
            <summary>Indicates if last change can be undone.</summary>
            <value>Value specifying if last change can be undone.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.ClearHistory">
            <summary>Discards both undo and redo history.</summary>
            <remarks><para>This method removes all temporary files which keep undo and redo history.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearRedoHistory" />
<seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearUndoHistory" />
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.ClearRedoHistory">
            <summary>Discards redo history.</summary>
            <remarks><para>This method removes all temporary files which keep redo history. Undo history is not removed.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearHistory" />
<seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearUndoHistory" />
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.ClearUndoHistory">
            <summary>Discards undo history.</summary>
            <remarks><para>This method removes all temporary files which keep undo history. Redo history is not removed.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearHistory" />
<seealso cref="M:Aurigma.GraphicsMill.IStateNavigable.ClearRedoHistory" />
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.MaxUndoStepCount">
            <summary>Gets/sets maximum number of available undo steps (levels).</summary>
            <value>Maximum number of available undo steps (levels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.Redo">
            <summary>Redoes last undone change.</summary>
            <remarks>This method can be used only if you already called <see cref="M:Aurigma.GraphicsMill.IStateNavigable.Undo" /> method. If no undone states are available this method will fail. You can check this with <see cref="P:Aurigma.GraphicsMill.IStateNavigable.CanRedo" /> property.</remarks>
            <overloads><summary>Redoes last undone change.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.Redo(System.Int32)">
            <summary>Redoes specified number of last undone actions.</summary>
            <param name="steps">Number of steps to redo.</param>
            <remarks>If <i>steps</i> argument is larger than number of steps available to redo, method will fail. To avoid this, use <see cref="P:Aurigma.GraphicsMill.IStateNavigable.RedoStepCount" /> property to check how much steps are left.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.IStateNavigable.Redoing">
            <summary>Fires when image is being redone (before starting).</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.IStateNavigable.Redone">
            <summary>Fires when operation has been redone (after finishing).</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.RedoStepCount">
            <summary>Returns number of available redo levels (i.e. how much time method <see cref="M:Aurigma.GraphicsMill.IStateNavigable.Redo" /> can be called).</summary>
            <value>Number of available redo steps (levels).</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.SaveState">
            <summary>Saves state of the object.</summary>
            <remarks>After you save the object state, you can revert to it using <see cref="M:Aurigma.GraphicsMill.IStateNavigable.Undo" /> method.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.Undo" draft="yes">
            <summary>Undoes last made change.</summary>
            <remarks>This method can be used only if you have saved object state at least once (using method <see cref="M:Aurigma.GraphicsMill.IStateNavigable.SaveState" />). If no states to undo are available, method will fail. You can check this with <see cref="P:Aurigma.GraphicsMill.IStateNavigable.CanUndo" /> property.</remarks>
            <overloads><summary>Undoes last made change.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.IStateNavigable.Undo(System.Int32)">
            <summary>Undoes specified number of last changes.</summary>
            <param name="steps">Number of steps to undo.</param>
            <remarks>If <i>steps</i> argument is larger than number of steps available to undo, method will fail. To avoid this, use <see cref="P:Aurigma.GraphicsMill.IStateNavigable.UndoStepCount" /> property to check how much steps are left.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.IStateNavigable.Undoing">
            <summary>Fires when image is being undone (before starting).</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.IStateNavigable.Undone">
            <summary>Fires when operation has been undone (after finishing).</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.UndoRedoEnabled">
            <summary>Enables or disables undo/redo functionality.</summary>
            <value>Value specifying if to enable undo/redo functionality.</value>
            <remarks>You can use this property to disable undo/redo functionality for some time. It is useful when for example, you apply some set of effects or draw a number of shapes as single atomic operation. In this case you likely do not want to undo sub-operations, but need to undo entire operation at once.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.UndoRedoTrackingEnabled" draft="yes">
            <summary>Enables or disables the automatic change tracking.</summary>
            <value>A value specifying whether the automatic change tracking should be enabled or not.</value>
            <remarks><para>If this property is set to <b>false</b>, the undo/redo functionality will be available, but you will have to manually save states to which the content can be reverted (using the <see cref="M:Aurigma.GraphicsMill.IStateNavigable.SaveState" /> method).</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.IStateNavigable.UndoStepCount">
            <summary>Returns number of available undo levels (i.e. how much time method <see cref="M:Aurigma.GraphicsMill.IStateNavigable.Undo" /> can be called).</summary>
            <value>Number of available undo steps (levels).</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.ISyncEvents">
            <summary>This interface contains events which should be implemented by all the classes which supports asynchronous mode.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Aborted">
            <summary>Fires when operation has been aborted.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Continued">
            <summary>Fires when operation has been resumed after being paused.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Paused">
            <summary>Fires when operation has been paused.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Progress">
            <summary>Fires on the operation progress notifications.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Started">
            <summary>Fires after operation has been started.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Starting">
            <summary>Fires before operation is started.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Stopped">
            <summary>Fires after operation has been stopped.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.ISyncEvents.Stopping">
            <summary>Fires before operation is stopped.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.ISyncHandler">
            <summary>This interface is implemented by all the codecs, transforms, as well as any other operations which can be run asynchronously.</summary>
            <remarks>Partial implementation of this interface is presented by <see cref="T:Aurigma.GraphicsMill.SyncHandler" /> class.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ISyncHandler.Abort">
            <summary>Aborts current operation.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.ISyncHandler.Completed">
            <summary>Returns value indicating if the operation is currently running.</summary>
            <value>Value that indicates whether the operation is currently running.</value>
            <remarks><para>
If the operation is running, this property returns <b>true</b>. Otherwise operation completed or never started), it returns <b>false</b>. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ISyncHandler.Continue">
            <summary>Resumes execution of the operation previously paused with <see cref="M:Aurigma.GraphicsMill.ISyncHandler.Pause" /> method.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.ISyncHandler.ExceptionThrowEnabled">
            <summary>Gets/sets value that specifies if to throw exception in synchronous mode.</summary>
            <value>Value that specifies if to throw exception in synchronous mode.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ISyncHandler.Pause">
            <summary>Pauses execution of the current operation.</summary>
            <remarks><para>
To resume the execution, use <see cref="M:Aurigma.GraphicsMill.ISyncHandler.Continue" /> method.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ISyncHandler.Priority">
            <summary>Gets/sets a priority for the auxilary thread.</summary>
            <value>The priority for the auxilary thread.</value>
            <remarks><para>The higher the priority, the faster the thread completes. But from the other hand, it consumes more resources, and that is why other threads are working slower.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ISyncHandler.SynchronizationMode">
            <summary>Gets/sets synchronization mode for the object.</summary>
            <value>Value that specifies the synchronization mode for the object.</value>
            <remarks><para>
              Currently Graphics Mill for .NET provides the following synchronization options:
            </para><list type="table"><listheader><term>Mode</term><term>Description</term></listheader><item><description>Synchronous mode</description><description>Operation (and its event handlers) is running in the application main thread.</description></item><item><description>Common asynchronous mode</description><description>Operation and its event handlers are running in the auxilary thread. </description></item><item><description>Asynchronous mode that uses main thread message loop</description><description>Operation is running in the auxilary thread, but its event handlers are running in the application main thread.</description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ISyncHandler.WaitForCompletion">
            <summary>Suspends the calling thread until the operation currently run is completed.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.IUnitConverter">
            <summary>This interface is implemented with all classes which needs to convert spatial values between different measurement units (like inches, millimeters, points, etc).</summary>
            <remarks>Graphics Mill for .NET provides two partial implementations of this interface: <see cref="T:Aurigma.GraphicsMill.UnitConverterObject" /> and <see cref="T:Aurigma.GraphicsMill.UnitConverterObject" /> classes.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.IUnitConverter.Unit">
            <summary>Gets/sets unit to convert from/to.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Unit" /> value, specifying target unit.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.LibraryModuleAbstract" draft="yes">
            <summary>This is a base class for all the classes representing Graphics Mill modules.</summary>
            <remarks><see cref="T:Aurigma.GraphicsMill.LibraryModuleAbstract" /> is an abstract class which implements common functionality Graphics Mill modules. You cannot instantiate objects of this class directly.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.LibraryModuleAbstract.{dtor}" draft="yes">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.LibraryModuleAbstract.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.LibraryModuleAbstract" />.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.LibraryModuleAbstract.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.LibraryModuleAbstract.Finalize">
            <exclude />
        </member>
        <member name="F:Aurigma.GraphicsMill.LibraryModuleAbstract.m_bIsDisposed">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.LibraryModuleAbstract.#ctor">
            <exclude />
        </member>
        <member name="N:Aurigma.GraphicsMill.Licensing" draft="yes">
            <summary>The <see cref="N:Aurigma.GraphicsMill.Licensing" /> namespaces includes classes intended to get information about registered license keys.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.GraphicsMillLicenseInformationProvider" draft="yes">
            <summary>This class is used to get the available licensing information for the current Graphics Mill for .NET assembly.</summary>
            <remarks><para>To get the licensing information about your copy of Graphics Mill for .NET read the <see cref="P:Aurigma.GraphicsMill.Licensing.GraphicsMillLicenseInformationProvider.BitmapLicenseInformation" /> property. This object will contain all available information about your license for Graphics Mill for .NET.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.GraphicsMillLicenseInformationProvider.BitmapLicenseInformation">
            <summary>Gets the available license information for the current copy of Graphics Mill for .NET.</summary>
            <value>Object containing the license information.</value>
            <remarks><para>Read properties of the returned object to get the information you are interested in.</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseAbstract">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseInformation">
            <summary>This class is a collection of properties representing the available license information.</summary>
            <remarks><para>Read this class properties to get the license information concerning your Graphics Mill for .NET assembly.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.EvaluationExpirationDate">
            <summary>Gets the expiration date of the evaluation period.</summary>
            <value>Date when the evaluation period ends.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.LicenseKeyIsExpired">
            <summary>Gets a value indicating whether the license key is already expired.</summary>
            <value>Value indicating whether the license key is already expired.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.LicenseKeySource">
            <summary>Gets the source from which the license key is read.</summary>
            <value>Member of the <see cref="T:Aurigma.GraphicsMill.Licensing.LicenseKeySource" /> enumeration, specifying the source from which the key is read.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.LiteVersion">
            <summary>Gets a value indicating whether the current license key works in a lite mode.</summary>
            <value>Value indicating whether the current license key works in a lite mode.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Licensing.LicenseInformation.#ctor(Aurigma.GraphicsMill.Licensing.LicenseAbstract)">
            <summary>Creates a new <see cref="T:Aurigma.GraphicsMill.Licensing.LicenseInformation" /> instance based on the provided license.</summary>
            <param name="license">License.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.ProfessionalVersion">
            <summary>Gets a value indicating whether the current license key works in a pro mode.</summary>
            <value>Value indicating whether the current license key works in a pro mode.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.ServerVersion">
            <summary>Gets a value indicating whether the current license is a server-based.</summary>
            <value>Value indicating whether the current license is a server-based.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.StandardVersion">
            <summary>Gets a value indicating whether the current license is a standard one.</summary>
            <value>Value indicating whether the current license is a standard one.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Licensing.LicenseInformation.TrialVersion">
            <summary>Gets a value indicating whether the current license is a trial one.</summary>
            <value>Value indicating whether the current license is a trial one.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseKeySource">
            <summary>Contains possible sources from which a key can be read.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Licensing.LicenseKeySource.EmbeddedIntoAssembly">
            <summary>Assembly code.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Licensing.LicenseKeySource.LicFileInWebBin">
            <summary><b>lic</b> file of the Web root <b>bin</b> folder.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Licensing.LicenseKeySource.LicFileNearAssembly">
            <summary><b>lic</b> file in the same folder as the assembly.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Licensing.LicenseKeySource.None">
            <summary>No key available.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Licensing.LicenseKeySource.Registry">
            <summary>System registry.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseKeyStatus">
            <exclude />
        </member>
        <member name="N:Aurigma.GraphicsMill.Licensing.LicenseProviderAbstract">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseProviderAbstract.LicenseKey">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseProviderAbstract">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.LicenseProviderAbstractLicenseKey">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Licensing.TimeBombLicenseAbstract">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.LockableObject">
            <summary>This class contains partial implementation of the <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface and used by all thread safe Graphics Mill for .NET classes.</summary>
            <remarks><para>All lockable objects (i.e. classes that are derived from <see cref="T:Aurigma.GraphicsMill.LockableObject" />) are thread safe. </para><para>To prevent the internal data of the object to be modified by another thread, use method <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" />. When you no longer needed to lock the object, unlock it with <see cref="M:Aurigma.GraphicsMill.LockableObject.Unlock" /> method. Note, standard Graphics Mill for .NET methods are locking the object when necessary, so you need not doing it yourself.</para><para>When you try to change the state of the object in the same thread where you lock the object, the deadlock will occur and the application will hang. That's why you should carefully work with locked objects. To verify whether object is locked, use <see cref="P:Aurigma.GraphicsMill.LockableObject.Locked" /> property. You can also use a timeout <see cref="P:Aurigma.GraphicsMill.LockableObject.Timeout" /> property to avoid hanging of the application during deadlock, however you should remember, that deadlock is a flaw in the logic of your code. So you should not rely at <see cref="P:Aurigma.GraphicsMill.LockableObject.Timeout" /> property as a solution of the deadlock problem.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="P:Aurigma.GraphicsMill.LockableObject._IsDisposed">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.LockableObject" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.LockableObject" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.Lock">
            <summary>Locks the object.</summary>
            <remarks><para>
After calling this method this object is not accessible from any other thread (until <see cref="M:Aurigma.GraphicsMill.LockableObject.Unlock" /> is called). If you try to lock the object twice (e.g. with two consequent calls of this method), <see cref="T:Aurigma.GraphicsMill.ObjectLockedException" />will be thrown. You can safely check <see cref="P:Aurigma.GraphicsMill.LockableObject.Locked" /> property to ensure if object is locked.
</para><para>
When you access the object which has been locked, the thread stops and waits until it become unlocked. Using property <see cref="P:Aurigma.GraphicsMill.LockableObject.Timeout" /> you can specify how much time to wait.
</para><note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" />/<see cref="M:Aurigma.GraphicsMill.LockableObject.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.LockableObject.Locked">
            <summary>Indicates if the object has been locked.</summary>
            <value>Value indicating if the object has been locked.</value>
            <remarks>This property is always accessible (even if the object is locked). You can use it to check if method <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" /> was already executed, but <see cref="M:Aurigma.GraphicsMill.LockableObject.Unlock" /> was not.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.#ctor">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.LockableObject.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.LockableObject.Unlock">
            <summary>Unlocks the object previously locked with method <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" />.</summary>
            <remarks>Every time you call method <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" /> object becomes unavailable until you call this method (the threads which access locked object are stopped until unlocking). That's why it is extremely important to call this method when you finished working with the object. 
<note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.LockableObject.Lock" />/<see cref="M:Aurigma.GraphicsMill.LockableObject.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.LockableObjectProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.MessageLoopNotPresentedException">
            <summary>The exception which arises when synchronization mode uses message loop, but no message loop is available.</summary>
            <remarks>This exception can be thrown only in single situation: when you try to use asynchronous mode which uses message loop of the application main thread (<see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" /> property equals to <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop" />), but message loop is not available (for example, you are writing a console application).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.MessageLoopNotPresentedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.MessageLoopNotPresentedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.MessageLoopNotPresentedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.MessageLoopNotPresentedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.MessageLoopNotPresentedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.MessageLoopNotPresentedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.MessageLoopNotPresentedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.MessageLoopNotPresentedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.ObjectEmptyException">
            <summary>This is a base class for exceptions raised when empty object (like bitmap or color palette) is accessed.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectEmptyException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectEmptyException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectEmptyException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectEmptyException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectEmptyException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectEmptyException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectEmptyException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectEmptyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.ObjectLockedException">
            <summary>This exception is thrown when you try to use a locked object in synchronous mode.</summary>
            <remarks>If you try to use a locked object in asynchronous mode, the calling thread will stop and wait until the object will be unlocked.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectLockedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectLockedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectLockedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectLockedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectLockedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectLockedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectLockedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectLockedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.ObjectNotOpenedException">
            <summary>This exception is thrown when you try to operate with an object which needs to be opened (like file format readers or writers), but which are not opened.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectNotOpenedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectNotOpenedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.ObjectNotOpenedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectNotOpenedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectNotOpenedException" /> class with a specified error message.</summary>
            <param name="name">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectNotOpenedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.ObjectNotOpenedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.ObjectNotOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.OperationNotCompletedException" draft="yes">
            <summary>This exception is thrown when you try to run an operation which is already running, or influence it in the way which is not allowed until operation is not completed.</summary>
            <remarks>For example, if you try to change <see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" /> property when operation is running, you will get this exception.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.OperationNotCompletedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.OperationNotCompletedException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.OperationNotCompletedException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.OperationNotCompletedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.OperationNotCompletedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.OperationNotCompletedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.OperationNotCompletedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.OperationNotCompletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.PixelFormat">
            <summary>Contains pixel formats supported by Graphics Mill for .NET.</summary>
            <remarks><note>GDI cannot handle bitmaps with an alpha channel (<see cref="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb" />) when it draws anything on it. As the high byte of 4-byte color must be zero in GDI, each pixel drawn with GDI becomes transparent. So now, if you try to call any drawing methods for the bitmaps with an alpha channel when using GDI, the <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> exception will be thrown.</note></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format16bppAGrayScale">
            <summary>16 bits per pixel. Grayscale with alpha channel. 8 bits are used for alpha channel and other 8 bits are used for luminosity level.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format16bppArgb1555">
            <summary>16 bits per pixel. RGB with alpha channel. 1 bit is used for the alpha component, and 5 bits each are used for the red, green, and blue components.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format16bppGrayScale">
            <summary>16 bits per pixel. Grayscale. All 16 bits are used for luminosity level (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format16bppRgb555">
            <summary>16 bits per pixel. RGB. 5 bits each are used for the red, green, and blue components. The rest bit is unused.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format16bppRgb565">
            <summary>16 bits per pixel. RGB. 5 bits each are used for the red, and blue components. 6 bits are used for green component.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format1bppIndexed">
            <summary>1 bit per pixel. Indexed.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb">
            <summary>24 bits per pixel. RGB. 8 bits each are used for the red, green, and blue components.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format32bppAGrayScale">
            <summary>32 bits per pixel. Grayscale with alpha channel. 16 bits are used for alpha channel and other 16 bits are used for luminosity level (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format32bppArgb">
            <summary>32 bits per pixel. RGB with alpha channel. 8 bits each are used for the alpha, red, green, and blue components.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format32bppCmyk">
            <summary>32 bits per pixel. CMYK. 8 bits each are used for the cyan, magenta, yellow, and black components.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format32bppRgb">
            <summary>32 bits per pixel. RGB. 8 bits each are used for the red, green, and blue components. The rest 8 bits are unused.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format40bppAcmyk">
            <summary>40 bits per pixel. CMYK with alpha channel. 8 bits each are used for the alpha, cyan, magenta, yellow, and black components.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format48bppRgb">
            <summary>48 bits per pixel. RGB. 16 bits each are used for the red, green, and blue components (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format4bppIndexed">
            <summary>4 bits per pixel. Indexed.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format64bppArgb">
            <summary>64 bits per pixel. RGB with alpha channel. 16 bits each are used for the alpha, red, green, and blue components (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format64bppCmyk">
            <summary>64 bits per pixel. CMYK. 16 bits each are used for the cyan, magenta, yellow, and black components (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format80bppAcmyk">
            <summary>80 bits per pixel. CMYK with alpha channel. 16 bits each are used for the alpha, cyan, magenta, yellow, and black components (extended pixel format).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale">
            <summary>8 bits per pixel. Grayscale. 8 bits are used for luminosity level.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed">
            <summary>8 bits per pixel. Indexed.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.PixelFormat.FormatUnknown">
            <summary>Undefined pixel format (returned when bitmap is not initialized).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.PixelFormatUtils">
            <summary>This class contains a number of static methods which provide functionality to work with <see cref="T:Aurigma.GraphicsMill.PixelFormat" /> values.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.AlphaChannelIndex(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns an index of the alpha channel for the specified pixel format.</summary>
            <param name="format">The pixel format to get an index of the alpha channel for.</param>
            <returns>An index of the alpha channel for the specified pixel format.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.BitsPerPixel(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns number of bits per pixel for specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Number of number of bits per pixel for specified pixel format.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.ChannelCount(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns number of channels (including alpha channel) supported by specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Number of channels (including alpha channel) supported by specified pixel format.</returns>
            <remarks>It will always return 1 for indexed bitmaps.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.ChannelCountWithoutAlpha(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns number of color channels (i.e. excluding alpha channel) supported by specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Number of color channels (excluding alpha channel) supported by specified pixel format.</returns>
            <remarks>It will always return 1 for indexed bitmaps.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.ColorSpace(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns color space of the specified pixel format.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> enumeration member that contains a color space of the specified pixel format.</returns>
            <remarks>Always <see cref="F:Aurigma.GraphicsMill.ColorSpace.Rgb" /> for indexed bitmaps.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.HasAlpha(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether pixel format supports alpha channel.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether pixel format supports alpha channel (<b>true</b>) or not (<b>false</b>).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.IsCmyk(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether pixel format belongs CMYK color space.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether pixel format belongs CMYK color space (<b>true</b>) or not (<b>false</b>).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.IsExtended(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether pixel format is extended (16 bits per channel).</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether pixel format supports alpha channel (<b>true</b>) or not (<b>false</b>).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.IsGrayScale(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether pixel format is grayscale.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether pixel format is grayscale (<b>true</b>) or not (<b>false</b>).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.IsIndexed(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether bitmap with this pixel format is indexed.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether bitmap with this pixel format is indexed (<b>true</b>) or not (<b>false</b>).</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.PixelFormatUtils.IsRgb(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Returns value that specifies whether pixel format belongs RGB color space.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> enumeration member to check.</param>
            <returns>Value that specifies whether pixel format belongs RGB color space (<b>true</b>) or not (<b>false</b>).</returns>
            <remarks>Always <b>true</b> for indexed bitmap.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.ProgressEventArgs">
            <summary>Provides data for progress notifications.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.ProgressEventArgs.Current">
            <summary>Current position of the progress.</summary>
            <value>Value specifying current position of the progress.</value>
            <remarks>This value is always less or equal to <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum" /> property. It is equal to <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum" /> only at the last progress notification and it indicates that operation was finished.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum">
            <summary>Maximum position of the progress.</summary>
            <value>Value specifying maximum position of the progress.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.ProgressEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.ProgressEventArgs" /> class instance.</summary>
            <param name="cur">Value specifying current position of the progress.</param>
            <param name="max">Value specifying maximum position of the progress.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.ProgressEventHandler">
            <summary>This delegate represents the method that will handle progress notifications.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Rational">
            <summary>This class represents signed rational numbers.</summary>
            <remarks><para>
Rational number is a number which may be represented as a division of two natural numbers.For example, 3/4, 2/1, 1/6, etc. Not all fractional numbers are rational. For example, a Pi number is <i>irrational</i> (i.e. cannot be represented as a division of two natural numbers).
</para><para>
This class provides an access to <see cref="P:Aurigma.GraphicsMill.Rational.Dividend" /> and <see cref="P:Aurigma.GraphicsMill.Rational.Divider" />. A <see cref="P:Aurigma.GraphicsMill.Rational.Divider" /> cannot be zero.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Rational.Dividend">
            <summary>Gets/sets dividend of the rational number.</summary>
            <value>Value that specifies dividend of the rational number (i.e. if represent rational number as <i>p/q</i>, dividend is <i>p</i>).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Rational.Divider">
            <summary>Gets/sets divider of the rational number.</summary>
            <value>Value that specifies divider of the rational number (i.e. if represent rational number as <i>p/q</i>, divider is <i>q</i>).</value>
            <remarks>Divider cannot equal to zero.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.Rational" /> with specified object.</summary>
            <param name="object">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.Rational" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.Rational" />, exception will be raised.</param>
            <returns>Value specifying whether given object represents the same value as this <see cref="T:Aurigma.GraphicsMill.Rational" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.GetHashCode">
            <summary>Returns a hash code for this <see cref="T:Aurigma.GraphicsMill.Rational" /> class.</summary>
            <returns>An integer value that specifies the hash code for this <see cref="T:Aurigma.GraphicsMill.Rational" /> class.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.Rational" /> instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Rational" /> instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.#ctor(System.Int32,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Rational" /> instance with specified dividend and divider.</summary>
            <param name="dividend">Value that specifies dividend of the rational number (i.e. if represent rational number as <i>p/q</i>, dividend is <i>p</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Rational.Dividend" /> property.</param>
            <param name="divider">Value that specifies divider of the rational number (i.e. if represent rational number as <i>p/q</i>, divider is <i>q</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Rational.Divider" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.op_Equality(Aurigma.GraphicsMill.Rational,Aurigma.GraphicsMill.Rational)">
            <summary>Compares <see cref="T:Aurigma.GraphicsMill.Rational" /> values for equality.</summary>
            <param name="object1">First <see cref="T:Aurigma.GraphicsMill.Rational" /> value.</param>
            <param name="object2">Second <see cref="T:Aurigma.GraphicsMill.Rational" /> value.</param>
            <returns>Value that is <b>true</b> when numbers are equal, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.op_Implicit(Aurigma.GraphicsMill.Rational)~System.Single">
            <summary>Converts this <see cref="T:Aurigma.GraphicsMill.Rational" /> class instance into <see cref="T:System.Single" /> value.</summary>
            <param name="object"><see cref="T:Aurigma.GraphicsMill.Rational" /> class instance which should be converted into <see cref="T:System.Single" />.</param>
            <returns><see cref="T:System.Single" /> converted from this <see cref="T:Aurigma.GraphicsMill.Rational" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.op_Inequality(Aurigma.GraphicsMill.Rational,Aurigma.GraphicsMill.Rational)">
            <summary>Compares <see cref="T:Aurigma.GraphicsMill.Rational" /> values for inequality.</summary>
            <param name="object1">First <see cref="T:Aurigma.GraphicsMill.Rational" /> value.</param>
            <param name="object2">Second <see cref="T:Aurigma.GraphicsMill.Rational" /> value.</param>
            <returns>Value that is <b>true</b> when numbers are inequal, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Rational.ToString">
            <summary>Returns string representation of this <see cref="T:Aurigma.GraphicsMill.Rational" /> class instance.</summary>
            <returns>A string representation of this <see cref="T:Aurigma.GraphicsMill.Rational" /> class instance.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.RgbColor">
            <summary>This class represents color value in RGB color space.</summary>
            <remarks><para>To get access to red, green, and blue component use <see cref="P:Aurigma.GraphicsMill.RgbColor.R" />, <see cref="P:Aurigma.GraphicsMill.RgbColor.G" />, and <see cref="P:Aurigma.GraphicsMill.RgbColor.B" /> properties accordingly. Alpha channel is available through <see cref="P:Aurigma.GraphicsMill.RgbColor.A" /> property. Also there are extended versions of these properties (that returns 16-bit version of the component). These properties have a suffix 32 (e.g. <see cref="P:Aurigma.GraphicsMill.RgbColor.R32" />, etc).</para><para>Also you can get components by index using <see cref="M:Aurigma.GraphicsMill.CmykColor.GetChannel(System.Int32)" /> method.</para><para>This class implements cast operator for other color types as well as for <see cref="T:System.Drawing.Color">System.Drawing.Color</see>. Note, when you convert colors, no color management is applied. To convert colors with color management, use <see cref="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.ColorProfile)" /> method of <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> class.</para><para>There are a number static properties which return predefined colors, such as <see cref="P:Aurigma.GraphicsMill.RgbColor.Red" />, <see cref="P:Aurigma.GraphicsMill.RgbColor.Maroon" />, <see cref="P:Aurigma.GraphicsMill.RgbColor.Pink" />, <see cref="P:Aurigma.GraphicsMill.RgbColor.SeaGreen" />, etc.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.A">
            <summary>Returns 8-bit alpha channel value (color opacity).</summary>
            <value>8-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.A32">
            <summary>Returns 16-bit  (extended) alpha channel value (color opacity).</summary>
            <value>16-bit alpha channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.AliceBlue">
            <summary>Alice blue color.</summary>
            <value>Value that represents alice blue color.</value>
            <remarks><span style="color:black;background-color:aliceblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.AntiqueWhite">
            <summary>Antique white color.</summary>
            <value>Value that represents antique white color.</value>
            <remarks><span style="color:black;background-color:antiquewhite">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Aqua">
            <summary>Aqua color.</summary>
            <value>Value that represents aqua color.</value>
            <remarks><span style="color:black;background-color:aqua">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Azure">
            <summary>Azure color.</summary>
            <value>Value that represents azure color.</value>
            <remarks><span style="color:black;background-color:azure">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.B">
            <summary>Returns 8-bit blue channel value.</summary>
            <value>Blue channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.B32">
            <summary>Returns 16-bit blue channel value.</summary>
            <value>Blue channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Beige">
            <summary>Beige color.</summary>
            <value>Value that represents beige color.</value>
            <remarks><span style="color:black;background-color:beige">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Bisque">
            <summary>Bisque color.</summary>
            <value>Value that represents bisque color.</value>
            <remarks><span style="color:black;background-color:bisque">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Black">
            <summary>Black color.</summary>
            <value>Value that represents black color.</value>
            <remarks><span style="color:white;background-color:black">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.BlanchedAlmond">
            <summary>Blanched almond color.</summary>
            <value>Value that represents blanched almond color.</value>
            <remarks><span style="color:black;background-color:blanchedalmond">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Blue">
            <summary>Blue color.</summary>
            <value>Value that represents blue color.</value>
            <remarks><span style="color:black;background-color:blue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.BlueViolet">
            <summary>Blue violet color.</summary>
            <value>Value that represents blue violet color.</value>
            <remarks><span style="color:black;background-color:blueviolet">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Brown">
            <summary>Brown color.</summary>
            <value>Value that represents brown color.</value>
            <remarks><span style="color:black;background-color:brown">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.BurlyWood">
            <summary>Burly wood color.</summary>
            <value>Value that represents burly wood color.</value>
            <remarks><span style="color:black;background-color:burlywood">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.CadetBlue">
            <summary>Cadet blue color.</summary>
            <value>Value that represents cadet blue color.</value>
            <remarks><span style="color:black;background-color:cadetblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.ChannelCount">
            <summary>Returns number of channels available in this color.</summary>
            <value>Number of channels available in this color. <see cref="T:Aurigma.GraphicsMill.RgbColor" /> always returns 4 (alpha channel + 3 color channels).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Chartreuse">
            <summary>Chartreuse color.</summary>
            <value>Value that represents chartreuse color.</value>
            <remarks><span style="color:black;background-color:chartreuse">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Chocolate">
            <summary>Chocolate color.</summary>
            <value>Value that represents chocolate color.</value>
            <remarks><span style="color:black;background-color:chocolate">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.RgbColor" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.ColorSpace">
            <summary>Returns a color space of the color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorSpace" /> value indicating color space of the color. <see cref="T:Aurigma.GraphicsMill.RgbColor" /> always returns <see cref="F:Aurigma.GraphicsMill.ColorSpace.Rgb" />.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Coral">
            <summary>Coral color.</summary>
            <value>Value that represents coral color.</value>
            <remarks><span style="color:black;background-color:coral">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.CornflowerBlue">
            <summary>Cornflower blue color.</summary>
            <value>Value that represents cornflower blue color.</value>
            <remarks><span style="color:black;background-color:cornflowerblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Cornsilk">
            <summary>Cornsilk color.</summary>
            <value>Value that represents cornsilk color.</value>
            <remarks><span style="color:black;background-color:cornsilk">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Crimson">
            <summary>Crimson color.</summary>
            <value>Value that represents crimson color.</value>
            <remarks><span style="color:black;background-color:crimson">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Cyan">
            <summary>Cyan color.</summary>
            <value>Value that represents cyan color.</value>
            <remarks><span style="color:black;background-color:cyan">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkBlue">
            <summary>Dark blue color.</summary>
            <value>Value that represents dark blue color.</value>
            <remarks><span style="color:white;background-color:darkblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkCyan">
            <summary>Dark cyan color.</summary>
            <value>Value that represents dark cyan color.</value>
            <remarks><span style="color:black;background-color:darkcyan">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkGoldenrod">
            <summary>Dark goldenrod color.</summary>
            <value>Value that represents dark goldenrod color.</value>
            <remarks><span style="color:black;background-color:darkgoldenrod">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkGray">
            <summary>Dark gray color.</summary>
            <value>Value that represents dark gray color.</value>
            <remarks><span style="color:black;background-color:darkgray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkGreen">
            <summary>Dark green color.</summary>
            <value>Value that represents dark green color.</value>
            <remarks><span style="color:black;background-color:darkgreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkKhaki">
            <summary>Dark khaki color.</summary>
            <value>Value that represents dark khaki color.</value>
            <remarks><span style="color:black;background-color:darkkhaki">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkMagenta">
            <summary>Dark magenta color.</summary>
            <value>Value that represents dark magenta color.</value>
            <remarks><span style="color:black;background-color:darkmagenta">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkOliveGreen">
            <summary>Dark olive green color.</summary>
            <value>Value that represents dark olive green color.</value>
            <remarks><span style="color:white;background-color:darkolivegreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkOrange">
            <summary>Dark orange color.</summary>
            <value>Value that represents dark orange color.</value>
            <remarks><span style="color:black;background-color:darkorange">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkOrchid">
            <summary>Dark orchid color.</summary>
            <value>Value that represents dark orchid color.</value>
            <remarks><span style="color:black;background-color:darkorchid">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkRed">
            <summary>Dark red color.</summary>
            <value>Value that represents dark red color.</value>
            <remarks><span style="color:black;background-color:darkred">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkSalmon">
            <summary>Dark salmon color.</summary>
            <value>Value that represents dark salmon color.</value>
            <remarks><span style="color:black;background-color:darksalmon">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkSeaGreen">
            <summary>Dark sea green color.</summary>
            <value>Value that represents dark sea green color.</value>
            <remarks><span style="color:black;background-color:darkseagreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkSlateBlue">
            <summary>Dark slate blue color.</summary>
            <value>Value that represents dark slate blue color.</value>
            <remarks><span style="color:black;background-color:darkslateblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkSlateGray">
            <summary>Dark slate gray color.</summary>
            <value>Value that represents dark slate gray color.</value>
            <remarks><span style="color:white;background-color:darkslategray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkTurquoise">
            <summary>Dark turquoise color.</summary>
            <value>Value that represents dark turquoise color.</value>
            <remarks><span style="color:black;background-color:darkturquoise">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DarkViolet">
            <summary>Dark violet color.</summary>
            <value>Value that represents dark violet color.</value>
            <remarks><span style="color:black;background-color:darkviolet">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DeepPink">
            <summary>Deep pink color.</summary>
            <value>Value that represents deep pink color.</value>
            <remarks><span style="color:black;background-color:deeppink">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DeepSkyBlue">
            <summary>Deep sky blue color.</summary>
            <value>Value that represents deep sky blue color.</value>
            <remarks><span style="color:black;background-color:deepskyblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DimGray">
            <summary>Dim gray color.</summary>
            <value>Value that represents dim gray color.</value>
            <remarks><span style="color:black;background-color:dimgray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.DodgerBlue">
            <summary>Dodger blue color.</summary>
            <value>Value that represents dodger blue color.</value>
            <remarks><span style="color:black;background-color:dodgerblue">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> with specified object.</summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.RgbColor" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.RgbColor" />, exception will be raised.</param>
            <returns>Value specifying if given object represents the same color value as this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Firebrick">
            <summary>Firebrick color.</summary>
            <value>Value that represents firebrick color.</value>
            <remarks><span style="color:black;background-color:firebrick">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.FloralWhite">
            <summary>Floral white color.</summary>
            <value>Value that represents floral white color.</value>
            <remarks><span style="color:black;background-color:floralwhite">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.ForestGreen">
            <summary>Forest green color.</summary>
            <value>Value that represents forest green color.</value>
            <remarks><span style="color:black;background-color:forestgreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Fuchsia">
            <summary>Fuchsia color.</summary>
            <value>Value that represents fuchsia color.</value>
            <remarks><span style="color:black;background-color:fuchsia">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.G">
            <summary>Returns 8-bit green channel value.</summary>
            <value>Green channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.G32">
            <summary>Returns 16-bit green channel value.</summary>
            <value>Green channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Gainsboro">
            <summary>Gainsboro color.</summary>
            <value>Value that represents gainsboro color.</value>
            <remarks><span style="color:black;background-color:gainsboro">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.GetChannel(System.Int32)">
            <summary>Gets value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Non-extended (8-bit) value stored in specified channel.</returns>
            <remarks>You can also use extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.RgbColor.GetChannel32(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.RgbColor.GetChannel32(System.Int32)" /> returns extended (16-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.GetChannel32(System.Int32)">
            <summary>Gets extended (16-bit) value stored in specified channel of this color.</summary>
            <param name="index">Number of the channel.</param>
            <returns>Extended (16-bit) value stored in specified channel.</returns>
            <remarks>You can also use non-extended version of this property, i.e. <see cref="M:Aurigma.GraphicsMill.RgbColor.GetChannel(System.Int32)" />. Unlike this property, <see cref="M:Aurigma.GraphicsMill.RgbColor.GetChannel(System.Int32)" /> returns non-extended (8-bit) value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.GetHashCode">
            <summary>Returns a hash code for this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class.</summary>
            <returns>An integer value that specifies the hash code for this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.GhostWhite">
            <summary>Ghost white color.</summary>
            <value>Value that represents ghost white color.</value>
            <remarks><span style="color:black;background-color:ghostwhite">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Gold">
            <summary>Gold color.</summary>
            <value>Value that represents gold color.</value>
            <remarks><span style="color:black;background-color:gold">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Goldenrod">
            <summary>Goldenrod color.</summary>
            <value>Value that represents goldenrod color.</value>
            <remarks><span style="color:black;background-color:goldenrod">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Gray">
            <summary>Gray color.</summary>
            <value>Value that represents gray color.</value>
            <remarks><span style="color:black;background-color:gray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Green">
            <summary>Green color.</summary>
            <value>Value that represents green color.</value>
            <remarks><span style="color:black;background-color:green">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.GreenYellow">
            <summary>Green yellow color.</summary>
            <value>Value that represents green yellow color.</value>
            <remarks><span style="color:black;background-color:greenyellow">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Honeydew">
            <summary>Honeydew color.</summary>
            <value>Value that represents honeydew color.</value>
            <remarks><span style="color:black;background-color:honeydew">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.HotPink">
            <summary>Hot pink color.</summary>
            <value>Value that represents hot pink color.</value>
            <remarks><span style="color:black;background-color:hotpink">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.IndianRed">
            <summary>Indian red color.</summary>
            <value>Value that represents indian red color.</value>
            <remarks><span style="color:black;background-color:indianred">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Indigo">
            <summary>Indigo color.</summary>
            <value>Value that represents indigo color.</value>
            <remarks><span style="color:white;background-color:indigo">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Khaki">
            <summary>Khaki color.</summary>
            <value>Value that represents khaki color.</value>
            <remarks><span style="color:black;background-color:khaki">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Lavender">
            <summary>Lavender color.</summary>
            <value>Value that represents lavender color.</value>
            <remarks><span style="color:black;background-color:lavender">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LavenderBlush">
            <summary>Lavender blush color.</summary>
            <value>Value that represents lavender blush color.</value>
            <remarks><span style="color:black;background-color:lavenderblush">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LawnGreen">
            <summary>Lawn green color.</summary>
            <value>Value that represents lawn green color.</value>
            <remarks><span style="color:black;background-color:lawngreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LemonChiffon">
            <summary>Lemon chiffon color.</summary>
            <value>Value that represents lemon chiffon color.</value>
            <remarks><span style="color:black;background-color:lemonchiffon">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightBlue">
            <summary>Light blue color.</summary>
            <value>Value that represents light blue color.</value>
            <remarks><span style="color:black;background-color:lightblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightCoral">
            <summary>Light coral color.</summary>
            <value>Value that represents light coral color.</value>
            <remarks><span style="color:black;background-color:lightcoral">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightCyan">
            <summary>Light cyan color.</summary>
            <value>Value that represents light cyan color.</value>
            <remarks><span style="color:black;background-color:lightcyan">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightGoldenrodYellow">
            <summary>Light goldenrod yellow color.</summary>
            <value>Value that represents light goldenrod yellow color.</value>
            <remarks><span style="color:black;background-color:lightgoldenrodyellow">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightGray">
            <summary>Light gray color.</summary>
            <value>Value that represents light gray color.</value>
            <remarks><span style="color:black;background-color:lightgray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightGreen">
            <summary>Light green color.</summary>
            <value>Value that represents light green color.</value>
            <remarks><span style="color:black;background-color:lightgreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightPink">
            <summary>Light pink color.</summary>
            <value>Value that represents light pink color.</value>
            <remarks><span style="color:black;background-color:lightpink">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightSalmon">
            <summary>Light salmon color.</summary>
            <value>Value that represents light salmon color.</value>
            <remarks><span style="color:black;background-color:lightsalmon">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightSeaGreen">
            <summary>Light sea green color.</summary>
            <value>Value that represents light sea green color.</value>
            <remarks><span style="color:black;background-color:lightseagreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightSkyBlue">
            <summary>Light sky blue color.</summary>
            <value>Value that represents light sky blue color.</value>
            <remarks><span style="color:black;background-color:lightskyblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightSlateGray">
            <summary>Light slate gray color.</summary>
            <value>Value that represents light slate gray color.</value>
            <remarks><span style="color:black;background-color:lightslategray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightSteelBlue">
            <summary>Light steel blue color.</summary>
            <value>Value that represents light steel blue color.</value>
            <remarks><span style="color:black;background-color:lightsteelblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LightYellow">
            <summary>Light yellow color.</summary>
            <value>Value that represents light yellow color.</value>
            <remarks><span style="color:black;background-color:lightyellow">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Lime">
            <summary>Lime color.</summary>
            <value>Value that represents lime color.</value>
            <remarks><span style="color:black;background-color:lime">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.LimeGreen">
            <summary>Lime green color.</summary>
            <value>Value that represents lime green color.</value>
            <remarks><span style="color:black;background-color:limegreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Linen">
            <summary>Linen color.</summary>
            <value>Value that represents linen color.</value>
            <remarks><span style="color:black;background-color:linen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Magenta">
            <summary>Magenta color.</summary>
            <value>Value that represents magenta color.</value>
            <remarks><span style="color:black;background-color:magenta">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Maroon">
            <summary>Maroon color.</summary>
            <value>Value that represents maroon color.</value>
            <remarks><span style="color:white;background-color:maroon">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumAquamarine">
            <summary>Medium aquamarine color.</summary>
            <value>Value that represents medium aquamarine color.</value>
            <remarks><span style="color:black;background-color:mediumaquamarine">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumBlue">
            <summary>Medium blue color.</summary>
            <value>Value that represents medium blue color.</value>
            <remarks><span style="color:white;background-color:mediumblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumOrchid">
            <summary>Medium orchid color.</summary>
            <value>Value that represents medium orchid color.</value>
            <remarks><span style="color:black;background-color:mediumorchid">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumPurple">
            <summary>Medium purple color.</summary>
            <value>Value that represents medium purple color.</value>
            <remarks><span style="color:black;background-color:mediumpurple">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumSeaGreen">
            <summary>Medium sea green color.</summary>
            <value>Value that represents medium sea green color.</value>
            <remarks><span style="color:black;background-color:mediumseagreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumSlateBlue">
            <summary>Medium slate blue color.</summary>
            <value>Value that represents medium slate blue color.</value>
            <remarks><span style="color:black;background-color:mediumslateblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumSpringGreen">
            <summary>Medium spring green color.</summary>
            <value>Value that represents medium spring green color.</value>
            <remarks><span style="color:black;background-color:mediumspringgreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumTurquoise">
            <summary>Medium turquoise color.</summary>
            <value>Value that represents medium turquoise color.</value>
            <remarks><span style="color:black;background-color:mediumturquoise">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MediumVioletRed">
            <summary>Medium violet red color.</summary>
            <value>Value that represents medium violet red color.</value>
            <remarks><span style="color:white;background-color:mediumvioletred">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MidnightBlue">
            <summary>Midnight blue color.</summary>
            <value>Value that represents midnight blue color.</value>
            <remarks><span style="color:white;background-color:midnightblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MintCream">
            <summary>Mint cream color.</summary>
            <value>Value that represents mint cream color.</value>
            <remarks><span style="color:black;background-color:mintcream">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.MistyRose">
            <summary>Misty rose color.</summary>
            <value>Value that represents misty rose color.</value>
            <remarks><span style="color:black;background-color:mistyrose">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Moccasin">
            <summary>Moccasin color.</summary>
            <value>Value that represents moccasin color.</value>
            <remarks><span style="color:black;background-color:moccasin">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.NavajoWhite">
            <summary>Navajo white color.</summary>
            <value>Value that represents navajo white color.</value>
            <remarks><span style="color:black;background-color:navajowhite">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Navy">
            <summary>Navy color.</summary>
            <value>Value that represents navy color.</value>
            <remarks><span style="color:black;background-color:navy">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.#ctor">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.RgbColor" /> instance. All channels are initialized with zeros, therefore this color will be represent absolutely black and transparent RGB value.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.OldLace">
            <summary>Old lace color.</summary>
            <value>Value that represents old lace color.</value>
            <remarks><span style="color:black;background-color:oldlace">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Olive">
            <summary>Olive color.</summary>
            <value>Value that represents olive color.</value>
            <remarks><span style="color:black;background-color:olive">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.OliveDrab">
            <summary>Olive drab color.</summary>
            <value>Value that represents olive drab color.</value>
            <remarks><span style="color:black;background-color:olivedrab">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(Aurigma.GraphicsMill.RgbColor)~Aurigma.GraphicsMill.CmykColor" draft="yes">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> to <see cref="T:Aurigma.GraphicsMill.CmykColor" /> automatically converting it to CMYK color space.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.CmykColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
            <overloads><summary>Casts RGB color data format.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(Aurigma.GraphicsMill.RgbColor)~Aurigma.GraphicsMill.GrayScaleColor">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> to <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> automatically converting it to grayscale.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance to cast.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.GrayScaleColor" /> class instance.</returns>
            <remarks>Note, no color management is applied in this case and colors may be reproduced inaccurately.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(Aurigma.GraphicsMill.RgbColor)~System.Int32">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> to <see cref="T:System.Int32" /> containing numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance to cast.</param>
            <returns><see cref="T:System.Int32" /> containing extended numerical representation of the color.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(Aurigma.GraphicsMill.RgbColor)~System.Int64">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> to <see cref="T:System.Int64" /> containing extended numerical representation of the color.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance to cast.</param>
            <returns><see cref="T:System.Int64" /> containing extended numerical representation of the color.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(Aurigma.GraphicsMill.RgbColor)~System.Drawing.Color">
            <summary>Casts this <see cref="T:Aurigma.GraphicsMill.RgbColor">Aurigma.GraphicsMill.RgbColor</see> class instance to <see cref="T:System.Drawing.Color">System.Drawing.Color</see> value.</summary>
            <param name="obj"><see cref="T:Aurigma.GraphicsMill.RgbColor">Aurigma.GraphicsMill.RgbColor</see> class instance to cast.</param>
            <returns>Color value casted to <see cref="T:System.Drawing.Color">System.Drawing.Color</see>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(System.Int32)~Aurigma.GraphicsMill.RgbColor">
            <summary>Casts numeric representation of RGB color to <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</summary>
            <param name="value">Numeric representation of the RGB color.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(System.Int64)~Aurigma.GraphicsMill.RgbColor">
            <summary>Casts extended (16-bit per channel) numeric representation of RGB color to <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</summary>
            <param name="value">Extended numeric representation of the RGB color.</param>
            <returns>Converted <see cref="T:Aurigma.GraphicsMill.RgbColor" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.op_Implicit(System.Drawing.Color)~Aurigma.GraphicsMill.RgbColor">
            <summary>Casts this <see cref="T:System.Drawing.Color">System.Drawing.Color</see> class instance to <see cref="T:Aurigma.GraphicsMill.RgbColor" /> value.</summary>
            <param name="obj"><see cref="T:System.Drawing.Color">System.Drawing.Color</see> class instance to cast.</param>
            <returns>Color value casted to <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Orange">
            <summary>Orange color.</summary>
            <value>Value that represents orange color.</value>
            <remarks><span style="color:black;background-color:orange">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.OrangeRed">
            <summary>Orange red color.</summary>
            <value>Value that represents orange red color.</value>
            <remarks><span style="color:black;background-color:orangered">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Orchid">
            <summary>Orchid color.</summary>
            <value>Value that represents orchid color.</value>
            <remarks><span style="color:black;background-color:orchid">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PaleGoldenrod">
            <summary>Pale goldenrod color.</summary>
            <value>Value that represents pale goldenrod color.</value>
            <remarks><span style="color:black;background-color:palegoldenrod">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PaleGreen">
            <summary>Pale green color.</summary>
            <value>Value that represents pale green color.</value>
            <remarks><span style="color:black;background-color:palegreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PaleTurquoise">
            <summary>Pale turquoise color.</summary>
            <value>Value that represents pale turquoise color.</value>
            <remarks><span style="color:black;background-color:paleturquoise">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PaleVioletRed">
            <summary>Pale violet red color.</summary>
            <value>Value that represents pale violet red color.</value>
            <remarks><span style="color:black;background-color:palevioletred">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PapayaWhip">
            <summary>Papaya whip color.</summary>
            <value>Value that represents papaya whip color.</value>
            <remarks><span style="color:black;background-color:papayawhip">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PeachPuff">
            <summary>Peach puff color.</summary>
            <value>Value that represents peach puff color.</value>
            <remarks><span style="color:black;background-color:peachpuff">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Peru">
            <summary>Peru color.</summary>
            <value>Value that represents peru color.</value>
            <remarks><span style="color:black;background-color:peru">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Pink">
            <summary>Pink color.</summary>
            <value>Value that represents pink color.</value>
            <remarks><span style="color:black;background-color:pink">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Plum">
            <summary>Plum color.</summary>
            <value>Value that represents plum color.</value>
            <remarks><span style="color:black;background-color:plum">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.PowderBlue">
            <summary>Powder blue color.</summary>
            <value>Value that represents powder blue color.</value>
            <remarks><span style="color:black;background-color:powderblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Purple">
            <summary>Purple color.</summary>
            <value>Value that represents purple color.</value>
            <remarks><span style="color:black;background-color:purple">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.R">
            <summary>Returns 8-bit red channel value.</summary>
            <value>Red channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.R32">
            <summary>Returns 16-bit red channel value.</summary>
            <value>Red channel value.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Red">
            <summary>Red color.</summary>
            <value>Value that represents red color.</value>
            <remarks><span style="color:black;background-color:red">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.RosyBrown">
            <summary>Rosy brown color.</summary>
            <value>Value that represents rosy brown color.</value>
            <remarks><span style="color:black;background-color:rosybrown">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.RoyalBlue">
            <summary>Royal blue color.</summary>
            <value>Value that represents royal blue color.</value>
            <remarks><span style="color:black;background-color:royalblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SaddleBrown">
            <summary>Saddle brown color.</summary>
            <value>Value that represents saddle brown color.</value>
            <remarks><span style="color:white;background-color:saddlebrown">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Salmon">
            <summary>Salmon color.</summary>
            <value>Value that represents salmon color.</value>
            <remarks><span style="color:black;background-color:salmon">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SandyBrown">
            <summary>Sandy brown color.</summary>
            <value>Value that represents sandy brown color.</value>
            <remarks><span style="color:black;background-color:sandybrown">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SeaGreen">
            <summary>Sea green color.</summary>
            <value>Value that represents sea green color.</value>
            <remarks><span style="color:black;background-color:seagreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SeaShell">
            <summary>Sea shell color.</summary>
            <value>Value that represents sea shell color.</value>
            <remarks><span style="color:black;background-color:seashell">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Sienna">
            <summary>Sienna color.</summary>
            <value>Value that represents sienna color.</value>
            <remarks><span style="color:black;background-color:sienna">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Silver">
            <summary>Silver color.</summary>
            <value>Value that represents silver color.</value>
            <remarks><span style="color:black;background-color:silver">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SkyBlue">
            <summary>Sky blue color.</summary>
            <value>Value that represents sky blue color.</value>
            <remarks><span style="color:black;background-color:skyblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SlateBlue">
            <summary>Slate blue color.</summary>
            <value>Value that represents slate blue color.</value>
            <remarks><span style="color:black;background-color:slateblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SlateGray">
            <summary>Slate gray color.</summary>
            <value>Value that represents slate gray color.</value>
            <remarks><span style="color:black;background-color:slategray">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Snow">
            <summary>Snow color.</summary>
            <value>Value that represents snow color.</value>
            <remarks><span style="color:black;background-color:snow">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SpringGreen">
            <summary>Spring green color.</summary>
            <value>Value that represents spring green color.</value>
            <remarks><span style="color:black;background-color:springgreen">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.SteelBlue">
            <summary>Steel blue color.</summary>
            <value>Value that represents steel blue color.</value>
            <remarks><span style="color:black;background-color:steelblue">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Tan">
            <summary>Tan color.</summary>
            <value>Value that represents tan color.</value>
            <remarks><span style="color:black;background-color:tan">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Teal">
            <summary>Teal color.</summary>
            <value>Value that represents teal color.</value>
            <remarks><span style="color:black;background-color:teal">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Thistle">
            <summary>Thistle color.</summary>
            <value>Value that represents thistle color.</value>
            <remarks><span style="color:black;background-color:thistle">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.ToGdiplusColor">
            <summary>Returns <see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> does.</summary>
            <returns><see cref="T:System.Drawing.Color">System.Drawing.Color</see> containing the same color value as this <see cref="T:Aurigma.GraphicsMill.RgbColor" /> does.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.ToInt32">
            <summary>Returns non-extended (8 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.ToInt64">
            <summary>Returns extended (16 bit per channel) numeric representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</summary>
            <returns>Value containing numeric representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Tomato">
            <summary>Tomato color.</summary>
            <value>Value that represents tomato color.</value>
            <remarks><span style="color:black;background-color:tomato">Sample color</span></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.RgbColor.ToString">
            <summary>Returns a string representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</summary>
            <returns>Value containing a string representation of this <see cref="T:Aurigma.GraphicsMill.RgbColor" />.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Transparent">
            <summary>Transparent color.</summary>
            <value>Value that represents transparent color.</value>
            <remarks><span style="color:black;background-color:transparent">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Turquoise">
            <summary>Turquoise color.</summary>
            <value>Value that represents turquoise color.</value>
            <remarks><span style="color:black;background-color:turquoise">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Violet">
            <summary>Violet color.</summary>
            <value>Value that represents violet color.</value>
            <remarks><span style="color:black;background-color:violet">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Wheat">
            <summary>Wheat color.</summary>
            <value>Value that represents wheat color.</value>
            <remarks><span style="color:black;background-color:wheat">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.White">
            <summary>White color.</summary>
            <value>Value that represents white color.</value>
            <remarks><span style="color:black;background-color:white">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.WhiteSmoke">
            <summary>White smoke color.</summary>
            <value>Value that represents white smoke color.</value>
            <remarks><span style="color:black;background-color:whitesmoke">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.Yellow">
            <summary>Yellow color.</summary>
            <value>Value that represents yellow color.</value>
            <remarks><span style="color:black;background-color:yellow">Sample color</span></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.RgbColor.YellowGreen">
            <summary>Yellow green color.</summary>
            <value>Value that represents yellow green color.</value>
            <remarks><span style="color:black;background-color:yellowgreen">Sample color</span></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.StateRestoringEventArgs">
            <summary>Provides data for undoing/redoing events.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.StateRestoringEventArgs.Cancel">
            <summary>Sets a value specifying if to cancel the operation before it will be started.</summary>
            <value>Value specifying if to cancel the operation before it will be started.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.StateRestoringEventArgs.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.StateRestoringEventArgs" /> object.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.StateRestoringEventHandler">
            <summary>This delegate represents the method that will handle undoing/redoing events.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.StopEventHandler">
            <summary>This delegate represents the method that will handle operation stopping events.</summary>
            <remarks>It handles both <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Stopped" /> and <see cref="E:Aurigma.GraphicsMill.ISyncEvents.Stopping" /> events.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.StreamWrapper">
            <summary>This class represents the wrapper of the <see cref="T:System.IO.Stream" /> class which exposes <b>IStream</b> interface used in COM (<see cref="T:System.Runtime.InteropServices.UCOMIStream" /> interface).</summary>
            <remarks><para>This class is used by Graphics Mill for .NET and typically you need not use it directly.</para></remarks>
            <threadsafety static="true" instance="false" />
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Clone(System.Runtime.InteropServices.ComTypes.IStream@)" draft="yes">
            <summary>Creates a new stream object with its own seek pointer that references the same bytes as the original stream.</summary>
            <param name="ppstm">On successful return, contains the new stream object.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::Clone</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Commit(System.Int32)">
            <summary>Ensures that any changes made to a stream object open in transacted mode are reflected in the parent storage.</summary>
            <param name="grfCommitFlags">Controls how the changes for the stream object are committed.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::Commit</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.CopyTo(System.Runtime.InteropServices.ComTypes.IStream,System.Int64,System.IntPtr,System.IntPtr)" draft="yes">
            <summary>Copies a specified number of bytes from the current seek pointer in the stream to the current seek pointer in another stream.</summary>
            <param name="pstm">Reference to the destination stream.</param>
            <param name="cb">The number of bytes to copy from the source stream.</param>
            <param name="pcbRead">On successful return, contains the actual number of bytes read from the source.</param>
            <param name="pcbWritten">On successful return, contains the actual number of bytes written to the destination.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::CopyTo</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.LockRegion(System.Int64,System.Int64,System.Int32)">
            <summary>Restricts access to a specified range of bytes in the stream.</summary>
            <param name="libOffset">The byte offset for the beginning of the range.</param>
            <param name="cb">The length of the range, in bytes, to restrict.</param>
            <param name="dwLockType">The requested restrictions on accessing the range.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::LockRegion</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.#ctor(System.IO.Stream)">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.StreamWrapper" /> and initializes it by the <see cref="T:System.IO.Stream" /> object.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream" /> object which you need to wrap.</param>
            <remarks><para>Create this class whenever you need to pass .NET <see cref="T:System.IO.Stream" /> class instance to some method of a COM object which accepts <b>IStream</b> interface.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Read(System.Byte[],System.Int32,System.IntPtr)">
            <summary>Reads a specified number of bytes from the stream object into memory starting at the current seek pointer.</summary>
            <param name="pv">On successful return, contains the data read frtom the stream.</param>
            <param name="cb">The number of bytes to read from the stream object.</param>
            <param name="pcbRead">Pointer to a <b>ULONG</b> variable that receives the actual number of bytes read from the stream object.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::Read</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Revert">
            <summary>Discards all changes that have been made to a transacted stream since the last <see cref="M:Aurigma.GraphicsMill.StreamWrapper.Commit(System.Int32)" /> call.</summary>
            <remarks>For more information, please see the existing documentation for <b>IStream::Revert</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Seek(System.Int64,System.Int32,System.IntPtr)">
            <summary>Changes the seek pointer to a new location relative to the beginning of the stream, to the end of the stream, or to the current seek pointer.</summary>
            <param name="dlibMove">Displacement to add to <i>dwOrigin</i>.</param>
            <param name="dwOrigin">Specifies the origin of the seek. The origin can be the beginning of the file, the current seek pointer, or the end of the file.</param>
            <param name="plibNewPosition">On successful return, contains the offset of the seek pointer from the beginning of the stream.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::Seek</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.SetSize(System.Int64)">
            <summary>Changes the size of the stream object.</summary>
            <param name="libNewSize">Specifies the new size of the stream as a number of bytes.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::SetSize</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Stat(System.Runtime.InteropServices.ComTypes.STATSTG@,System.Int32)" draft="yes">
            <summary>Retrieves the <b>STATSTG</b> structure for this stream.</summary>
            <param name="pstatstg">On successful return, contains a <b>STATSTG</b> structure which describes this stream object.</param>
            <param name="grfStatFlag">Specifies some of the members in the <b>STATSTG</b> structure that this method does not return, thus saving some memory allocation operations.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::Stat</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.UnlockRegion(System.Int64,System.Int64,System.Int32)" draft="yes">
            <summary>Removes the access restriction on a range of bytes previously restricted with <see cref="M:Aurigma.GraphicsMill.StreamWrapper.LockRegion(System.Int64,System.Int64,System.Int32)" />.</summary>
            <param name="libOffset">The byte offset for the beginning of the range.</param>
            <param name="cb">The length, in bytes, of the range to restrict.</param>
            <param name="dwLockType">The access restrictions previously placed on the range.</param>
            <remarks>For more information, please see the existing documentation for <b>IStream::UnlockRegion</b> in the MSDN library.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.StreamWrapper.Write(System.Byte[],System.Int32,System.IntPtr)">
            <summary>Writes a specified number of bytes into the stream object starting at the current seek pointer.</summary>
            <param name="pv">Buffer to write this stream to.</param>
            <param name="cb">The number of bytes to write into the stream.</param>
            <param name="pcbWritten">On successful return, contains the actual number of bytes written to the stream object. The caller can set this pointer to a null reference (<b>Nothing</b> in Visual Basic), in which case this method does not provide the actual number of bytes written.</param>
            <remarks>For more information, please see the existing documentation for <b>ISequentialStream::Write</b> in the MSDN library.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.SyncHandler" draft="yes">
            <summary>This is a base class for all the codecs, transforms, as well as any other operations which can be run asynchronously. It contains partial implementation for <see cref="T:Aurigma.GraphicsMill.ISyncHandler" /> interface.</summary>
            <remarks><para>
Main aim of this class is to provide access to operation execution. Using <see cref="M:Aurigma.GraphicsMill.SyncHandler.Abort" /> method you can cancel the operation execution. <see cref="M:Aurigma.GraphicsMill.SyncHandler.Pause" /> and <see cref="M:Aurigma.GraphicsMill.SyncHandler.Continue" /> methods are used to suspend/resume the operation.
</para><para>
This class provides asynchronous modes support. It is specified with <see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" />. For synchronization of some thread with the operation completion, you can use <see cref="M:Aurigma.GraphicsMill.SyncHandler.WaitForCompletion" /> method. 
</para><para>
A number of events can be used to provide control of the operation execution:  
</para><list type="bullet"><item><term><see cref="E:Aurigma.GraphicsMill.SyncHandler.Starting" />/<see cref="E:Aurigma.GraphicsMill.SyncHandler.Started" /></term><description>operation is starting/has been started;</description></item><item><term><see cref="E:Aurigma.GraphicsMill.SyncHandler.Progress" /></term><description>operation is running;</description></item><item><term><see cref="E:Aurigma.GraphicsMill.SyncHandler.Paused" />/<see cref="E:Aurigma.GraphicsMill.SyncHandler.Continued" /></term><description>operation was paused/resumed;</description></item><item><term><see cref="E:Aurigma.GraphicsMill.SyncHandler.Aborted" /></term><description>operation was cancelled;</description></item><item><term><see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopping" />/<see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /></term><description>operation is about to finish/fully completed.</description></item></list><para>This class also provides an implementation for <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface, so you can use object locking functionality.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Abort">
            <summary>Aborts current operation.</summary>
            <remarks><para>
The class which was aborted with this operation will throw the <see cref="T:Aurigma.GraphicsMill.AbortedException" />. In synchronous mode you need to use standard exception handling mechanism (try/catch block or its analogue). In asynchronous mode the exception is retrieved into <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event (as its argument). Event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Aborted" /> is also fired.</para><para>If this method is called from main thread, it retuns a control only when auxilary thread has been stopped terminated. If it is called from the auxilary thread (i.e. from such event handlers like <see cref="E:Aurigma.GraphicsMill.SyncHandler.Progress" />, <see cref="E:Aurigma.GraphicsMill.SyncHandler.Paused" />, <see cref="E:Aurigma.GraphicsMill.SyncHandler.Started" />, etc), this method <b>does not wait</b> for thread terminating (to avoid deadlock).</para><para>If it is called after the execution was paused by <see cref="M:Aurigma.GraphicsMill.SyncHandler.Pause" /> method, the operation will be stopped only after call of <see cref="M:Aurigma.GraphicsMill.SyncHandler.Continue" />.</para><note>It makes no sense to call <see cref="M:Aurigma.GraphicsMill.SyncHandler.Abort" /> in event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Starting" /> because auxilary thread has not been launched yet at that point. It just will not have an effect.</note></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Aborted">
            <summary>Fires when operation has been aborted.</summary>
            <remarks>It fires immediately after event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" />. If <see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" /> is <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Sync" /> or <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop" />, this event handler is executed in the main application thread, otherwise (if it is <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Async" />) - in auxiliaryt thread (where operation was executed).</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.Completed">
            <summary>Returns value indicating if the operation is currently running.</summary>
            <value>Value that indicates whether the operation is currently running.</value>
            <remarks><para>
If the operation is running, this property returns <b>true</b>. Otherwise operation completed or never started), it returns <b>false</b>. 
</para><para>
It is recommended to check if the operation is running with this property rather than using property <see cref="P:Aurigma.GraphicsMill.SyncHandler.Locked" />, because the object can be locked not only when operation is run.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Continue">
            <summary>Resumes execution of the operation previously paused with <see cref="M:Aurigma.GraphicsMill.SyncHandler.Pause" /> method.</summary>
            <remarks>When operation is resumed, event <see cref="E:Aurigma.GraphicsMill.SyncHandler.Continued" /> fires.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Continued">
            <summary>Fires when operation has been resumed with <see cref="M:Aurigma.GraphicsMill.SyncHandler.Continue" /> method.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.SyncHandler" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.SyncHandler" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.ExceptionThrowEnabled">
            <summary>Gets/sets value that specifies if to throw exception in synchronous mode.</summary>
            <value>Value that specifies if to throw exception in synchronous mode.</value>
            <remarks><para>
When you are using asynchronous mode, the single way to handle errors is to check <see cref="P:Aurigma.GraphicsMill.ErrorEventArgs.Exception" /> argument of the <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event. If it is not <b>null</b>, it contains the exception object thrown by operation. 
</para><para>
In synchronous mode you still can use <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event to handle errors. However this property enables you to specify how to use standard exception handling mechanism (<b>try</b>/<b>catch</b> block). If it is <b>false</b>, operation will pass exceptions into <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event only, otherwise it will throw it in common way (in addition to retrieving exception to <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> event).
</para><para>
If current <see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" /> is not <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Sync" />, this property is ignored (to avoid vagueness where to handle it when operation is asynchronous). 
</para><para>
Default value is <b>true</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.ExportEventsHostSettings(System.IntPtr)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Finalize">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Lock">
            <summary>Locks the object.</summary>
            <remarks><para>
After calling this method this object is not accessible from any other thread (until <see cref="M:Aurigma.GraphicsMill.SyncHandler.Unlock" /> is called). You can safely check <see cref="P:Aurigma.GraphicsMill.SyncHandler.Locked" /> property to ensure if object is locked.
</para><para>
When you access the object which has been locked, the thread stops and waits until it become unlocked. Using property <see cref="P:Aurigma.GraphicsMill.SyncHandler.Timeout" /> you can specify how much time to wait.
</para><note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.SyncHandler.Lock" />/<see cref="M:Aurigma.GraphicsMill.SyncHandler.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.Locked">
            <summary>Indicates if the object has been locked.</summary>
            <value>Value indicating if the object has been locked.</value>
            <remarks>This property is always accessible (even if the object is locked). You can use it to check if method <see cref="M:Aurigma.GraphicsMill.SyncHandler.Lock" /> was already executed, but <see cref="M:Aurigma.GraphicsMill.SyncHandler.Unlock" /> was not.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadAbort">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadAbortHander(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadContinue">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadContinueHandler(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadPause">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadPauseHandler(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadProgress(System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadProgressHandler(System.Object,Aurigma.GraphicsMill.ProgressEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStarted">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStartedHandler(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStarting">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStartingHandler(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStopped(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStoppedHandler(System.Object,Aurigma.GraphicsMill.ErrorEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.OnThreadStoppingHandler(System.Object,Aurigma.GraphicsMill.ErrorEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Pause">
            <summary>Pauses execution of the current operation.</summary>
            <remarks><para>
When operation is paused, <see cref="E:Aurigma.GraphicsMill.SyncHandler.Paused" /> event fires.
</para><para>
You can resume the execution using <see cref="M:Aurigma.GraphicsMill.SyncHandler.Continue" /> method.
</para></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Paused">
            <summary>Fires when operation has been paused with <see cref="M:Aurigma.GraphicsMill.SyncHandler.Pause" /> method.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.Priority">
            <summary>Gets/sets a priority for the auxilary thread.</summary>
            <value>The priority for the auxilary thread.</value>
            <remarks><para>The higher the priority, the faster the thread completes. But from the other hand, it consumes more resources, and that is why other threads are working slower.</para></remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Progress">
            <summary>Fires on the operation progress notifications.</summary>
            <remarks>Using <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Current" /> and <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum" /> arguments you can determine how much work was done at current moment. Typically you use this event to update a progress bar or display percentage of the work done. Percentage can be calculated with the following formula: (<see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Current" /> / <see cref="P:Aurigma.GraphicsMill.ProgressEventArgs.Maximum" />) * 100.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Aborted(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Continued(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Paused(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Progress(System.Object,Aurigma.GraphicsMill.ProgressEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Started(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Starting(System.Object,System.EventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Stopped(System.Object,Aurigma.GraphicsMill.ErrorEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.raise_Stopping(System.Object,Aurigma.GraphicsMill.ErrorEventArgs)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.ResetEventsHostSettings(System.IntPtr)">
            <exclude />
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Started">
            <summary>Fires after operation has been started.</summary>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Starting">
            <summary>Fires before operation is started.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.StartThread">
            <exclude />
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Stopped">
            <summary>Fires after operation has been stopped.</summary>
            <remarks>This event also enables you to handle errors in asynchronous mode by using <see cref="P:Aurigma.GraphicsMill.ErrorEventArgs.Exception" /> argument. If operation was completed successfully, this argument contains <b>null</b>.</remarks>
        </member>
        <member name="E:Aurigma.GraphicsMill.SyncHandler.Stopping">
            <summary>Fires before operation is stopped.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode">
            <summary>Gets/sets synchronization mode for the object.</summary>
            <value>Value that specifies the synchronization mode for the object.</value>
            <remarks><para>
              Currently Graphics Mill for .NET provides the following synchronization options:
            </para><list type="table"><listheader><term>Mode</term><term>Description</term></listheader><item><description>Synchronous mode</description><description>Operation (and its event handlers) is running in the application main thread.</description></item><item><description>Common asynchronous mode</description><description>Operation and its event handlers are running in the auxilary thread. </description></item><item><description>Asynchronous mode that uses main thread message loop</description><description>Operation is running in the auxilary thread, but its event handlers are running in the application main thread.</description></item></list><para>
Default value is <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Sync" />.
</para><note>To use <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop" /> mode, application message loop must be running. In particular it means that you cannot set <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop" /> value into this property at application initialization event (such as form load, etc).</note><note>Another thing you should keep in mind is that you cannot modify this property when the auxilary thread is running. So you cannot set these properties in all events except of <see cref="E:Aurigma.GraphicsMill.SyncHandler.Starting" /> and <see cref="E:Aurigma.GraphicsMill.SyncHandler.Stopped" /> (that are called before and after the thread starts/finishes).</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.ThreadProc">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.ThreadProcHandler">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.SyncHandler.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.Unlock">
            <summary>Unlocks the object previously locked with method <see cref="M:Aurigma.GraphicsMill.SyncHandler.Lock" />.</summary>
            <remarks>Every time you call method <see cref="M:Aurigma.GraphicsMill.SyncHandler.Lock" /> object becomes unavailable until you call this method (the threads which access locked object are stopped until unlocking). That's why it is extremely important to call this method when you finished working with the object. 
<note>
  All Graphics Mill for .NET method and properties already uses <see cref="M:Aurigma.GraphicsMill.SyncHandler.Lock" />/<see cref="M:Aurigma.GraphicsMill.SyncHandler.Unlock" /> methods to provide thread safety. You need call these methods manually only if you manipulate the objects manually, or if you inherit your own class from <see cref="T:Aurigma.GraphicsMill.ILockable" /> interface.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.SyncHandler.WaitForCompletion">
            <summary>Suspends the calling thread until the operation currently run is completed.</summary>
            <remarks>If <see cref="P:Aurigma.GraphicsMill.SyncHandler.SynchronizationMode" /> is <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Sync" />, this method do nothing.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.SyncHandlerProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.SynchronizationMode">
            <summary>Contains possible values for synchronization modes used in Graphics Mill for .NET.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.SynchronizationMode.Async">
            <summary>Asynchronous mode. Operation is run in auxiliary thread, most events are fired in auxiliary thread too. In asynchronous mode the operation is not running in the same thread with main application. Therefore user interface is not freezing, user can use your application while operation is done. He can abort, pause or continue the operation. Note, when events are fired, their handlers a run in auxilary thread. That's why you must provide thread safety for these handlers. If event handler and main application thread are modifying the same object or memory, the result is unpredictable (usually it just crashes unexpectedly).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop">
            <summary>Asynchronous mode which uses thread message loop (window procedure). Operation is run in auxiliary thread, events are fired in main thread. This is an asynchronous mode which executes the operation in auxilary thread, but call event handlers in main application thread. This is a crucial difference from <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Async" /> mode. All event handlers are automatically thread safe, in particular it makes using standard controls like progress bar easy. However this method is not perfect too. You should write event handlers carefully and avoid deadlocks, otherwise your application will hang. Deadlock may happen when you get access to the bitmap or other object which has been locked. You can check it with property <see cref="P:Aurigma.GraphicsMill.SyncHandler.Locked" />. Also you may avoid hanging with a help of <see cref="P:Aurigma.GraphicsMill.SyncHandler.Timeout" /> property. However deadlock means a flaw in your code logic, so anyway you must avoid it. Also, <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.AsyncViaMessageLoop" /> has a limitation - it works only at applications which have GUI. So if you need an asynchronous mode in console applications, ASP.NET, etc, you should use <see cref="F:Aurigma.GraphicsMill.SynchronizationMode.Async" /> instead.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.SynchronizationMode.Sync">
            <summary>Synchronous mode. Operation is run in main thread of application. This mode is simple in usage and always used by default. The shortcoming of this method is that user interface freezes while operation is applied. If you need to run the operation in the background, you should use some of asynchronous mode.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.TimeoutException">
            <summary>The exception which arises when timeout is expired.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.TimeoutException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.TimeoutException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.TimeoutException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TimeoutException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.TimeoutException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.TimeoutException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.TimeoutException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.TimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="N:Aurigma.GraphicsMill.Transforms" draft="yes">
            <summary>The <see cref="N:Aurigma.GraphicsMill.Transforms" /> namespace provides access to Graphics Mill for .NET transforms and attendant functionality. Most classes of this namespace represent single transform algorithm. Note, if you need to run transforms synchroniously, you can use method provided with <see cref="P:Aurigma.GraphicsMill.Bitmap.Transforms" /> and <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorAdjustment" />.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.AddNoise">
            <summary>This class enables you to put additive noise to the image by adding random number to each pixel.</summary>
            <remarks>Using <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind" /> property you can specify a noise distribution (uniform or Gaussian). <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" /> property is used to specify strength of noise. If you need to put the same noise values to all channels of pixel (in other words, noise is gray), you can use <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise" />.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount">
            <summary>Gets/sets amount (strength) of noise.</summary>
            <value>Value specifying strength of noise. Possible values is in range [-1, 1]. If <i>Value</i> is 0, no noise added.</value>
            <remarks>Default value is 0.2.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind">
            <summary>Gets/sets distribution kind of noise.</summary>
            <value>A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.DistributionKind.Uniform" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise">
            <summary>Gets/sets boolean value specifying if to generate gray noise (random value should be the same for all channels of one pixel) or color noise (random value may vary for each channel in one pixel).</summary>
            <value>Value specifying if to generate gray or color noise.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Boolean[],System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can specify what channels to modify and set noise amount parameter.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Boolean[],System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can specify all the transform parameters here (noise amount, distribution kind, if it should be gray, and channels to apply transform at).</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is true, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind" />.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Boolean[],System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can specify all the transform parameters here (noise amount, distribution kind, seed, if it should be gray, and channels to apply transform at).</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is true, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind" />.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise" />.</param>
            <param name="seed">An integer value specifying seed for random generator. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Seed" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can initialize noise amount parameter here. Transform will be applied to all channels of the bitmap.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can specify all the transform parameters here (noise amount, distribution kind, and if it should be gray). Transform will be applied to all channels of the bitmap.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind" />.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class instance. You can specify all the transform parameters here (noise amount, distribution kind, seed, and if it should be gray). Transform will be applied to all channels of the bitmap.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Amount" />.</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.DistributionKind" />.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.GrayNoise" />.</param>
            <param name="seed">An integer value specifying seed for random generator. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.AddNoise.Seed" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AddNoise.Randomize">
            <summary>Initializes <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.Seed" /> property with random value.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AddNoise.Seed">
            <summary>Gets/sets seed value for random generator.</summary>
            <value>An integer value specifying seed for random generator.</value>
            <remarks><para>
Set of random numbers is always the same for the same seed. So if you need to have the same result for multiple execution of this transform, specify some fixed seed. If you want to have different result each time you run this transform, set this property randomly (for example, from system clock or some other unpredictable value). You can also use special method <see cref="M:Aurigma.GraphicsMill.Transforms.AddNoise.Randomize" /> which automatically set this property to random value.
</para><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.AdjustHsl">
            <summary>This class enables you to perform adjusting image in HSL color space.</summary>
            <remarks><para>To use this transform, you should supply values for <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Hue" />, <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Saturation" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Lightness" /> which will be added to appropriate components in HSL color space to each pixel.</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AdjustHslTransform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AdjustHslTransform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AdjustHsl.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AdjustHsl.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Hue">
            <summary>Gets/sets hue modifier.</summary>
            <value>Hue modifier value in range [-1, 1] (degrees normalized at 360).</value>
            <remarks>Hue is measured in degrees relatively red point on color wheel. It means that if, for example, you specify 120 degrees, red color will turn to green, etc.
<para>
Default value is 0.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Lightness">
            <summary>Gets/sets lightness modifier.</summary>
            <value>Lightness modifier value. Should be a value in range [-1, 1].</value>
            <remarks>This parameter allows to change intensity of the color. It works similar to <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> transform, however another algorithm is used and result differs from brightness adjustment.
<para>
Default value is 0.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AdjustHsl.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.AdjustHsl.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.AdjustHsl" /> class instance. You can specify all the parameters of this transform here (hue, saturation, and lightness).</summary>
            <param name="hue">Hue modifier (in degrees). You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Hue" />.</param>
            <param name="saturation">Saturation modifier (in range [0,1]). You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Saturation" />.</param>
            <param name="lightness">Saturation modifier (in range [0,1]). You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Lightness" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.AdjustHsl.Saturation">
            <summary>Gets/sets saturation modifier.</summary>
            <value>Saturation modifier value. Should be a value in range [-1, 1].</value>
            <remarks>Saturation means "purity" of the color. Small (negative) values will make image desaturated, gray. Large values will make image very saturated, all the color will be deep. Note, natural colors are seldom very saturated, so if you apply this method on photo, don't make this parameter close to maximum (if you don't deal with tropical butterflies and flowers). 
<para>
Default value is 0.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ApplyLut">
            <summary>This class enables you to apply tone correction using specified look-up table (LUT).</summary>
            <remarks><para>
Look-up table (LUT) is an array specifying mapping function for pixels. The algorithm works in the following way: it iterates through each pixels on each channels separately. It takes a channel luminosity and uses it as index in LUT array to get a value to copy to corresponding channel and pixel of the result image. Pseudocode for this algorithm is looking in the following way:
</para><code language="VB" source="CodeSnippets/LUT.vb"></code><code language="CS" source="CodeSnippets/LUT.cs"></code><para>
To specify look-up table you should use property <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyLut.Lut" />. Look-up tables are represented with <see cref="T:Aurigma.GraphicsMill.Transforms.Lut">Aurigma.GraphicsMill.Transforms.Lut</see> class which provides a number of methods allowing to generate LUT as standard function.
</para><para>
As usual LUT should not affect the alpha channel. When property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyOnAlpha" /> is set to <b>false</b>, alpha channel is not modified with algorithm even if it is enabled with <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> property.
</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#ApplyLutTransform1"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ApplyLutTransform1"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.ApplyLut.Lut">
            <summary>Gets/sets look-up table which defines this LUT transform.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance which specifies look-up table for this LUT transform.</value>
            <remarks><para>
This class is initialized by empty LUT after the <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> has been created, so you can use the syntax to specify LUT like this:
</para><code language="VB" source="ApplyingEffectsVB/form1.vb#ApplyLutTransform1"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ApplyLutTransform1"></code><para>
instead of creating and initializing separate <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> instance.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.#ctor(Aurigma.GraphicsMill.Transforms.Lut)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class instance. You can pass necessary LUT here.</summary>
            <param name="lut"><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance which specifies look-up table for this LUT transform. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyLut.Lut" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.#ctor(System.Boolean[])">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class instance. Here you can specify what channels to process with this transform.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />. Note, if <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyOnAlpha" /> property is set to <b>false</b>, alpha channel flag is ignored (disabled).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.#ctor(System.Boolean[],Aurigma.GraphicsMill.Transforms.Lut)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class instance. You can pass necessary LUT and set what channels to process here.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />. Note, if <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyOnAlpha" /> property is set to <b>false</b>, alpha channel flag is ignored (disabled).</param>
            <param name="lut"><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance which specifies look-up table for this LUT transform. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyLut.Lut" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyLut.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform">
            <summary>This class enables you to apply an arbitrary convex linear transformation on the bitmap (such as perspective distortion, rotation, skew, etc).</summary>
            <remarks><para>To apply a transfomation, you should build a matrix of the linear transformation (see <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class for more details). This matrix allows to specify both affine and projective transformation. The only limitation - the matrix should not be singular (i.e. transformation must be convex). Put this matrix to the <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.Transform" /> property.</para><para>In fact, such transforms as <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> and <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> are special cases of the linear transformations. You can emulate these transforms by providing scaling/rotating matrix to this transform. However  <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> and <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> are optimized and we recommend to use it when you need only to resize or rotate.</para><para>As for all other geometry transforms you can specify also the <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.InterpolationMode" /> (which affects on the algorithm speed and output quality) and <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.BackgroundColor" />.  </para></remarks>
            <seealso cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.BackgroundColor">
            <summary>Gets/sets the background color for the transformed image.</summary>
            <value>Value specifying the background color for the transformed image.</value>
            <remarks>Default value is a transparent white.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during transformation.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during transformation.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.#ctor(Aurigma.GraphicsMill.Transforms.Matrix)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class instance with specified matrix.</summary>
            <param name="transform"><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which specifies a matrix of the linear transform. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.Transform" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.#ctor(Aurigma.GraphicsMill.Transforms.Matrix,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class instance.</summary>
            <param name="transform"><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which specifies a matrix of the linear transform. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.Transform" /> property.</param>
            <param name="backgroundColor">Color value which specifies the background color for the transformed image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value which specifies interpolation algorithm used during transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform.Transform">
            <summary>Gets/sets a matrix of the transformation.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which specifies a matrix of the linear transformation.</value>
            <remarks>Default value is an identify matrix.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.BitmapTransform" draft="yes">
            <summary>This is a base class of all transforms presented in Graphics Mill for .NET.</summary>
            <remarks>This abstract class contains partial implementation for all Graphics Mill for .NET transforms. In particular it provides method <see cref="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)" /> and property <see cref="P:Aurigma.GraphicsMill.Transforms.BitmapTransform.SupportedPixelFormats" /> that allows to determine what pixel format are supported by this transform and whether some certain format can be used. Also, it contains partial implementation of method <see cref="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)" /> (and its overloads) which is used to apply the transform at the bitmap.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap ("in-place").</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <overloads><summary>Transforms given bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged).</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (<see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance). The bitmap data remains unchanged.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.BitmapTransform" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.BitmapTransform" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.GetVerticalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)">
            <summary>Verifies if bitmap with specified pixel format is supported by this transform.</summary>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value to verify.</param>
            <returns>Value that equals to <b>true</b> if specified pixel format is supported, <b>false</b> otherwise.</returns>
            <remarks><para>
If you try to apply this transform to a bitmap which has unsupported pixel format, <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> will be raised.
</para><para>To get a list of all supported pixel formats, you can use <see cref="P:Aurigma.GraphicsMill.Transforms.BitmapTransform.SupportedPixelFormats" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.#ctor(Aurigma.GraphicsMill.BitmapChange)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.OnTransforming">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.RaiseBitmapChangedEvent">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.RaiseBitmapChangedEvent(Aurigma.GraphicsMill.Bitmap)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.RaiseBitmapChangingEvent">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.RaiseBitmapChangingEvent(Aurigma.GraphicsMill.Bitmap)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.SetDestinationData(System.IntPtr)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.BitmapTransform.SupportedPixelFormats">
            <summary>Returns an array of pixel formats that are supported by this transform.</summary>
            <value>An array of <see cref="T:Aurigma.GraphicsMill.PixelFormat" /> values that are supported by this transform.</value>
            <remarks><para>If you try to apply this transform to a bitmap which has pixel format which is not inlcuded into this array, <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> will be raised.</para><para>To verify the single pixel format, use <see cref="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.IsPixelFormatSupported(Aurigma.GraphicsMill.PixelFormat)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BitmapTransform.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.BitmapTransformProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Blur">
            <summary>This class enables you to apply blurring filter on the bitmap.</summary>
            <remarks>Using this class, you can blur the image. It allow two kinds of blur - classic <see cref="F:Aurigma.GraphicsMill.Transforms.BlurType.Gaussian" /> blur and <see cref="F:Aurigma.GraphicsMill.Transforms.BlurType.Fast" /> modification (higher performance is obtained with lower quality). You can select between these blur variations using <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Type" /> property. Besides, you can specify a radius of blur filter using <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Radius" /> property. Large values of radius makes image more blurry, so you can treat this parameter as "blur strength".</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Blur.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Blur.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Blur.#ctor">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Blur.#ctor(System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class instance. You can set blur radius here.</summary>
            <param name="radius">A positive value which specifies blur radius. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Radius" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Blur.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.BlurType)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class instance. You can initialize all transform parameters here (both blur radius and blur type).</summary>
            <param name="radius">A positive value which specifies blur radius. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Radius" />.</param>
            <param name="type">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> enumeration specifying blur type. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Type" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Blur.Radius">
            <summary>Gets/sets blur radius.</summary>
            <value>Value specifying blur radius. Must be positive.</value>
            <remarks><note type="implementnotes">Radius means how much neighbour pixels algorithm fetches (for radius = 1 it will take 8 neighbours, for radius = 2 it will use already 24 neighbour pixels, etc). That's why in general the larger radius is, the slower blur works. However Graphics Mill for .NET implements special algorithms which are optimized for large radiuses, that's why this rule not always works.</note><para>
Default value is 2.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Blur.Type">
            <summary>Gets/sets blur type.</summary>
            <value>A member of <see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> enumeration specifying blur type.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.BlurType.Fast" />.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.BlurType">
            <summary>Contains blur types for <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.BlurType.Fast">
            <summary>Fast blur algorithm (works faster than Gaussian blur, but quality is lower).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.BlurType.Gaussian">
            <summary>Gaussian blur algorithm.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Brightness">
            <summary>This class enables you to correct brightness of the image.</summary>
            <remarks>This class provides simple brightness adjustment functionality. Being extremely easy-to-use for end user (it has the single parameter <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" />), it is used by professional retouchers very seldom (because as usual it leads to losses of details in highlights and/or shadows). 
<para>
You can also use this transform in automatic mode using <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> property.
</para><para>
If you want to apply both brightness and contrast, you should consider <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> transform. Both of these operation will be performed at the single pass, so it will work faster than sequential execution of <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> and <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" />.
</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#BrightnessTransform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#BrightnessTransform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount">
            <summary>Gets/sets brightness modifier.</summary>
            <value>Brightness modifier value varying in range [-1, 1].</value>
            <remarks><note>If you set <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> property to <b>true</b>, and modifying <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> is reset to <b>false</b>.</note><para>
Default value is 0. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto">
            <summary>Gets/sets a value specifying if transform should be run in automatic mode.</summary>
            <value>A value specifying if transform should be run in automatic mode. If it is <b>true</b>, property <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" /> will be ignored and brightness modifier will be calculated automatically.</value>
            <remarks><note>If you set <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> property to <b>true</b>, and modifying <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Auto" /> is reset to <b>false</b>.</note><para>
When you create <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> without specifying brightness amount, default value is <b>true</b>. If amount is passed to constructor, default value is <b>false</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.CalculateAutoParameters(Aurigma.GraphicsMill.Bitmap,System.Single@,Aurigma.GraphicsMill.Transforms.Lut@)" draft="yes">
            <summary>Returns brightness modifier value which the class would apply in automatic mode.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance for which the brightness modifier is calculated automatically.</param>
            <param name="amount">Out parameter. Value which contains brightness modifier which would be used automatically will be written into this parameter.</param>
            <param name="lut">Out parameter. LUT which represents this brightness modification will be written into this parameter.</param>
            <overloads><summary>Returns brightness modifier value which the class would apply in automatic mode.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.CalculateAutoParameters(Aurigma.GraphicsMill.BitmapData,System.Single@,Aurigma.GraphicsMill.Transforms.Lut@)">
            <summary>Returns brightness modifier value which the class would apply in automatic mode.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance for which the brightness modifier is calculated automatically.</param>
            <param name="amount">Out parameter. Value which contains brightness modifier which would be used automatically will be written into this parameter.</param>
            <param name="lut">Out parameter. LUT which represents this brightness modification will be written into this parameter.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.#ctor(System.Boolean[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance. Here you can specify what channels to process with this transform.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.#ctor(System.Boolean[],System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance. Here you can specify what channels to process with this transform and brigthness modifier.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="amount">Brightness modifier value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Brightness.#ctor(System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance. Here you can specify a brigthness modifier.</summary>
            <param name="amount">Brightness modifier value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Brightness.Amount" />.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast">
            <summary>This class enables you to correct brightness and contrast of the image.</summary>
            <remarks>This class provides simple brightness and contrast adjustment functionality. Being extremely easy-to-use for end user, it is used by professional retouchers very seldom (because as usual it leads to losses of details in highlights and/or shadows). 
<para>
It provides two parameters - brightness modifier (<see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.BrightnessAmount" /> property) and contrast modifier (<see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.ContrastAmount" /> property).  
</para><para>
If you want to modify only brightness or contrast, you can use <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> or <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> transform. It will work slightly faster.
</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#BrightnessContrastTransform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#BrightnessContrastTransform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.BrightnessAmount">
            <summary>Gets/sets brightness modifier.</summary>
            <value>Brightness modifier value varying in range [-1, 1].</value>
            <remarks><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.ContrastAmount">
            <summary>Gets/sets contrast modifier.</summary>
            <value>Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized.</value>
            <remarks><para>
Default value is 0. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.#ctor(System.Boolean[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class instance. Here you can specify what channels to process.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.#ctor(System.Boolean[],System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class instance. Here you can specify what channels to process with this transform and brigthness/contrast modifiers.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="brightnessAmount">Brightness modifier value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.BrightnessAmount" />.</param>
            <param name="contrastAmount">Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.ContrastAmount" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.BrightnessContrast.#ctor(System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> class instance. Here you can specify brigthness and contrast modifiers.</summary>
            <param name="brightnessAmount">Brightness modifier value varying in range [-1, 1]. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.BrightnessAmount" />.</param>
            <param name="contrastAmount">Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.BrightnessContrast.ContrastAmount" />.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Buttonize">
            <summary>This class enables you to apply buttonize effect on the image.</summary>
            <remarks><para>
Using this transform you can make images looking like buttons. You can specify button appearance settings such as border (button edge) width with <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" />, lighting direction (<see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction" /> property), shadowed and lighted colors (<see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor" /> properties respectively). Besides, if you need to display button edges partially, you can use <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.HorizontalBorder" /> and  <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.VerticalBorder" /> to enable/disable horizontal or vertical edge.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth">
            <summary>Gets/sets a border (button edge) width.</summary>
            <value>Border (button edge) width.</value>
            <remarks>Default value is 10.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction">
            <summary>Gets/sets lighting direction used to draw button edges.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges.</value>
            <remarks><para>
According to this value some edges will be colored to <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor" />, another edges will be colored to <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor" />.
</para><para>
Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.Direction.UpLeft" />.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.FadeType">
            <summary>Gets/sets fade type used to draw button edges.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.FadeType.Linear" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.HorizontalBorder">
            <summary>Gets/sets value specifying whether to show horizontal border.</summary>
            <value>Value specifying whether to show horizontal border.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor">
            <summary>Gets/sets color used to draw highlighted edges.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw highlighted edges.</value>
            <remarks>Default value is a light gray color.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. You can set button edge width at this constructor.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. At this constructor you can set button edge width and edges colors.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw highlighted edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor" /> property.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw shadowed edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. At this constructor you can set button edge width and parameters defining edges appearance as lighting direction and border fade type.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.FadeType" /> property.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. At this constructor you can set button edge width and parameters defining edges appearance as lighting direction, border fade type, and edges colors.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.FadeType" /> property.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction" /> property.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw highlighted edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor" /> property.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw shadowed edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,System.Boolean,System.Boolean)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. At this constructor you can set button edge width and parameters defining edges appearance as lighting direction and border fade type. Besides you can enable/disable horizontal or vertical edges here.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.FadeType" /> property.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction" /> property.</param>
            <param name="horizontalBorder">Value specifying whether to show horizontal border. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.HorizontalBorder" /> property.</param>
            <param name="verticalBorder">Value specifying whether to show vertical border. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.VerticalBorder" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,System.Boolean,System.Boolean,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> transform object. At this constructor you can all parameters available for buttonizing.</summary>
            <param name="borderWidth">Border (button edge) width. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.BorderWidth" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.FadeType" /> property.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.Direction" /> property.</param>
            <param name="horizontalBorder">Value specifying whether to show horizontal border. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.HorizontalBorder" /> property.</param>
            <param name="verticalBorder">Value specifying whether to show vertical border. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.VerticalBorder" /> property.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw highlighted edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.LightColor" /> property.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw shadowed edges. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.ShadowColor">
            <summary>Gets/sets color used to draw shadowed edges.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying to draw shadowed edges.</value>
            <remarks>Default value is a gray color.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Buttonize.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Buttonize.VerticalBorder">
            <summary>Gets/sets value specifying whether to show vertical border.</summary>
            <value>Value specifying whether to show vertical border.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" draft="yes">
            <summary>This class enables you to adjust channel balance.</summary>
            <remarks>To modify channel balance, you should retrieve an array of channel modifiers which will be added to appropriate channels of all pixels. This array is specified with <see cref="P:Aurigma.GraphicsMill.Transforms.ChannelBalance.Levels" /> property.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ChannelBalance.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ChannelBalance.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.ChannelBalance.Levels">
            <summary>Gets/sets an array of channels modifiers.</summary>
            <value>Each entry of array is a value varying in range [-1, 1]. According to number bits per channel, these values are normalized either to 255 (for non-extended pixel formats) or 65535 (for extended pixel formats).</value>
            <remarks>If number of this array entries is less than number of channels in the target bitmap, the rest channels will be unchanged. If there are more array entries than channels target bitmap provides, all extra entries will be ignored.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ChannelBalance.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ChannelBalance.#ctor(System.Single[])">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.ChannelBalance" /> class instance.</summary>
            <param name="levels">Each entry of array is a value varying in range [-1, 1]. According to number bits per channel, these values are normalized either to 255 (for non-extended pixel formats) or 65535 (for extended pixel formats). Can be modified later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.ChannelBalance.Levels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.ChannelBalance.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ColorManagementEngine" draft="yes">
            <summary>Contains possible color management engines.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.AdobeCmm" draft="yes">
            <summary>Adobe CMM.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.LittleCms" draft="yes">
            <summary>LittleCMS.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" draft="yes">
            <summary>Color management is disabled.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm">
            <summary>Contains possible values of color quantization algorithms.</summary>
            <remarks><para>Color quantization is a process that reduces the number of distinct colors used in an image with the intention that the new image should be as visually similar as possible to the original image. It is used when you convert, say, 24-bit image to 8-bit (or lower). </para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm.MedianCut">
            <summary>Median cut algorithm. The algorithm fits a box around all colors used in the RGB colorspace which it splits at the median value of its longest side. The algorithm stops after 255 recursions. All colors in one box are mapped to the centroid of this box.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm.Octree">
            <summary>Octree algorithm. The algorithm encodes image colour data as an octree up to nine levels deep. The node index to branch out from at the top level is determined by a formula that uses the most significant bits of the red, green, and blue colour components. The next lower level uses the next bit significance, and so on. Less significant bits are sometimes ignored to reduce the tree size. The algorithm is highly memory efficient because the tree's size can be limited. The bottom level of the octree consists of leaf nodes that accrue colour data not represented in the tree; these nodes initially contain single bits. If much more than the desired number of palette colours are entered into the octree, its size can be continually reduced by seeking out a bottom-level node and averaging its bit data up into a leaf node, pruning part of the tree. Once sampling is complete, exploring all routes in the tree down to the leaf nodes, taking note of the bits along the way, will yield approximately the required number of colours.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent">
            <summary>Contains possible values for color management rendering intents.</summary>
            <remarks>The definition of the rendering intent is given in ICC Profile Format Specification Version 3.4 which can be downloaded at this site:
<para><see href="http://www.color.org">http://www.color.org</see></para><para>
According to this document, rendering intent specifies the style of reproduction to be used during the evaluation of this profile in a sequence of profiles. It applies specifically to that profile in the sequence and not to the entire sequence. Typically, the
user or application will set the rendering intent dynamically at runtime or embedding time.
</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.AbsoluteColorimetric">
            <summary>Absolute colorimetric intent (also known as match intent). In this intent, any colors that fall outside the output device range are adjusted to the closest color that can be rendered, while all other colors are left unchanged. White point is preserved. For example, the whitest white of a paper is more yellow than the whitest white of a computer monitor. An image converted into the gamut of the printer using match intent would result in all colors being converted and matched into the gamut of the printer. The white point of the image is not moved to match the white point of the printer. Therefore, the distance of the colors to the white point may change. This produces an image that is less visually disconcerting to the user, but is also a less accurate rendition of printer output.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.Perceptual">
            <summary>Perceptual intent (also known as picture intent). According to clause 4.9 of ICC specification perceptual intent is a rendering intent that specifies the full gamut of the image is compressed or expanded to fill the gamut of the destination device. Gray balance is preserved but colorimetric accuracy might not be preserved.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.RelativeColorimetric">
            <summary>Relative colorimetric intent (also known as proof intent). In this intent, any colors that fall outside the output device range are adjusted to the closest color that can be rendered, while all other colors are left unchanged. However white point is not preserved. For example, the whitest white of a paper is more yellow than the whitest white of a computer monitor. An image converted into the gamut of the printer using relative colorimetric intent would result in all colors becoming more yellow. The white point of the image is moved to match the white point of the printer. All other colors in the image keep their position relative to the white point. This produces an image that more accurately reflects what the printed image will look like. However, the user may find it visually disconcerting.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.RelativeColorimetricBpc">
            <summary>Relative colorimetric intent (also known as proof intent) with additional black point compensation. In addition to operations made with <see cref="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.RelativeColorimetric" /> intent, this one tries to improve image histogram.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.Saturation">
            <summary>Saturation intent (also known as graphics intent). According to clause 4.12 of ICC specification, saturation intent is a rendering intent that specifies the saturation of the pixels in the image is preserved perhaps at the expense of accuracy in hue and lightness.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.CombineMode">
            <summary>Contains possible combine modes. They are used when the bitmap is drawn on window or blended with another bitmap.</summary>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Add">
            <summary>Add combine mode. Source and destination pixels are added.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Alpha">
            <summary>Alpha blending combine mode. Alpha blending is applied. Makes sense only if source has alpha channel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.AlphaOverlapped">
            <summary>Alpha overlapped combine mode. The same as <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Alpha" />, however alpha channel is also modified (maximum between source and destination channel is taken).</summary>
        </member>
		<member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.AlphaOverlay">
            <summary>Alpha overlay combine mode allows blending multiple transparent images and supports image reordering without quality loss.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.And">
            <summary>AND combine mode. Bitwise AND operation is applied for source and destination pixels.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Behind">
            <summary>Behind combine mode. Blends pixels only at transparent parts of destination bitmap.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Color">
            <summary>Color combine mode. The result pixel is constructed in the following way: hue and saturation are taken from the source pixel, luminosity is taken from destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Copy">
            <summary>Copy combine mode. Source pixel replaces destination one. Opacity setting is disregarded.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Difference">
            <summary>Difference combine mode. The result is a difference between destination and source pixels.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Divide">
            <summary>Divide combine mode. The result pixel is the destination pixel divided to source one.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Hue">
            <summary>Hue combine mode. The result pixel is constructed in the following way: hue is taken from the source pixel, saturation and luminosity are taken from destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.IfDarker">
            <summary>"If Darker" combine mode. The result pixel is a darkest between source and destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.IfLighter">
            <summary>"If Lighter" combine mode. The result pixel is a lightest between source and destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Invert">
            <summary>Invert combine mode.  Source pixel is inverted and blended with destination pixel in the same way as with <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Alpha" /> mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Luminosity">
            <summary>Luminosity combine mode. The result pixel is constructed in the following way: luminosity is taken from the source pixel, saturation and hue are taken from destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Multiply">
            <summary>Multiply combine mode. Source pixel is multiplied at the destination one and normalized to maximum luminosity value (255 for common pixel formats, and 65535 for extended ones).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Or">
            <summary>OR combine mode. Bitwise OR operation is applied for source and destination pixels.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Overlay">
            <summary>Overlay combine mode. Depending on destination pixel luminosity the <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Multiply" /> (darkening) or <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Screen" /> (lightening) is applied. This combine mode preserves highlights and shadows of the image.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Saturation">
            <summary>Saturation combine mode. The result pixel is constructed in the following way: saturation is taken from the source pixel, hue and luminosity are taken from destination pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Screen">
            <summary>Screen combine mode. Source pixel is inverted and multiplied at the destination one. After that this value is normalized to maximum luminosity value (255 for common pixel formats, and 65535 for extended ones).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Subtract">
            <summary>Substract combine mode. Source and destination pixels are added and maximum luminosity value (255 for common pixel formats, and 65535 for extended ones) is subtracted.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Texturize">
            <summary>Texturize combine mode. Source pixel is converted into grayscale and blended with destination pixel in the same way as with <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Alpha" /> mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.CombineMode.Xor">
            <summary>XOR combine mode. Bitwise XOR operation is applied for source and destination pixels.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Combiner">
            <summary>This class enables you to combine two bitmaps (or its sections) with configurable combine mode, opacity, etc.</summary>
            <remarks><para>
Two bitmaps are involved into this transform: 
</para><list type="number"><item><description>"Upper" image, or source bitmap. Pixels are taken from it. You specify it using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceBitmap" /> property.</description></item><item><description>"Lower" image, or destination bitmap. Pixels are combined with it. This bitmap is retrieved into <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)" /> method.</description></item></list><para>
Bitmaps can be combined in the different way: just copying pixels from one bitmap to another, alpha blending, bitwise operations, etc. You can adjust it with <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property. Property <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.Opacity" /> specifies a total opacity of the <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceBitmap" />. 
</para><para>
If you need to take source bitmap pixels only partially, you can specify rectangular area using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> property. In the same way you can specify an area of the destination bitmap where to put the pixels using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" /> property. By default both rectangles equals to the size of the source bitmap. If rectangles differs, this transform resizes a block of pixels taken from <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> to have the same size as <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" />. Using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.InterpolationMode" /> property you can manage interpolation quality/speed.
</para></remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
<seealso href="OverlayingImages.htm">Overlaying Images</seealso>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode">
            <summary>Gets/sets a combine mode.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.CombineMode" /> value specifying combine mode.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Alpha" />.</remarks>
            <seealso href="CombineModes.htm">Combine Modes</seealso>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle">
            <summary>Gets/sets the destination rectangle.</summary>
            <value>The source destination.</value>
            <remarks><para>
During combining, algorithm will put pixels to rectangular area of destination bitmap defined with this property. If this rectangle is empty (both width and heights are zero), <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> dimensions are used. If only one dimension is zero, it is calculated automatically to preserve aspect ratio of the destination bitmap.
</para><para>
When dimensions of <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" /> are not coincide each other, algorithm makes a resize (using interpolation algorithm defined with <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.InterpolationMode" /> property). 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during resizing (occurred when <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> or source bitmap has different dimension from <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" />).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.#ctor">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> class.</summary>
            <overloads><summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.#ctor(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> class. You can set main transform parameters without custom source and destination rectangles.</summary>
            <param name="sourceBitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance used as source bitmap. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceBitmap" /> property.</param>
            <param name="combineMode"><see cref="T:Aurigma.GraphicsMill.Transforms.CombineMode" /> value specifying combine mode. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.#ctor(Aurigma.GraphicsMill.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> class. You can set all transform parameters.</summary>
            <param name="sourceBitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance used as source bitmap. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceBitmap" /> property.</param>
            <param name="destinationRectangle">Destination rectangle. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" /> property.</param>
            <param name="sourceRectangle">Source rectangle. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> property.</param>
            <param name="combineMode"><see cref="T:Aurigma.GraphicsMill.Transforms.CombineMode" /> value specifying combine mode. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
            <param name="opacity">A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.Opacity">
            <summary>Gets/sets a total opacity of the source bitmap during combining.</summary>
            <value>A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</value>
            <remarks><para>
If <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.CombineMode" /> is <see cref="F:Aurigma.GraphicsMill.Transforms.CombineMode.Copy" />, this property is ignored.
</para><para>
Default value is 1.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceBitmap">
            <summary>Gets/sets a source bitmap which will be used to get pixels from.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance used as source bitmap.</value>
            <remarks>By default this property is set to <b>null</b>. However this transform cannot be executed with non-initialized source bitmap. So you should make sure that it is specified before applying the effect.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle">
            <summary>Gets/sets the source rectangle.</summary>
            <value>Source rectangle.</value>
            <remarks><para>During combining, algorithm will take pixels from rectangular area of source bitmap defined with this property. If this rectangle is empty (both width and heights are zero), entire bitmap is used. If only one dimension is zero, it is calculated automatically to preserve aspect ratio of the source bitmap.</para><para>
When dimensions of <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.SourceRectangle" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.DestinationRectangle" /> are not coincide each other, algorithm makes a resize (using interpolation algorithm defined with <see cref="P:Aurigma.GraphicsMill.Transforms.Combiner.InterpolationMode" /> property). 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Combiner.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Contrast">
            <summary>This class enables you to correct contrast of the image.</summary>
            <remarks>This class provides simple contrast adjustment functionality. Being extremely easy-to-use for end user (it has the single parameter <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />), it is used by professional retouchers very seldom (because as usual it leads to losses of details in highlights and/or shadows). 
<para>
You can also use this transform in automatic mode using <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property.
</para><para>
If you want to apply both brightness and contrast, you should consider <see cref="T:Aurigma.GraphicsMill.Transforms.BrightnessContrast" /> transform. Both of these operation will be performed at the single pass, so it will work faster than sequential execution of <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> and <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" />.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount">
            <summary>Gets/sets contrast modifier.</summary>
            <value>Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized.</value>
            <remarks><note>If you set <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property to <b>true</b>, and modifying <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> is reset to <b>false</b>.</note><para>
Default value is 0. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto">
            <summary>Gets/sets a value specifying if transform should be run in automatic mode.</summary>
            <value>A value specifying if transform should be run in automatic mode. If it is <b>true</b>, property <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" /> will be ignored and contrast modifier will be calculated automatically.</value>
            <remarks><note>If you set <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property to <b>true</b>, and modifying <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> is reset to <b>false</b>.</note><para>
When you create <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> without specifying brightness amount, default value is <b>true</b>. If amount is passed to constructor, default value is <b>false</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.CalculateAutoParameters(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Transforms.Lut@)" draft="yes">
            <summary>Returns contrast modifier value which the class would apply in automatic mode.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance for which the contrast modifier is calculated automatically.</param>
            <param name="lut">Out parameter. LUT which represents this contrast modification will be written into this parameter.</param>
            <overloads><summary>Returns contrast modifier value which the class would apply in automatic mode.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.CalculateAutoParameters(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Transforms.Lut@)">
            <summary>Returns contrast modifier value which the class would apply in automatic mode.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance for which the contrast modifier is calculated automatically.</param>
            <param name="lut">Out parameter. LUT which represents this contrast modification will be written into this parameter.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.#ctor(System.Boolean[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Brightness" /> class instance. Here you can specify what channels to process with this transform.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.#ctor(System.Boolean[],System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class instance. Here you can specify what channels to process with this transform and contrast modifier.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="amount">Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Contrast.#ctor(System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> class instance. Here you can specify a contrast modifier.</summary>
            <param name="amount">Contrast modifier value varying in range [-1, 1]. Minimum value (-1) will produce absolutely gray image, neutral value (0)  does no effect, maximum value (1) makes the image extremely posterized. You can change this value later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Crop">
            <summary>This class enables you to crop the image.</summary>
            <remarks>Crop transform returns pixels which are inside of the <i>cropping rectangle</i> (see <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> property). If cropping rectangle "grabs" pixels which are beyond of the image (e.g. rectangle is larger of the image, or its coordinates closer to the edge of the image than width of the rectangle), these pixels are filled with <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />.
<para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor">
            <summary>Gets/sets background color which is used when cropping rectangle takes pixels which are out of the image.</summary>
            <value>Crop background color value. If its color space does not conform pixel format of target bitmap, it is converted to bitmap color space.</value>
            <remarks>Default value is transparent white. It is instantiated as <see cref="T:Aurigma.GraphicsMill.RgbColor" /> until you specify another color value.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance.</summary>
            <remarks>If you use this constructor, do not forget to initialize cropping rectangle with <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" />.</remarks>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle here.</summary>
            <param name="x">X-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.X" /> property).</param>
            <param name="y">Y-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Y" /> property).</param>
            <param name="width">Width of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Width" /> property).</param>
            <param name="height">Height of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Height" /> property).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle and background color here.</summary>
            <param name="x">X-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.X" /> property).</param>
            <param name="y">Y-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Y" /> property).</param>
            <param name="width">Width of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Width" /> property).</param>
            <param name="height">Height of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Height" /> property).</param>
            <param name="backgroundColor">Crop background color value. If its color space does not conform pixel format of target bitmap, it is converted to bitmap color space. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle here.</summary>
            <param name="x">X-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.X" /> property).</param>
            <param name="y">Y-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Y" /> property).</param>
            <param name="width">Width of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Width" /> property).</param>
            <param name="height">Height of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Height" /> property).</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle and background color here.</summary>
            <param name="x">X-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.X" /> property).</param>
            <param name="y">Y-coordinate for the left upper corner of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Y" /> property).</param>
            <param name="width">Width of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Width" /> property).</param>
            <param name="height">Height of the cropping rectangle. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" /> (using <see cref="P:System.Drawing.RectangleF.Height" /> property).</param>
            <param name="backgroundColor">Crop background color value. If its color space does not conform pixel format of target bitmap, it is converted to bitmap color space. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Drawing.Rectangle)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle here.</summary>
            <param name="rect">Cropping rectangle. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Drawing.Rectangle,Aurigma.GraphicsMill.Color)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle and background color here.</summary>
            <param name="rect">Cropping rectangle. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" />.</param>
            <param name="backgroundColor">Crop background color value. If its color space does not conform pixel format of target bitmap, it is converted to bitmap color space. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Drawing.RectangleF)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle here.</summary>
            <param name="rect">Cropping rectangle. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.#ctor(System.Drawing.RectangleF,Aurigma.GraphicsMill.Color)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class instance. You are specifying cropping rectangle and background color here.</summary>
            <param name="rect">Cropping rectangle. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle" />.</param>
            <param name="backgroundColor">Crop background color value. If its color space does not conform pixel format of target bitmap, it is converted to bitmap color space. You can change it later through property <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Crop.Rectangle">
            <summary>Gets/sets cropping rectangle.</summary>
            <value>Cropping rectangle. Can intersect the bitmap only partially. In this case pixels which are outside of the bitmap are filled with <see cref="P:Aurigma.GraphicsMill.Transforms.Crop.BackgroundColor" />. This feature is also known as "outer crop".</value>
            <remarks>By default this rectangle has zero width and height. That's why it is necessary to always initialize this property before applying crop.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Crop.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Curves">
            <summary>This class enables you to apply tone correction used specified curve.</summary>
            <remarks>Using this class you can apply a tone correction similar to Adobe Photoshop Curves effect. You specify array of curve <see cref="P:Aurigma.GraphicsMill.Transforms.Curves.Points" />, these points are interpolated by cubic interpolation polynomial function (the same as building <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> from spline and applying it using <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> transform).</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.#ctor(System.Boolean[])">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class instance. Here you can specify what channels to process.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.#ctor(System.Boolean[],System.Drawing.PointF[])">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class instance. Here you can specify what channels to process in addition to array of points for curve.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="points">Array of points used to build the curve. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Curves.Points" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.#ctor(System.Drawing.PointF[])">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Curves" /> class instance. Here you can specify an array of points for curve.</summary>
            <param name="points">Array of points used to build the curve. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Curves.Points" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Curves.Points">
            <summary>Gets/sets an array of points used to build the curve.</summary>
            <value>Array of points used to build the curve.</value>
            <remarks>Coordinates are normalized on maximum possible luminosity value, i.e. you specify values in range [0, 1] and they are stretched either to [0, 255] or [0, 65535] depending on <i>extended</i> property value. Note, you still can specify values that are out of [0, 1] range, and algorithm automatically truncates the curve. If all points will be strictly inside of this range, algorithm will add points at:
<list type="bullet"><item><description>x equal to 0 and y equal to Y-coordinate of the leftmost point.</description></item><item><description>x equal to 1 and y equal to Y-coordinate of the rightmost point.</description></item></list></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Curves.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Cylindrize" draft="yes">
            <summary>This class enables you to apply cylindrize transform. Image will be looking like bended on cylinder.</summary>
            <remarks>This class is useful if you need to emulate the image to be bended on the cylinder surface, for example, mug. In this case the following sequence is used:
<list type="number"><item><description><see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> bitmap to fit it to cylinder parameters.</description></item><item><description>Use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> transform to distort image.</description></item><item><description>Combine distorted bitmap and mug image using <see cref="T:Aurigma.GraphicsMill.Transforms.Combiner" /> class, <see cref="M:Aurigma.GraphicsMill.Bitmap.Draw(Aurigma.GraphicsMill.Bitmap,System.Drawing.Rectangle,System.Drawing.Rectangle,Aurigma.GraphicsMill.Transforms.CombineMode,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)" /> method, or any other way.</description></item></list><para>
You can specify a number of cylinder parameters - height (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight" /> property), half-perimeter (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter" /> property), color (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" /> property). You also can specify position of the image relatively top left corner of the "face" part of cylinder (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.HorizontalOffset" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.VerticalOffset" /> properties). If the cylinder (e.g. mug) is tilted, you can take it into account with <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property. And of course like for any other geometry bitmap transform, you can specify interpolation algorithm (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.InterpolationMode" /> property) and background color (<see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.BackgroundColor" /> property).
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.BackgroundColor">
            <summary>Gets/sets background color. This color will be used to fill all the areas which are out of the cylinder.</summary>
            <value>Background color value.</value>
            <remarks>Default value is transparent white.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor">
            <summary>Gets/sets cylinder color. This color is used to fill the cylinder surface which is not covered with bitmap pixels.</summary>
            <value>Cylinder color value.</value>
            <remarks>Default value is transparent white.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter">
            <summary>Gets/sets half-perimeter of the cylinder (i.e. length of the surface visible to user).</summary>
            <value>Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken.</value>
            <remarks><para>
If you want entire image to fit on the visible part of cylinder, you should resize the bitmap first to make its width equal to cylinder half-perimeter.
</para><para>
Default value is -1.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight">
            <summary>Gets/sets cylinder height.</summary>
            <value>Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken.</value>
            <remarks>Default value is -1.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.HorizontalOffset">
            <summary>Gets/sets horizontal offset of the bitmap relatively top left corner of the visible part of the cylinder.</summary>
            <value>Horizontal offset of the bitmap on the cylinder.</value>
            <remarks>If you specify negative offset, the image will be shifted left on cylinder and part of the image will be invisible. Positive offset will shift the image right. Empty space between the left edge of bitmap and edge of the visible part of cylinder will be filled with <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.InterpolationMode">
            <summary>Gets/sets interpolation mode of the transform (i.e. algorithm which is used to resample bitmap).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform.</value>
            <remarks>As usual fast interpolation algorithms produces lower quality comparing to slow ones, and vice versa. That's why using this property you can select between speed and quality of resizing.
<para>
Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can specify slope angle here.</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can set such transform parameters as slope angle, interpolation mode, cylinder and background color.</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
            <param name="cylinderColor">Cylinder color value. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" /> property.</param>
            <param name="backgroundColor">Background color value. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can set here cylinder parameters (half-perimeter and height) and slope angle.</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter" /> property.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can set here cylinder parameters (half-perimeter and height), slope angle, and appearance details (colors, interpolation mode).</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter" /> property.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight" /> property.</param>
            <param name="cylinderColor">Cylinder color value. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" /> property.</param>
            <param name="backgroundColor">Background color value. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can set here cylinder parameters (half-perimeter and height), slope angle, and bitmap position.</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter" /> property.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight" /> property.</param>
            <param name="horizontalOffset">Horizontal offset of the bitmap on the cylinder. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.HorizontalOffset" /> property.</param>
            <param name="verticalOffset">Vertical offset of the bitmap on the cylinder. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.VerticalOffset" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class instance. You can set here cylinder parameters (half-perimeter and height), slope angle, and appearance details (colors, interpolation mode).</summary>
            <param name="slopeAngle">Slope angle of the cylinder. It can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle" /> property.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHalfPerimeter" /> property.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderHeight" /> property.</param>
            <param name="horizontalOffset">Horizontal offset of the bitmap on the cylinder. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.HorizontalOffset" /> property.</param>
            <param name="verticalOffset">Vertical offset of the bitmap on the cylinder. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.VerticalOffset" /> property.</param>
            <param name="cylinderColor">Cylinder color value. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" /> property.</param>
            <param name="backgroundColor">Background color value. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform. This value can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.InterpolationMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.SlopeAngle">
            <summary>Gets/sets a slope angle of the cylinder.</summary>
            <value>Slope angle of the cylinder.</value>
            <remarks><para>
It is often you need to bend the image on the cylindric surface like a mug, which is slightly tilted toward to user. It happens when objective of the camera shooting the mug is higher than mug. In this case you should estimate the angle of the slope and set it to this property to obtain more realistic result.
</para><para>
Default value is 5.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Cylindrize.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Cylindrize.VerticalOffset">
            <summary>Gets/sets vertical offset of the bitmap relatively top left corner of the visible part of the cylinder.</summary>
            <value>Vertical offset of the bitmap on the cylinder.</value>
            <remarks>If you specify negative offset, the image will be shifted up on cylinder and part of the image will be invisible. Positive offset will shift the image down. Empty space between the top edge of bitmap and edge of the visible part of cylinder will be filled with <see cref="P:Aurigma.GraphicsMill.Transforms.Cylindrize.CylinderColor" />.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Direction">
            <summary>Contains possible directions used to specify some edge or corner of image to be processed.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.Down">
            <summary>Down direction (bottom edge of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.DownLeft">
            <summary>Down-left direction (bottom-left corner of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.DownRight">
            <summary>Down-right direction (bottom-right corner of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.Left">
            <summary>Left direction (left edge of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.Right">
            <summary>Right direction (right edge of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.Up">
            <summary>Up direction (top edge of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.UpLeft">
            <summary>Up-left direction (top-left corner of image).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Direction.UpRight">
            <summary>Up-right direction (top-right corner of image).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.DistributionKind">
            <summary>Contains distribution kinds to generate random values.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DistributionKind.Gaussian">
            <summary>Gaussian (normal) distribution.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DistributionKind.Uniform">
            <summary>Uniform distribution.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.DitheringType">
            <summary>Contains possible values for dithering types. Dithering is an algorithm of color reducing which allows to preserve halftones.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Burkes">
            <summary>Burkes dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Fan">
            <summary>Fan dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.FloydSteinberg">
            <summary>Floyd-Steinberg dithering algorithm (most wide-spread one).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Jarvis">
            <summary>Jarvis dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Noise">
            <summary>White noise dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.None">
            <summary>No dithering.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedBayer2">
            <summary>Ordered Bayer dithering algorithm of order 2.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedBayer3">
            <summary>Ordered Bayer dithering algorithm of order 3.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedBayer4">
            <summary>Ordered Bayer dithering algorithm of order 4.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedSpiral2">
            <summary>Ordered spiral dithering algorithm of order 2.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedSpiral3">
            <summary>Ordered spiral dithering algorithm of order 3.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.OrderedSpiral4">
            <summary>Ordered spiral dithering algorithm of order 4.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Original">
            <summary>Original dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Sierra">
            <summary>Sierra dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Stephenson">
            <summary>Stephenson dithering algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.DitheringType.Stucki">
            <summary>Stucki dithering algorithm.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.EdgeDetect">
            <summary>This class enables you to find edges on the image.</summary>
            <remarks>This class uses certain spatial filters to detect edges. Using <see cref="P:Aurigma.GraphicsMill.Transforms.EdgeDetect.Mode" /> property you can specify some of edge detectors.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.EdgeDetect.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.EdgeDetect.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.EdgeDetect.Mode">
            <summary>Gets/sets an edge detector used to outline image edges.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetectMode" /> value specifying edge detector.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.EdgeDetect.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.EdgeDetect.#ctor(Aurigma.GraphicsMill.Transforms.EdgeDetectMode)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> class instance. You can specify edge detector here.</summary>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetectMode" /> value specifying edge detector. You can change this value later through <see cref="P:Aurigma.GraphicsMill.Transforms.EdgeDetect.Mode" /> property.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.EdgeDetectMode">
            <summary>Contains possible edge detect modes for <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.Glow">
            <summary>Glow edge detect mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.LaplaceHV">
            <summary>Laplacian edge detector (horizontal/vertical).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.LaplaceOmni">
            <summary>Laplacian edge detector (omni-directional).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.Pattern">
            <summary>Pattern edge detect mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.Prewitt">
            <summary>Prewitt edge detector.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.Sharp">
            <summary>Sharp edge detect mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.SharpMore">
            <summary>Strong sharp edge detect mode.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.EdgeDetectMode.TraceContour">
            <summary>Trace contour edge detector.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Emboss">
            <summary>This class enables you to apply effect of emboss on the image.</summary>
            <remarks><para>This effect imitates embossed image. You can adjust angle of the emboss (property <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Angle" />). The strength of the effect is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Amount" />. Also you can set a height of the emboss (property <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Height" />). Avoid to set too large height, because it will not be looking naturally. The last parameter you can change is a brightness of the output image (property <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Brightness" />). </para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Emboss.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Emboss.Amount">
            <summary>Gets/sets emboss amount ("strength" of embossing).</summary>
            <value>Value specifying emboss amount ("strength" of embossing). It is specified in percents - values below 100 will reduce contrast, values above 100 will increase contrast.</value>
            <remarks>Default value is 100.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Emboss.Angle">
            <summary>Gets/sets emboss angle (in degrees).</summary>
            <value>Emboss angle (in degrees).</value>
            <remarks>Default value is 135 degrees.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Emboss.Brightness">
            <summary>Gets/sets embossed image brightness.</summary>
            <value>Value in range [-1, 1] specifying embossed image brightness.</value>
            <remarks><para>Typically it is useless to specify values which is out of range [0, 1]. However you still can specify value less than 0.</para><para>Default value is 0.5f.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Emboss.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Emboss.Height">
            <summary>Gets/sets an embossing pixel height.</summary>
            <value>Value specifying embossed image height (in pixels).</value>
            <remarks>Default value is 3.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Emboss.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Emboss.#ctor(System.Single,System.Int32,System.Int32)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class instance. You can set main emboss parameters (angle, height, and amount) here.</summary>
            <param name="angle">Emboss angle (in degrees). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Angle" /> property.</param>
            <param name="height">Value specifying embossed image height (in pixels). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Height" /> property.</param>
            <param name="amount">Value specifying emboss amount ("strength" of embossing). It is specified in percents - values below 100 will reduce contrast, values above 100 will increase contrast. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Amount" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Emboss.#ctor(System.Single,System.Int32,System.Int32,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class instance. You can set all emboss parameters here.</summary>
            <param name="angle">Emboss angle (in degrees). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Angle" /> property.</param>
            <param name="height">Value specifying embossed image height (in pixels). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Height" /> property.</param>
            <param name="amount">Value specifying emboss amount ("strength" of embossing). It is specified in percents - values below 100 will reduce contrast, values above 100 will increase contrast. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Amount" /> property.</param>
            <param name="brightness">Value in range [-1, 1] specifying embossed image brightness. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Emboss.Brightness" /> property.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.FadeType">
            <summary>Contains various fade types for a number of artistic effects.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.FadeType.Linear">
            <summary>Linear fading.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.FadeType.None">
            <summary>No fading.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.FadeType.Nonlinear">
            <summary>Non-linear fading.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.FloodFill">
            <summary>This transform provides flood fill algorithm (analogue to Paint Bucket tool in the Adobe Photoshop).</summary>
            <remarks><para>
This transform works in the following way: you specify a start point (with <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property) and it begins filling this point and its neighbour with a color specified with <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property until a boundary will be met. Boundary can be defined in different ways: either as pixels of color equal to <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property, or pixels which differ from this color. It is specified with <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.
</para><para>
As color values can differ very slightly (due various factors: noise, JPEG compression artifacts, or image features), sometimes algorithm can work not very well. In these situations you can use property <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" />. This property means the how close current pixel color can be to target color to match. If tolerance is very small only colors very close to target color matches. If big value specified (near 1), almost all colors matches. Thereby if property <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones" /> is set to <b>false</b>, algorithm will just replace all matching colors, otherwise it will blend matching colors with the original pixel using distance between these colors as a transparency level (this way you can produce more or less smooth edges on the boundaries).
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor">
            <summary>Gets/sets a color used to fill the surface.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with.</value>
            <remarks>Default value is black color.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode">
            <summary>Gets/sets a value specifying how to determine the filling area boundary.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set main flood fill parameters here.</summary>
            <param name="x">X-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="y">Y-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set all flood fill parameters here.</summary>
            <param name="x">X-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="y">Y-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by filling color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.PreserveAlpha" /> property.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set main flood fill parameters here.</summary>
            <param name="x">X-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="y">Y-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set all flood fill parameters here.</summary>
            <param name="x">X-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="y">Y-coordinate of the point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by filling color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.PreserveAlpha" /> property.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Drawing.Point,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set main flood fill parameters here.</summary>
            <param name="point"><see cref="T:System.Drawing.Point" /> structure that specifies a point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Drawing.Point,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set all flood fill parameters here.</summary>
            <param name="point"><see cref="T:System.Drawing.Point" /> structure that specifies a point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by filling color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.PreserveAlpha" /> property.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Drawing.PointF,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set main flood fill parameters here.</summary>
            <param name="point"><see cref="T:System.Drawing.PointF" /> structure that specifies a point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.#ctor(System.Drawing.PointF,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.FloodFillMode,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> class instance. You can set all flood fill parameters here.</summary>
            <param name="point"><see cref="T:System.Drawing.PointF" /> structure that specifies a point to start filling from. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point" /> property.</param>
            <param name="fillColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies a color to fill with. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> property.</param>
            <param name="targetColor">The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries. The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" /> property.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.FloodFillMode" /> value specifying how to determine the filling area boundary (see comments for <i>targetColor</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Mode" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" /> property.</param>
            <param name="preserveAlpha">Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by filling color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.PreserveAlpha" /> property.</param>
            <param name="processHalftones">Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors). You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.Point">
            <summary>Gets/sets a start point for the flood fill algorithm.</summary>
            <value><see cref="T:System.Drawing.PointF" /> structure specifying the point to start filling from.</value>
            <remarks>Default flood fill start position is a left top corner of the bitmap (point with coordinates (0, 0)).</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.PreserveAlpha">
            <summary>Get/sets a value that specifies if to leave alpha channel intacted with the flood fill algorithm.</summary>
            <value>Value specifying if to preserve alpha channel. If <b>true</b>, alpha channel will not be overwritten by the <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" />.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.ProcessHalftones">
            <summary>Gets/sets a value that specifies how to process colors which are not exactly match the <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" />, but are tolerant enough.</summary>
            <value>Value specifying how to handle situations when current color does not exactly match target color, but tolerant to it (with specified <i>tolerance</i>). If <b>false</b>, this pixel is replaced with brush color, if <b>true</b>, it is alpha-blended (alpha is calculated as 1 - T, where T is actual tolerance between these colors).</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor">
            <summary>Gets/sets a target color that is used to find the boundaries of area to fill.</summary>
            <value>The <see cref="T:Aurigma.GraphicsMill.Color" /> which is used to determine the filling area boundaries.</value>
            <remarks><para>
The method behaviour depends on <i>mode</i> argument value. If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor" />, this is a boundary color (when algorithm meets this color, it stops filling). If <i>mode</i> is <see cref="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor" />, this is a surface color (algorithm continue filling till current color is the same as target color).
</para><para>
Default value is a white color.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.FloodFill.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance">
            <summary>Gets/sets a maximum allowed tolerance for the target color.</summary>
            <value>Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and target color (see comments for <i>targetColor</i>). Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</value>
            <remarks>Default value is 0.1.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.FloodFillMode">
            <summary>Contains values which specify when stop filling to the <see cref="T:Aurigma.GraphicsMill.Transforms.FloodFill" /> algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.TillColor">
            <summary>Fill with <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> till color of the current pixel is the same (or similar with given <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" />) as <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" />.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.FloodFillMode.UntilColor">
            <summary>Fill with <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.FillColor" /> until color of the current pixel is the same (or similar with given <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.Tolerance" />) as <see cref="P:Aurigma.GraphicsMill.Transforms.FloodFill.TargetColor" />.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Glow">
            <summary>This class allows you making opaque objects on the image to glow.</summary>
            <remarks><para>
When you apply this effect, the image begins glow with specified parameters (taking into account transparent areas of the image). This effect is ideal for creating artistic texts, logos, etc.  
</para><para>
You can specify <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.GlowColor" /> as well as parameters which infuence on the glow size and density: <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.Intensity" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.Radius" />. Property <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.EnlargeToFit" /> can be used to specify if the transform should increase size of the image to fit the glow or it should truncate the glow which is out of the original image (makes sense to set it to <b>true</b> when you create artistic thumbnails).
</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Glow.EnlargeToFit">
            <summary>Gets/sets value that specifies whether to enlarge the image to fit entire glow or put it to the image of the same size (in this case glow which is out of the image will be cut off).</summary>
            <value>Value that specifies whether to enlarge the image to fit entire glow.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Glow.GlowColor">
            <summary>Gets/sets glow color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies glow color.</value>
            <remarks>Default value is a yellow color.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Glow.Intensity">
            <summary>Gets/sets glow intensity.</summary>
            <value>Positive <see cref="T:System.Single" /> value that specifies glow intensity. Small values (about 1.0 or below) provide hardly visible glow. In the same time, large values (say, about 50) provide too heavy glow.</value>
            <remarks><para>Default value is 3.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.#ctor(Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class instance. You can set glow color here.</summary>
            <param name="glowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies glow color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.GlowColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.#ctor(Aurigma.GraphicsMill.Color,System.Single,System.Single,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class instance. You can set all glow parameters here.</summary>
            <param name="glowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies glow color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.GlowColor" /> property.</param>
            <param name="intensity">Positive <see cref="T:System.Single" /> value that specifies glow intensity. Small values (about 1.0 or below) provide hardly visible glow. In the same time, large values (say, about 50) provide too heavy glow.  You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.Intensity" /> property.</param>
            <param name="radius">Value that specifies a blur radius used to blur the glow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.Radius" /> property.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire glow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Glow.EnlargeToFit" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Glow.Radius">
            <summary>Gets/sets a blur radius used to blur the glow.</summary>
            <value>Value that specifies a blur radius used to blur the glow.</value>
            <remarks><para>
This parameter works in the same way as <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Radius" /> of the <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> transform.
</para><para>
Default value is 12.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Glow.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" draft="yes">
            <summary>This class enables you to apply histogram equalization algorithm.</summary>
            <remarks><para>
Histogram equalization algorithm is used to automatically enhance a contrast of the image. As usual it makes the image too posterized, that's why it is seldom used to with photos (you should use <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> effect with <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> property set to <b>true</b>). However it suits for scientific tasks (as a preparation before applying some specific algorithm like vectorization, recognition, etc).
</para><para>
Main idea of this algorithm is to build such look-up table (LUT) which makes the bitmap histogram equalized (all histogram entries are equal each other). Actually the histogram is never equalized absolutely, however this algorithm makes it as much as possible. After that this LUT is applied using <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyLut" /> class.
</para><para>
This class enables you to use not only histogram of the source bitmap, but any other histogram too. In this case algorithm will build the LUT for this histogram, but apply this LUT on the source bitmap. To specify another histogram, use property <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" />. If you want to get histogram from the bitmap automatically, set <b>null</b> to this property.
</para><para>
As long as this class is inherited from <see cref="T:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform" /> class, you can equalize histogram for specific channels. Just use <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> property, <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.SelectAllChannels" />, and <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.DeselectAllChannels" /> methods in the common way for this.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram">
            <summary>Gets/sets a histogram should be equalized.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance containing a histogram to equalize. Can be <b>null</b>.</value>
            <remarks><para>
If histogram is not set (this property equals to <b>null</b>), algorithm automatically builds it from the bitmap at which the effect is applied (depending on <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> property). Otherwise it will build LUT that equalizes this histogram and apply it on the image.
</para><para>
Default value is <b>null</b>.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode">
            <summary>Gets/sets value that specifies how to build histogram if no custom histogram specified.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.HistogramMode" />value that specifies how to build histogram if no custom histogram specified.</value>
            <remarks>If both <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" /> specified, histogram mode is ignored (custom histogram used).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance.</summary>
            <overloads><summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor(Aurigma.GraphicsMill.Histogram)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance. You can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" /> property with custom histogram.</summary>
            <param name="histogram"><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance containing a histogram to equalize. Can be <b>null</b>. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor(Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance. You can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> property.</summary>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor(System.Boolean[])">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance. Here you can specify what channels to process with this transform.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor(System.Boolean[],Aurigma.GraphicsMill.Histogram)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance. Here you can specify what channels to process with this transform. Besides of this, you can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" /> property with custom histogram.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="histogram"><see cref="T:Aurigma.GraphicsMill.Histogram" /> class instance containing a histogram to equalize. Can be <b>null</b>. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.Histogram" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.#ctor(System.Boolean[],Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class instance. Here you can specify what channels to process with this transform. Besides of this, you can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> property.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.HistogramEqualize.HistogramMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.HistogramEqualize.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.InterpolationMode">
            <summary>Contains possible interpolation modes for geometrical transformations applied to bitmaps.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.Anisotropic4">
            <summary>Anisotropic filtration with 4 points.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.Anisotropic9">
            <summary>Anisotropic filtration with 9 points.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.BellFilter">
            <summary>Two-pass bell filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.Bilinear">
            <summary>Bilinear algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.BoxFilter">
            <summary>Two-pass box filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.HermiteFilter">
            <summary>Two-pass Hermite filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.HighQuality">
            <summary>Best quality algorithm (usually lowest speed). When two-pass algorithms are available, <b>Lanczos3Filter</b> is used, for indexed images it is <b>ScaleToGray</b>, and <b>Anisotropic9</b> for others.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.HighSpeed">
            <summary>Fastest algorithm (usually has the lowest quality). The same as <b>LowQuality</b>.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.Lanczos3Filter">
            <summary>Two-pass Lanczos filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.LowQuality">
            <summary>Lowest quality algorithm (but usually fastest one). It is always the same as <b>NearestNeighbour</b>.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.LowSpeed">
            <summary>Slowest algorithm (as usually it has the highest quality). The same as <b>HighQuality</b>.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality">
            <summary>Medium quality algorithm (as usual with medium speed). When it is possible, it equals to <b>Bilinear</b>, for indexed images it is <b>ScaleToGray</b> and <b>NearestNeighbour</b> for the rest cases.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumSpeed">
            <summary>Medium speed algorithm (as usual has medium quality). The same as <b>MediumQuality</b>.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MitchellFilter">
            <summary>Two-pass Mitchell filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.NearestNeighbour">
            <summary>Nearest neighbour algorithm.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.ScaleToColor">
            <summary>Scale-to-color (for indexed images only). 4-bit and 8-bit indexed images are converted to 24-bit RGB. Numerically it is the same as <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.ScaleToGray" />.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.ScaleToGray">
            <summary>Scale-to-gray mode (for indexed images only). 1-bit indexed images are is converted to 8-bit grayscale here. Numerically it is the same as <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.ScaleToColor" /></summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.SplineFilter">
            <summary>Two-pass spline filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.TriangleFilter">
            <summary>Two-pass triangle filter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.Trilinear">
            <summary>Trilinear algorithm.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Invert">
            <summary>This transform enables you to invert all colors in the bitmap.</summary>
            <remarks>This class has no parameters.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Invert.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Invert.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Invert" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Invert" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Invert.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Invert" /> class instance.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Levels">
            <summary>This class enables you to apply levels correction.</summary>
            <remarks><para>
Using this class you can apply a tone correction similar to Adobe Photoshop Levels effect. You specify <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Shadows" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Midtones" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Highlights" />, as well as <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MinimumLevel" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MaximumLevel" /> modifiers. These values works in the same way as appropriate sliders in Adobe Photoshop.
</para><para>
It also can be applied automatically. To do it, set <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property to <b>true</b>. 
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.Auto">
            <summary>Gets/sets a value specifying if transform should be run in automatic mode.</summary>
            <value>A value specifying if transform should be run in automatic mode. If it is <b>true</b>, all settings will be calculated automatically.</value>
            <remarks><note>If you set <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Auto" /> property to <b>true</b>, and modifying <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Amount" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Contrast.Auto" /> is reset to <b>false</b>.</note><para>
When you create <see cref="T:Aurigma.GraphicsMill.Transforms.Contrast" /> without specifying brightness amount, default value is <b>true</b>. If amount is passed to constructor, default value is <b>false</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.Highlights">
            <summary>Gets/sets highlights level modifier.</summary>
            <value>Value in range [0, 1] that contains highlights level modifier.</value>
            <remarks><para>This value is normalized to 1. Inside the transform it will be stretched to 255 or 65355 depending on pixel format (for 8 bits per channel formats it will be 255, for 16 bit per channel - 65355). For example, for example, if you apply this transform on the bitmap with <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" /> pixel format, and this property is 0.9, algorithm will treat it as 229. </para><para>
With this property you specify the upper bound of new tone range. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode">
            <summary>Gets/sets value that specifies how to build histogram during levels adjusting.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.HistogramMode" />value that specifies how to build histogram during levels adjusting.</value>
            <remarks>Adobe Photoshop builds histogram using <see cref="F:Aurigma.GraphicsMill.HistogramMode.Sum" /> technique.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.MaximumLevel">
            <summary>Gets/sets maximum output level.</summary>
            <value>Value in range [0, 1] that specifies maximum output level.</value>
            <remarks><para>This value is normalized to 1. Inside the transform it will be stretched to 255 or 65355 depending on pixel format (for 8 bits per channel formats it will be 255, for 16 bit per channel - 65355). For example, for example, if you apply this transform on the bitmap with <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" /> pixel format, and this property is 0.9, algorithm will treat it as 229. </para><para>
This property is useful when you are preparing image for printing at the printer which does not support too high tone levels. This way instead of truncating highlights you can compress a tone range and preserve details in highlights at the hardcopy. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.Midtones">
            <summary>Gets/sets midtones modifier.</summary>
            <value>Value in range [0.1, 10] that contains midtones modifier.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.MinimumLevel">
            <summary>Gets/sets minimum output level.</summary>
            <value>Value in range [0, 1] that specifies minimum output level.</value>
            <remarks><para>This value is normalized to 1. Inside the transform it will be stretched to 255 or 65355 depending on pixel format (for 8 bits per channel formats it will be 255, for 16 bit per channel - 65355). For example, for example, if you apply this transform on the bitmap with <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" /> pixel format, and this property is 0.1, algorithm will treat it as 25. </para><para>
This property is useful when you are preparing image for printing at the printer which does not support too low tone levels. This way instead of truncating shadows you can compress a tone range and preserve details in shadows at the hardcopy. 
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor" draft="yes">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance.</summary>
            <overloads><summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor(Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance. You can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property here.</summary>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor(System.Boolean[])">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance. Here you can specify what channels to process with this transform.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor(System.Boolean[],Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance. Here you can specify what channels to process with this transform. Besides of this, you can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor(System.Boolean[],System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance. Here you can specify all the levels adjustment settings as well as channels to process with this transform. Besides of this, you can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped. You can change to this array later through the property <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />.</param>
            <param name="minimumLevel">Value in range [0, 1] that specifies minimum output level. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MinimumLevel" /> property.</param>
            <param name="maximumLevel">Value in range [0, 1] that specifies maximum output level. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MaximumLevel" /> property.</param>
            <param name="shadows">Value in range [0, 1] that contains shadows level modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Shadows" /> property.</param>
            <param name="midtones">Value in range [0.1, 10] that contains midtones modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Midtones" /> property.</param>
            <param name="highlights">Value in range [0, 1] that contains highlights level modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Highlights" /> property.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Levels.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.HistogramMode)">
            <summary>Create and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Levels" /> class instance. Here you can specify all the levels adjustment settings. Besides of this, you can initialize <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</summary>
            <param name="minimumLevel">Value in range [0, 1] that specifies minimum output level. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MinimumLevel" /> property.</param>
            <param name="maximumLevel">Value in range [0, 1] that specifies maximum output level. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.MaximumLevel" /> property.</param>
            <param name="shadows">Value in range [0, 1] that contains shadows level modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Shadows" /> property.</param>
            <param name="midtones">Value in range [0.1, 10] that contains midtones modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Midtones" /> property.</param>
            <param name="highlights">Value in range [0, 1] that contains highlights level modifier. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.Highlights" /> property.</param>
            <param name="histogramMode"><see cref="T:Aurigma.GraphicsMill.HistogramMode" /> value specifying how to build the histogram. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Levels.HistogramMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.Shadows">
            <summary>Gets/sets shadows level modifier.</summary>
            <value>Value in range [0, 1] that contains shadows level modifier.</value>
            <remarks><para>This value is normalized to 1. Inside the transform it will be stretched to 255 or 65355 depending on pixel format (for 8 bits per channel formats it will be 255, for 16 bit per channel - 65355). For example, for example, if you apply this transform on the bitmap with <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" /> pixel format, and this property is 0.1, algorithm will treat it as 25. </para><para>
With this property you specify the lower bound of new tone range. 
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Levels.Threshold">
            <summary>Gets/sets threshold level.</summary>
            <value>Threshold level on which correction should be based.</value>
            <remarks><para>The threshold value is used to define a percent of pixels on edges of the tonal range to discard. Threshold = 1 is 100% of pixels. To get more or less realistic result, use a value less than 1% (0.01). For example: </para><list type="bullet"><item><description>If you want to get a result similar to Photoshop 7, use 0.5% (0.005).</description></item><item><description>If you want a result similar to Photoshop CS or later, use 0.1% (0.001).</description></item></list></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Lut">
            <summary>This class represents look-up table (LUT) used for tone correction.</summary>
            <remarks><para>
Look-up tables are used in most tone correction algorithms. LUT defines a "luminosity function", in other words, a rule which translate channel luminosity to another value. Actually it is implemented as an array where entries means the luminosity values for channels which has luminosity equal to this entry index. To make it more clean, let's see the pseudocode for the algorithm which uses LUT:
</para><code language="VB" source="CodeSnippets/LUT.vb"></code><code language="CS" source="CodeSnippets/LUT.cs"></code><para>
For LUT entries the following rules are true:
</para><list type="number"><item><description>Minimum value of the LUT entry is 0.</description></item><item><description>Maximum value of the LUT entry is a maximum possible luminosity for target pixel format. If pixel format is not extended (i. e. it has 8 bits per channel), maximum value is 255. For extended pixel formats (16 bits per channel) maximum value is 65535.  </description></item><item><description>LUT has as much entries as maximum possible luminosity (for 8 bit per channel images it is 255, for 16 bits per channel images - 65535).</description></item><item><description>If LUT is not define monotone increasing function, some pixel values will be inverted (at the decreasing function sections).</description></item></list><para>
As LUT values depend on the target bitmap pixel format (saying more precisely, it depends on the channel bit depth), this class provides a property <see cref="P:Aurigma.GraphicsMill.Transforms.Lut.IsExtended" />. When you change it, the look-up table is resized either to 8-bit or 16-bit case. Besides of that each contrustor (instead of parameterless one) has argument specifying what bit depth to use.
</para><note>
If you create 16-bit LUT, then set <see cref="P:Aurigma.GraphicsMill.Transforms.Lut.IsExtended" /> property to <b>false</b> (convert it to 8-bit), and after that set it back to <b>true</b>, LUT won't be the same as initially. Some information can be lost. It interpolates the missing entries linearly.
</note><para>
You can fill the LUT as if it is common array using property <see cref="P:Aurigma.GraphicsMill.Transforms.Lut.Item(System.Int32)" />. To check how much entries it actually has, use <see cref="P:Aurigma.GraphicsMill.Transforms.Lut.Length" /> property. You can also create predefined LUTs using <b>BuildXXX</b> methods. For example, <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildEmpty(System.Boolean)" /> method creates LUT filled with zeros. <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromSpline(System.Drawing.PointF[],System.Boolean)" /> method defines a LUT as a curve which passes specified array of points. <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildLinear(System.Single,System.Single,System.Boolean)" /> method defines a LUT as a linear function with given parameters.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildEmpty(System.Boolean)">
            <summary>Resets all LUT entries to zero.</summary>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromArray(System.Int32[])">
            <summary>Builds a LUT from specified array.</summary>
            <param name="array">An array containing LUT entries. If this array contains 256 elements, LUT considered as non-extended. If array contains 65536 elements, LUT is extended. All other array length values are incorrect.</param>
            <remarks>Method checks if LUT entries are in proper range (from 0 to maximum luminosity value). If it finds out that some entry exceeds this range, exception is thrown.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromBitmapHistogram(Aurigma.GraphicsMill.Bitmap)">
            <summary>Builds a LUT which would make histogram of the specified bitmap as uniform as possible.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance to get histogram from.</param>
            <remarks>Typically this LUT is used to apply histogram equalization algorithm. You can also do it using <see cref="T:Aurigma.GraphicsMill.Transforms.HistogramEqualize" /> class.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromGamma(System.Single,System.Boolean)">
            <summary>Builds a LUT which makes the gamma correction.</summary>
            <param name="gamma">Gamma value (typically in range [1, 3]).</param>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromSpline(System.Drawing.PointF[],System.Boolean)">
            <summary>Builds LUT defined as a curve which passes specified set of points.</summary>
            <param name="points">Array of curve points. Coordinates are normalized on maximum possible luminosity value, i.e. you specify values in range [0, 1] and they are stretched either to [0, 255] or [0, 65535] depending on <i>extended</i> property value. Note, you still can specify values that are out of [0, 1] range, and algorithm automatically truncates the curve. If all points will be strictly inside of this range, algorithm will add points at:
<list type="bullet"><item><description>x equal to 0 and y equal to Y-coordinate of the leftmost point.</description></item><item><description>x equal to 1 and y equal to Y-coordinate of the rightmost point.</description></item></list></param>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildIdentical(System.Boolean)">
            <summary>Builds an <i>identical</i> LUT, i.e. a LUT which does not modify the source image.</summary>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
            <remarks>This LUT is represented with a line beginning in point (0, 0) with angle relatively x-axis equal to 45 degrees. So you can also produce it using method <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildLinear(System.Single,System.Single,System.Boolean)" /> with <i>a</i> argument equal to 1 and <i>b</i> equal to 0.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildLinear(System.Single,System.Single,System.Boolean)">
            <summary>Builds a LUT from linear function with given parameters.</summary>
            <param name="a">Value that specifies <i>a</i> parameter of the linear function (an angle of the line slope). See <b>Remarks</b> section for more details.</param>
            <param name="b">Value that specifies <i>b</i> parameter of the linear function (a line shift relatively the origin of coordinates). See <b>Remarks</b> section for more details.</param>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
            <remarks><para>
Linear functions are described with two parameters <i>a</i> and <i>b</i> in the following way:
</para><para><c>f(x) = a * x + b</c></para><para>
Argument <i>a</i> defines an angle of the line slope (to be more precise, it is a tangent of this angle). When this argument is 0, function degenerates to <c>f(x) = b</c>, and the line becomes parallel to the x-axis. 
</para><para>
Argument <i>b</i> defines a shift of the line relatively the origin of coordinates, i. e. point (0, 0). When this argument is 0, function degenerates to <c>f(x) = a*x</c>, and the line passes through the origin of coordinates. 
</para><para>
Quite often you have two points and need to build a line which connects them. Let's assume that these points are specified with coordinates (x1, y1) and (x2, y2) correspondingly. In this case you can calculate parameters <i>a</i> and <i>b</i> in the following way:
</para><code>a = (y1 - y2) / (x1 - x2)
b = (y2 * x1 - y1 * x2) / (x1 - x2)</code><para>
Draw attention, x1 and x2 cannot be equal to avoid division by zero. It means that you cannot specify a line which is absolutely parallel to y-axis. As a workaround, you should compare these values before <i>a</i> and <i>b</i> calculating, and if they are equal, add to one of them small number (e.g. 0.001). As LUT is a discrete function, it will cause no problem.
</para><para>Linear function with <i>a</i> = 1 and <i>b</i> = 0 produces LUT which does not change an image (in other words, input luminosity values are mapped to the same output values). You can also create such LUT with <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildIdentical(System.Boolean)" /> method.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.BuildStaircase(System.Int32,System.Boolean)">
            <summary>Builds a LUT from a staircase function with a given number of steps.</summary>
            <param name="steps">Number of the staircase function steps. Minimum value is 0 (single horizontal line will be produced).</param>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
            <remarks>Using staircase function you can apply a posterize effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance containing full copy of current LUT.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.GetEnumerator">
            <summary>Returns an enumerator for the LUT entries allowing it to be used in <b>foreach</b> blocks.</summary>
            <returns>Enumerator that implements <see cref="T:System.Collections.IEnumerator">System.Collections.IEnumerator</see> interface.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Lut.IsEmpty">
            <summary>Returns whether LUT array is initialized.</summary>
            <value>Value that specifies whether LUT array is initialized.</value>
            <remarks>When you create a <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> instance with a <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.#ctor">constructor without parameters</see>, this property will return <b>true</b>. In all other situations LUT array is always available and it returns <b>false</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Lut.IsExtended">
            <summary>Switches LUT between extended and non-extended mode.</summary>
            <value>Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</value>
            <remarks>If you create 16-bit LUT, then set this property to <b>false</b> (convert it to 8-bit), and after that set it back to <b>true</b>, LUT won't be the same as initially. Some information can be lost. It interpolates the missing entries linearly.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Lut.Item(System.Int32)">
            <summary>Gets/sets a LUT entry by index.</summary>
            <param name="index">Index of the target LUT entry.</param>
            <value>LUT entry value.</value>
            <remarks>When you modifies the entry, it checks if new value is in proper range (from 0 to maximum luminosity value). If it finds out that it exceeds this range, exception is raised.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Lut.Length">
            <summary>Returns number of LUT entries.</summary>
            <value>Number of LUT entries.</value>
            <remarks>When LUT array is not initialized (<see cref="P:Aurigma.GraphicsMill.Transforms.Lut.IsEmpty" /> = <b>true</b>), it returns 0. If property <see cref="P:Aurigma.GraphicsMill.Transforms.Lut.IsExtended" /> is <b>false</b>, it returns 256. Otherwise it returns 65536.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance.</summary>
            <remarks>No LUT array is initialized with this constructor. You should do it with some of <b>BuildXXX</b> method.</remarks>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.#ctor(System.Boolean)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance and calls <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildEmpty(System.Boolean)" /> method to initialize the LUT array.</summary>
            <param name="extended">Value that specifies if LUTshould be build for extended (16 bits per channel) or non-extended (8 bits per channel) bitmaps. If it is <b>true</b>, LUT entries number is 65536 and maximum value is 65535, otherwise entries number is 256 and maximum value is 255.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Lut.#ctor(System.Int32[])">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Lut" /> class instance and calls <see cref="M:Aurigma.GraphicsMill.Transforms.Lut.BuildFromArray(System.Int32[])" /> method to initialize the LUT array.</summary>
            <param name="array">An array containing LUT entries. If this array contains 256 elements, LUT considered as non-extended. If array contains 65536 elements, LUT is extended. All other array length values are incorrect.</param>
            <remarks>This constructor checks if LUT entries are in proper range (from 0 to maximum luminosity value). If it finds out that some entry exceeds this range, exception is thrown.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform" draft="yes">
            <summary>This is a base class for all transforms which can be applied with mask.</summary>
            <remarks><para>
Transforms inherited from this class guaranties that they do not modify neither pixel format of the bitmap, nor its dimensions. It means that these transforms can be applied directly in-place (without creating bitmap copy). It has additional overloaded <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData)" /> method which works in this way. It makes this transform running faster and consuming less memory, however if user will abort the transform, the effect will be partially applied (e.g. if user stops the contrast enhancement, half of image will have modified contrast, the rest part of image will be unchanged). So if you use it in this way, you should keep this fact in mind.
</para><para>
Another interesting feature of this class descendants is possibility to apply the effect with specified mask. Mask is a grayscale image of the same size as target bitmap which defines "region of interest" (ROI) in raster form. Black pixels on this mask are treated as transparent and effect is applied for appropriate pixels on target bitmap. White pixels are opaque and original pixels are copied to the target bitmap. Mask can be compared with a following sequense of actions:
</para><list type="number"><item><description>Effect is applied on copy of the original image.</description></item><item><description>Mask bitmap replaces alpha channel in modified image.</description></item><item><description>This image is alpha-blended with original image.</description></item></list><para>
To apply transform with mask, you should use <see cref="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)" /> method.
</para></remarks>
            <seealso href="OverlayingImages.htm">Overlaying Images</seealso>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap "in-place" using specified mask.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <remarks>You can create empty mask for the bitmap using <see cref="M:Aurigma.GraphicsMill.Bitmap.GetEmptyMask" /> method. This method always returns mask with proper dimensions and pixel format. Initially this mask is fully transparent (filled with black pixels). You should draw necessary non-transparent areas yourself.</remarks>
            <overloads><summary>Transforms given bitmap using specified mask.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged) using specified mask.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap data "in-place" using specified mask.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> which should be transformed. Result of the transform will be saved to the same bitmap data (in other word, transform is applied "in-place").</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <remarks>You can create empty mask for the bitmap using <see cref="M:Aurigma.GraphicsMill.Bitmap.GetEmptyMask" /> method. This method always returns mask with proper dimensions and pixel format. Initially this mask is fully transparent (filled with black pixels). You should draw necessary non-transparent areas yourself.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (which remains unchanged) using specified mask.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap ("in-place").</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <overloads><summary>Transforms given bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged).</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData)">
            <summary>Transforms given bitmap data ("in-place").</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> which should be transformed. Result of the transform will be saved to the same bitmap data (in other word, transform is applied "in-place").</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (<see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance). The bitmap data remains unchanged.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.#ctor(Aurigma.GraphicsMill.BitmapChange)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.OnThreadStopping(System.Exception)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform.SetDestinationData(System.IntPtr)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransformProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Matrix" draft="yes">
            <summary>This class represents a 3x3 matrix.</summary>
            <remarks><para>3x3 matrix is used to apply geometry transformation of the bitmap. Geometry transformation can be both affine (such as scale, skew or rotate) and projective (such as perspective correction).</para><para>You can create this class instance in two ways: either create <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.#ctor">new matrix</see> and then fill it using <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> property, or generate it from points representing affine or projective transformation (see <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> and <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> methods for more details).  </para><para>This class also implements some matrix algebraic operations, such as matrix inversion (<see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Invert" /> method), multiplication (<see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix)" /> method), determinant calculation (<see cref="P:Aurigma.GraphicsMill.Transforms.Matrix.Determinant" /> property). Also, you can apply affine operations at the matrix: rotate (<see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single)" /> and <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)" /> methods), scale (<see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single)" /> method), and translate (<see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single)" /> method).  </para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Clone">
            <summary>Creates a full copy of this <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> object.</summary>
            <returns><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> object containing full copy of the current object.</returns>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Matrix.Determinant">
            <summary>Gets a determinant of the matrix.</summary>
            <value>A determinant of the matrix.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Matrix.Elements">
            <summary>Gets a reference to the array which stores the matrix elements.</summary>
            <value>A reference to the array which stores the matrix elements.</value>
            <remarks><para>This array stores 9 elements - the first triple represents the first row, the second triple - the second row, and the third triple is the third row. </para><note>This property returns a reference to the array rather than a copy. It means that if you modify some element in this array, the changes will immediately reflect in the matrix.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> with specified object.</summary>
            <param name="object">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />, exception will be raised.</param>
            <returns>Value that specifies whether given object represents the same matrix as this <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another.</summary>
            <param name="sourcePoints">An array of 3 source (input) points to transform from.</param>
            <param name="destinationPoints">An array of 3 destination (output) points to transform source points to.</param>
            <remarks>You can also create a matrix of the affine transform which converts one set of points to another one using a static method <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])" />.</remarks>
            <overloads><summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromAffinePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another.</summary>
            <param name="sourcePoint0">The first input source (input) point to transform from.</param>
            <param name="sourcePoint1">The second input source (input) point to transform from.</param>
            <param name="sourcePoint2">The third input source (input) point to transform from.</param>
            <param name="destinationPoint0">The first input destination (output) point to transform to. It corresponds to the <i>sourcePoint0</i> point.</param>
            <param name="destinationPoint1">The second input destination (output) point to transform to. It corresponds to the <i>sourcePoint1</i> point.</param>
            <param name="destinationPoint2">The third input destination (output) point to transform to. It corresponds to the <i>sourcePoint2</i> point.</param>
            <remarks>You can also create a matrix of the affine transform which converts one set of points to another one using a static method <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another.</summary>
            <param name="sourcePoints">An array of 4 source (input) points to transform from.</param>
            <param name="destinationPoints">An array of 4 destination (output) points to transform source points to.</param>
            <remarks>You can also create a matrix of the projective transform which converts one set of points to another one using a static method <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])" />.</remarks>
            <overloads><summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another.
</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromProjectivePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Initializes a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another.</summary>
            <param name="sourcePoint0">The first input source (input) point to transform from.</param>
            <param name="sourcePoint1">The second input source (input) point to transform from.</param>
            <param name="sourcePoint2">The third input source (input) point to transform from.</param>
            <param name="sourcePoint3">The fourth input source (input) point to transform from.</param>
            <param name="destinationPoint0">The first input destination (output) point to transform to. It corresponds to the <i>sourcePoint0</i> point.</param>
            <param name="destinationPoint1">The second input destination (output) point to transform to. It corresponds to the <i>sourcePoint1</i> point.</param>
            <param name="destinationPoint2">The third input destination (output) point to transform to. It corresponds to the <i>sourcePoint2</i> point.</param>
            <param name="destinationPoint3">The fourth input destination (output) point to transform to. It corresponds to the <i>sourcePoint3</i> point.</param>
            <remarks>You can also create a matrix of the projective transform which converts one set of points to another one using a static method <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another.</summary>
            <param name="sourcePoints">An array of 3 source (input) points to transform from.</param>
            <param name="destinationPoints">An array of 3 destination (output) points to transform source points to.</param>
            <returns>A <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which represents the matrix of the transform which converts <i>sourcePoints</i> to <i>destinationPoints</i>.</returns>
            <remarks>If you already have an instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class, you can use <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> method (non-static version of this method).</remarks>
            <overloads><summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another. </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the affine transform which converts one set of points to another.</summary>
            <param name="sourcePoint0">The first input source (input) point to transform from.</param>
            <param name="sourcePoint1">The second input source (input) point to transform from.</param>
            <param name="sourcePoint2">The third input source (input) point to transform from.</param>
            <param name="destinationPoint0">The first input destination (output) point to transform to. It corresponds to the <i>sourcePoint0</i> point.</param>
            <param name="destinationPoint1">The second input destination (output) point to transform to. It corresponds to the <i>sourcePoint1</i> point.</param>
            <param name="destinationPoint2">The third input destination (output) point to transform to. It corresponds to the <i>sourcePoint2</i> point.</param>
            <returns>A <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which represents the matrix of the transform which converts <i>sourcePoints</i> to <i>destinationPoints</i>.</returns>
            <remarks>If you already have an instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class, you can use <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromAffinePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" /> method (non-static version of this method).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another.</summary>
            <param name="sourcePoints">An array of 4 source (input) points to transform from.</param>
            <param name="destinationPoints">An array of 4 destination (output) points to transform source points to.</param>
            <returns>A <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which represents the matrix of the transform which converts <i>sourcePoints</i> to <i>destinationPoints</i>.</returns>
            <remarks>If you already have an instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class, you can use <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> method (non-static version of this method).</remarks>
            <overloads><summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another. </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>Returns a <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> of the projective transform which converts one set of points to another.</summary>
            <param name="sourcePoint0">The first input source (input) point to transform from.</param>
            <param name="sourcePoint1">The second input source (input) point to transform from.</param>
            <param name="sourcePoint2">The third input source (input) point to transform from.</param>
            <param name="sourcePoint3">The fourth input source (input) point to transform from.</param>
            <param name="destinationPoint0">The first input destination (output) point to transform to. It corresponds to the <i>sourcePoint0</i> point.</param>
            <param name="destinationPoint1">The second input destination (output) point to transform to. It corresponds to the <i>sourcePoint1</i> point.</param>
            <param name="destinationPoint2">The third input destination (output) point to transform to. It corresponds to the <i>sourcePoint2</i> point.</param>
            <param name="destinationPoint3">The fourth input destination (output) point to transform to. It corresponds to the <i>sourcePoint3</i> point.</param>
            <returns>A <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which represents the matrix of the transform which converts source points to destination points.</returns>
            <remarks>If you already have an instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class, you can use <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FillFromProjectivePoints(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" /> method (non-static version of this method).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Invert">
            <summary>Inverts the matrix.</summary>
            <remarks><para>The matrix cannot be inverted when its determinant is 0 (i.e. the matrix is singular). This method will throw an exception in this case. </para><para>To check whether the matrix can be inverted, you can use the <see cref="P:Aurigma.GraphicsMill.Transforms.Matrix.IsInvertible" /> property.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Matrix.IsIdentity">
            <summary>Gets a value that specifies whether this instance is an identify matrix.</summary>
            <value><b>true</b> when this instance represents an identify matrix (see remarks for more details), <b>false</b> otherwise.</value>
            <remarks><para>Identifty matrix is a matrix which has a following structure: all elements of the main diagonal (i.e. A[0,0], A[1,1], and A[2,2]) are equal to 1, all other elements are equal to 0.</para><para>This kind of matrix is very important in the linear algebra. It has the following characteristics: when you multiply any other matrix or a vector by an identify matrix, the result is the same as an input matrix or vector. In other words, it represents a neutral element for an operation of matrix multiplication.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Matrix.IsInvertible">
            <summary>Gets a value that specifies whether the matrix can be inverted.</summary>
            <value>A value that is <b>true</b> when the matrix can be inverted, <b>false</b> otherwise.</value>
            <remarks>The matrix cannot be inverted when it is singular, i.e. its determinant is 0. Therefore you can just check the <see cref="P:Aurigma.GraphicsMill.Transforms.Matrix.Determinant" /> property instead of this one.</remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Transforms.Matrix.Determinant" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Invert" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix)">
            <summary>Multiplies two matrices.</summary>
            <param name="matrix">The matrix you multiply by.</param>
            <remarks><para>Note, matrix multiplication is not commutative. It means that the result depends on the order of the matrix. In other words, if A and B are two matrices, the matrix A*B is not equal to the matrix B*A. </para><para>This overload prepends the <i>matrix</i> argument (i.e. left-sided multiplication is applied). If you need to apply right-sided multiplication, you should use the <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix,System.Drawing.Drawing2D.MatrixOrder)">overloaded version</see> of this method which enables you to specify the side you multiply from. </para></remarks>
            <overloads><summary>Multiplies two matrices.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix,System.Drawing.Drawing2D.MatrixOrder)">
            <summary>Multiplies two matrices.</summary>
            <param name="matrix">The matrix you multiply by.</param>
            <param name="order">An order of the matrices in the multiplication operation.</param>
            <remarks><para>Note, matrix multiplication is not commutative. It means that the result depends on the order of the matrix. In other words, if A and B are two matrices, the matrix A*B is not equal to the matrix B*A. That's why you should use the <i>order</i> argument to specify the matrix order. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.#ctor">
            <summary>Creates a new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> object.</summary>
            <remarks><para>When you use this constructor, the identify matrix is created. The identify matrix has the following structure: all elements at the main diagonal are equal to 1. All other elements are equal to 0. To check whether the current instance of this class is an identify matrix, use the <see cref="P:Aurigma.GraphicsMill.Transforms.Matrix.IsIdentity" /> property.</para><para>You can also create a matrix from the points which specify input and output quadrangles. Use <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromAffinePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> and <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.FromProjectivePoints(System.Drawing.PointF[],System.Drawing.PointF[])" /> static methods for this.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.op_Implicit(Aurigma.GraphicsMill.Transforms.Matrix)~System.Drawing.Drawing2D.Matrix" draft="yes">
            <summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> to <see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see>.</summary>
            <param name="matrix"><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> instance to cast.</param>
            <returns>Matrix casted to <see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see>.</returns>
            <remarks><para><see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> is intended only for affine transforms, and it has only 6 elements (2 columns x 3 rows). <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> supports also projective transforms, and has 9 elements (3 columns x 3 rows). When conversion is applied, the last column is discarded (since it is not supported by GDI+ matrix). So if you are converting matrix of the projective transform, you will get another result with GDI+ matrix. </para></remarks>
            <overloads><summary>Casts an instance of <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> to <see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> or vice versa.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.op_Implicit(System.Drawing.Drawing2D.Matrix)~Aurigma.GraphicsMill.Transforms.Matrix">
            <summary>Casts an instance of <see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> to <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see>.</summary>
            <param name="matrix"><see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> value which is being casted.</param>
            <returns>Matrix casted to <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> class.</returns>
            <remarks><para><see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> is intended only for affine transforms, and it has only 6 elements (2 columns x 3 rows). <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> supports also projective transforms, and has 9 elements (3 columns x 3 rows). When conversion is applied, last column (which is absent in GDI+ matrix) is filled with a vector (0, 0, 1). </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Reset">
            <summary>Resets matrix elements to values which correspond the identify matrix.</summary>
            <remarks><para>Identifty matrix is a matrix which has a following structure: all elements of the main diagonal (i.e. A[0,0], A[1,1], and A[2,2]) are equal to 1, all other elements are equal to 0.</para><para>This kind of matrix is very important in the linear algebra. It has the following characteristics: when you multiply any other matrix or a vector by an identify matrix, the result is the same as an input matrix or vector. In other words, it represents a neutral element for an operation of matrix multiplication.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single)">
            <summary>Applies a rotate affine transform to the matrix.</summary>
            <param name="angle">The angle of the rotation (in degrees).</param>
            <remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para><para>Internally the rotation is applied by multiplying this instance of the matrix by the affine matrix of rotation. Left-sided multiplication is made. If you need to make right-sided multiplication, you can use an <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single,System.Drawing.Drawing2D.MatrixOrder)">overloaded version</see> of this method which enables to specify a matrix order.</para><para>The rotation is applied around the point of origin. To rotate around an arbitrary point, use the <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)" /> method.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single)" />
            <overloads><summary>Applies rotate affine transform to the matrix.</summary><remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para><para>The rotation is applied around the point of origin. To rotate around an arbitrary point, use the <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)" /> method.</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single,System.Drawing.Drawing2D.MatrixOrder)">
            <summary>Applies a rotate affine transform to the matrix.</summary>
            <param name="angle">The angle of the rotation (in degrees).</param>
            <param name="order">The order of the matrices in the multiplication operation.</param>
            <remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para><para>The rotation is applied around the point of origin. To rotate around an arbitrary point, use the <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)" /> method.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF)">
            <summary>Applies a rotate affine transform to the matrix around the specified point.</summary>
            <param name="angle">The angle of the rotation (in degrees).</param>
            <param name="point">The point which is used as a center of the rotation.</param>
            <remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para><para>Internally the rotation is applied by multiplying this instance of the matrix by the affine matrix of rotation. Left-sided multiplication is made. If you need to make right-sided multiplication, you can use an <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF,System.Drawing.Drawing2D.MatrixOrder)">overloaded version</see> of this method which enables to specify a matrix order.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single)" />
            <overloads><summary>Applies rotate affine transform to the matrix around the specified point.</summary><remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.RotateAt(System.Single,System.Drawing.PointF,System.Drawing.Drawing2D.MatrixOrder)">
            <summary>Applies a rotate affine transform to the matrix around the specified point.</summary>
            <param name="angle">The angle of the rotation (in degrees).</param>
            <param name="point">The point which is used as a center of the rotation.</param>
            <param name="order">The order of the matrices in the multiplication operation.</param>
            <remarks><para>The clockwise rotation is applied. Use negative angle value to rotate counter-clockwise.</para></remarks>
            <seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Multiply(Aurigma.GraphicsMill.Transforms.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Rotate(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
<seealso cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single)">
            <summary>Applies a scale affine transform to the matrix.</summary>
            <param name="scaleX">The value to scale the matrix horizontally.</param>
            <param name="scaleY">The value to scale the matrix vertically.</param>
            <remarks><para>Internally the scaling is applied by multiplying this instance of the matrix by the affine matrix of scale. Left-sided multiplication is made. If you need to make right-sided multiplication, you can use an <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)">overloaded version</see> of this method which enables to specify a matrix order.</para></remarks>
            <overloads><summary>Applies a scale affine transform to the matrix.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Scale(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)">
            <summary>Applies a scale affine transform to the matrix.</summary>
            <param name="scaleX">The value to scale the matrix horizontally.</param>
            <param name="scaleY">The value to scale the matrix vertically.</param>
            <param name="order">The order of the matrices in the multiplication operation.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.ToGdiplusMatrix">
            <summary>Returns a matrix converted to <see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see>.</summary>
            <returns><see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> class instance.</returns>
            <remarks><para><see cref="T:System.Drawing.Drawing2D.Matrix">System.Drawing.Drawing2D.Matrix</see> is intended only for affine transforms, and it has only 6 elements (2 columns x 3 rows). <see cref="T:Aurigma.GraphicsMill.Transforms.Matrix">Aurigma.GraphicsMill.Transforms.Matrix</see> supports also projective transforms, and has 9 elements (3 columns x 3 rows). When conversion is applied, the last column is discarded (since it is not supported by GDI+ matrix). So if you are converting matrix of the projective transform, you will get another result with GDI+ matrix. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.TransformPoints(System.Drawing.PointF[])">
            <summary>Applies a linear transform to specified set of points.</summary>
            <param name="points">A set of points to transform. <note>The method modifies points in this array. If you need to keep original values, you should pass  a copy of this array to this method.</note></param>
            <remarks><para><see cref="T:System.Drawing.PointF" /> represents a two-dimensional vector. At the same time, the rank of this matrix is 3. That's why during conversion, algorithm adds third component of this vector (which equals to 1), and then discard it when putting transformed points back to the array. </para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single)">
            <summary>Applies a translate affine transform to the matrix.</summary>
            <param name="offsetX">The value to move the matrix horizontally.</param>
            <param name="offsetY">The value to move the matrix vertically.</param>
            <remarks><para>Internally the scaling is applied by multiplying this instance of the matrix by the affine matrix of translation. Left-sided multiplication is made. If you need to make right-sided multiplication, you can use an <see cref="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)">overloaded version</see> of this method which enables to specify a matrix order.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Matrix.Translate(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)">
            <summary>Applies a translate affine transform to the matrix.</summary>
            <param name="offsetX">The value to move the matrix horizontally.</param>
            <param name="offsetY">The value to move the matrix vertically.</param>
            <param name="order">The order of the matrices in the multiplication operation.</param>
            <overloads><summary>Applies a translate affine transform to the matrix.</summary></overloads>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.MaximumFilter">
            <summary>This class enables you to apply maximum filter (also known as erosion).</summary>
            <remarks>Maximum filter is a non-linear filter which works in the following way: for each pixel it searches pixel with maximum brightness in "running window" of the radius specified with <see cref="P:Aurigma.GraphicsMill.Transforms.MaximumFilter.Radius" /> property. This pixel is copied to the result bitmap. 
<para>
That's why if you apply this filter on the image with has black objects on white background (for example text), they will be <i>erosed</i>.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaximumFilter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaximumFilter.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaximumFilter.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MaximumFilter.#ctor(System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" /> class instance. You can specify filter radius here.</summary>
            <param name="radius">Radius of the filter (in pixels). Can be any positive integer value. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.MaximumFilter.Radius" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.MaximumFilter.Radius">
            <summary>Gets/sets a radius of maximum filter.</summary>
            <value>Radius of the filter (in pixels). Can be any positive integer value.</value>
            <remarks>This property specifies how much neighbour pixels will be processed (for radius = 1 it will take 8 neighbours, for radius = 2 it will use already 24 neighbour pixels, etc). That's why the larger radius you specify, the slower algorithm will work. It is recommended to limit user input for this parameter to avoid performance drop.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.MedianFilter">
            <summary>This class enables you to apply median filter.</summary>
            <remarks>Median filter is a non-linear filter which works in the following way: for each pixel it searches median pixel in "running window" of the radius specified with <see cref="P:Aurigma.GraphicsMill.Transforms.MedianFilter.Radius" /> property. This pixel is copied to the result bitmap. 
<para>
This filter is good for removing noise (especially impulse noise).
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MedianFilter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MedianFilter.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MedianFilter.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MedianFilter.#ctor(System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" /> class instance. You can specify filter radius here.</summary>
            <param name="radius">Radius of the filter (in pixels). Can be any positive integer value. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.MedianFilter.Radius" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.MedianFilter.Radius">
            <summary>Gets/sets a radius of median filter.</summary>
            <value>Radius of the filter (in pixels). Can be any positive integer value.</value>
            <remarks>This property specifies how much neighbour pixels will be processed (for radius = 1 it will take 8 neighbours, for radius = 2 it will use already 24 neighbour pixels, etc). That's why the larger radius you specify, the slower algorithm will work. It is recommended to limit user input for this parameter to avoid performance drop.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.MinimumFilter">
            <summary>This class enables you to apply minimum filter (also known as dilation).</summary>
            <remarks>Minimum filter is a non-linear filter which works in the following way: for each pixel it searches pixel with minimum brightness in "running window" of the radius specified with <see cref="P:Aurigma.GraphicsMill.Transforms.MinimumFilter.Radius" /> property. This pixel is copied to the result bitmap. 
<para>
That's why if you apply this filter on the image with has black objects on white background (for example text), they will be <i>dilated</i>.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MinimumFilter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MinimumFilter.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MinimumFilter.#ctor" draft="yes">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" /> class instance.</summary>
            <overloads><summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.MinimumFilter.#ctor(System.Int32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" /> class instance. You can specify filter radius here.</summary>
            <param name="radius">Radius of the filter (in pixels). Can be any positive integer value. You can later access this value through property <see cref="P:Aurigma.GraphicsMill.Transforms.MinimumFilter.Radius" />.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.MinimumFilter.Radius">
            <summary>Gets/sets a radius of minimum filter.</summary>
            <value>Radius of the filter (in pixels). Can be any positive integer value.</value>
            <remarks>This property specifies how much neighbour pixels will be processed (for radius = 1 it will take 8 neighbours, for radius = 2 it will use already 24 neighbour pixels, etc). That's why the larger radius you specify, the slower algorithm will work. It is recommended to limit user input for this parameter to avoid performance drop.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Mosaic">
            <summary>This class enables you to apply mosaic effect on the image.</summary>
            <remarks><para>
This effect lies in averaging a block of pixels of specified size. You specify <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight" />, and the image is "pixelated" according this cell size.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight">
            <summary>Gets/sets mosaic cell height.</summary>
            <value>Mosaic cell height.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth">
            <summary>Gets/sets mosaic cell width.</summary>
            <value>Mosaic cell width.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance. Mosaic cell size is specified here.</summary>
            <param name="cellWidth">Mosaic cell width. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth" /> property.</param>
            <param name="cellHeight">Mosaic cell height. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.#ctor(System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance. Mosaic cell size is specified here.</summary>
            <param name="cellWidth">Mosaic cell width. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth" /> property.</param>
            <param name="cellHeight">Mosaic cell height. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.#ctor(System.Drawing.Size)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance. Mosaic cell size is specified here.</summary>
            <param name="cellSize">Mosaic sell size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Mosaic.#ctor(System.Drawing.SizeF)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class instance. Mosaic cell size is specified here.</summary>
            <param name="cellSize">Mosaic sell size. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellWidth" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Mosaic.CellHeight" /> property.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Orientation">
            <summary>Contains possible orientations for some artistic effects.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Orientation.Horizontal">
            <summary>Horizontal orientation.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.Orientation.Vertical">
            <summary>Vertical orientation.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.PageCurl">
            <summary>This class enables you to apply effect of curled page on the bitmap.</summary>
            <remarks><para>
You can specify a corner to curl (with <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner" /> property) and its <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" />. To manipulate curl size, you can specify <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> of the corner to curl. You can also specify color of the "paper" back (<see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property) and color under the "paper" (<see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property).
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor">
            <summary>Gets/sets background color of the curled image (in other words, if imagine that the bitmap is a piece of paper, this property specifies a color under this paper).</summary>
            <value>Value specifying background color for the curled image.</value>
            <remarks>Background color is transparent white.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner">
            <summary>Gets/sets a curl corner.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl.</value>
            <remarks><para>
Only "corner" directions are accepted. This way you can specify only these values:
</para><list type="bullet"><item><description><see cref="F:Aurigma.GraphicsMill.Transforms.Direction.DownLeft" />;</description><description><see cref="F:Aurigma.GraphicsMill.Transforms.Direction.DownRight" />;</description><description><see cref="F:Aurigma.GraphicsMill.Transforms.Direction.UpLeft" />;</description><description><see cref="F:Aurigma.GraphicsMill.Transforms.Direction.UpRight" />.</description></item></list><para>
Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.Direction.DownRight" />.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor">
            <summary>Gets/sets curl color (in other words, if imagine that the bitmap is a piece of paper, this property specifies a back this paper).</summary>
            <value>Value specifying a curl color.</value>
            <remarks>Background color is opaque white.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height">
            <summary>Gets/sets a height of the image corner to curl.</summary>
            <value>Height of the image corner to curl.</value>
            <remarks>Default value is 100.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set curl width and height here.</summary>
            <param name="width">Width of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> property.</param>
            <param name="height">Height of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set all curl parameters here.</summary>
            <param name="width">Width of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> property.</param>
            <param name="height">Height of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> property.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner" /> property.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Single,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set curl width and height here.</summary>
            <param name="width">Width of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> property.</param>
            <param name="height">Height of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set all curl parameters here.</summary>
            <param name="width">Width of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> property.</param>
            <param name="height">Height of the image corner to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> property.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner" /> property.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Drawing.Size)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set curl width and height here.</summary>
            <param name="size">Size of the image corner to curl. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> properties.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set all curl parameters here.</summary>
            <param name="size">Size of the image corner to curl. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> properties.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner" /> property.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Drawing.SizeF)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set curl width and height here.</summary>
            <param name="size">Size of the image corner to curl. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> properties.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.#ctor(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class instance. You can set all curl parameters here.</summary>
            <param name="size">Size of the image corner to curl. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Height" /> properties.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Corner" /> property.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation">
            <summary>Gets/sets orientation of the curl.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.Orientation.Horizontal" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PageCurl.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PageCurl.Width">
            <summary>Gets/sets a width of the image corner to curl.</summary>
            <value>Width of the image corner to curl.</value>
            <remarks>Default value is 100.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform" draft="yes">
            <summary>This is a base class for all transforms which can be applied on separate channels.</summary>
            <remarks><para>Main feature of this class (and its descendants) is possibility to specify what channels should be modified with the transform. To do it you should use <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" />property. This property retrieves an array of boolean values. To mark a channel (or channels) which should be affected by the transform, set entry with appropriate index to <b>true</b>. If you set it to <b>false</b>, appropriate channel in not affected. For example, you apply transform on 24-bit RGB image. This way it has three channels, blue (at index 0), green (at index 1), and red (at index 2). Now let's assume you want to modify red and green channels, and leave blue channel as is. You should pass an array which contains three boolean values, first one should be <b>false</b>, and the rest of them should be <b>true</b>:</para><code>
transform.Channels(0) = False  ' blue channel unchanged
transform.Channels(1) = True   ' green channel should be modified
transform.Channels(2) = True   ' red channel should be modified
</code><code>
transform.Channels[0] = false;  // blue channel unchanged
transform.Channels[1] = true;   // green channel should be modified
transform.Channels[2] = true;   // red channel should be modified
</code><para>By default all channels are selected. Using methods <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.SelectAllChannels" /> or <see cref="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.DeselectAllChannels" /> you can select or deselect all channels.</para><para>This class is inherited from <see cref="T:Aurigma.GraphicsMill.Transforms.MaskedBitmapTransform" />, so it supports all the features provided with this class (true in-place applying support, using masks).</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap "in-place" using specified mask.</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <remarks>You can create empty mask for the bitmap using <see cref="M:Aurigma.GraphicsMill.Bitmap.GetEmptyMask" /> method. This method always returns mask with proper dimensions and pixel format. Initially this mask is fully transparent (filled with black pixels). You should draw necessary non-transparent areas yourself.</remarks>
            <overloads><summary>Transforms given bitmap using specified mask.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged) using specified mask.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap data "in-place" using specified mask.</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> which should be transformed. Result of the transform will be saved to the same bitmap data (in other word, transform is applied "in-place").</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <remarks>You can create empty mask for the bitmap using <see cref="M:Aurigma.GraphicsMill.Bitmap.GetEmptyMask" /> method. This method always returns mask with proper dimensions and pixel format. Initially this mask is fully transparent (filled with black pixels). You should draw necessary non-transparent areas yourself.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyMaskTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (which remains unchanged) using specified mask.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="mask"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which defines mask. Mask should be 8-bit grayscale bitmap (its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />) of the same dimensions as original image.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyOnAlpha">
            <summary>Gets/sets value specifying if to modify alpha channel with the transform.</summary>
            <value>Value specifying if to modify alpha channel with the transform.</value>
            <remarks><para>
This property has higher priority than <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> property. So if it is <b>false</b>, but <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> specifies <b>true</b> for alpha channel, alpha will be intact (and vice versa).
</para><para>
Default value is <b>false</b>.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap)">
            <summary>Transforms given bitmap ("in-place").</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <overloads><summary>Transforms given bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged).</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData)">
            <summary>Transforms given bitmap data ("in-place").</summary>
            <param name="bitmapData"><see cref="T:Aurigma.GraphicsMill.BitmapData" /> which should be transformed. Result of the transform will be saved to the same bitmap data (in other word, transform is applied "in-place").</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ApplyTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (<see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance). The bitmap data remains unchanged.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels">
            <summary>Returns an array of flags specifying what channels to apply effect at.</summary>
            <value>Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</value>
            <remarks>When the object is created, this array is created with fixed number of items (maximum possible number of channels). You can get it with <see cref="P:System.Array.Length" /> property of the <see cref="T:System.Array" />. All entries values are equal to <b>true</b>.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.DeselectAllChannels">
            <summary>Resets all <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> array entries to <b>false</b>.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ExportChannelsSettings">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.#ctor(Aurigma.GraphicsMill.BitmapChange)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.#ctor(Aurigma.GraphicsMill.BitmapChange,System.Boolean[])">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.#ctor(System.Boolean[])">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.SelectAllChannels">
            <summary>Sets all <see cref="P:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.Channels" /> array entries to <b>true</b>.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransform.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.PerChannelBitmapTransformProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter">
            <summary>This class enables you to convert a bitmap from one pixel format to another one.</summary>
            <remarks><para>
Using this class you can modify pixel format of the bitmap. To specify new pixel format use property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" />. Pixel formats can be divided into two big groups - indexed and continuous ones. These groups has different set of settings.
</para><para>
Indexed pixel formats are defined in the following way: colors are stores in a special table called <i>palette</i>. Pixels in such images are indexes in the palette (pointing this way to the necessary color). When bit depth of this pixel format is 1 bpp (bits per pixel), the palette can contain only 2 colors, 4 bpp - 16 colors, and 8 bpp - 256 colors. When you convert the image to indexed pixel format, you should specify how to produce the palette. You can do it using <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteType" /> property. You also may need to specify a number of entries in the palette (the less colors number the image has, the better compression characteristics does it have).</para><para> 
Number of colors in the palette are closely concerned with another block of settings. When we reducing number of colors (for example, when we convert from 24 bpp image to 8 bpp, we convert 16 millions of colors to 256 ones), the colors are usually noticeable distorted. Multiple hues (halftones) of some color are converted to single colors, gradients are turned into areas filled with solid color. To decrease this effect, special technique called <i>dithering</i> is used. The idea is to emulate halftones by spreading pixels of the palette with different density. Human eye perceives it as a new color. There are multiple dithering algorithms are available. You can select one of them with <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Dithering" /> property. You can also specify dithering intensity with <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DitheringIntensity" /> property.
</para><para>
Continuous pixel formats are organized in another way. Pixels are constructed from one or more color channels. Each color channel contains a value that specifies this channel luminosity. A set of color channels depends on the image <i>color space</i>. Currently Graphics Mill for .NET supports such color spaces as RGB, CMYK, and grayscale. Conversion between color spaces is not unambiguous, and that's why colors may get distorted during conversion. To resolve this problem, color management is used. Color management is performed with a help of <i>color profiles</i>. Two color profiles should be defined - input profile and output profile. Input profile is always taken from the source bitmap (<see cref="P:Aurigma.GraphicsMill.Bitmap.ColorProfile" /> property of the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class), output profile is set for each target color space via <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile" /> correspondingly. You can also specify so-called <i>rendering intent</i> using <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TransformationIntent" /> property. Rendering intent allows to tell the algorithm what color parameters are most important to you and what one can be discarded. If you do not care about color transformation precision and prefer higher speed, you can disable color management (set the <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />).
</para><para>
Another nuance you should keep in mind is handling the situation when source pixel format had alpha channel, but the destination one - has not and vice versa. The table below describes how this problem is resolved with this class.
</para><list type="table"><listheader><term>Has Alpha</term><term> How to Resolve</term></listheader><item><description>Both <b>source</b> and <b>destination</b>.</description><description>No specific action should be performed.</description></item><item><description>Only <b>source</b>.</description><description>As destination pixel format has no alpha channel, we should remove alpha information from the source bitmap. We can either discard alpha channel, or emulate it by blending the source bitmap with some background color. If property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundEnabled" /> is set to <b>true</b>, the algorithm blends the source image with the color specified with <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundColor" /> property. Otherwise alpha channel is just ignored.</description></item><item><description>Only <b>destination</b>.</description><description>In case when source bitmap does not have alpha channel information, but we need to add it during conversion, the only thing we should know is an initial value for the alpha channel. It is specified with <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Opacity" /> property. </description></item><item><description>Neither source nor destination. </description><description>No specific action should be performed.</description></item></list></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ApplyTransform(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Transforms given bitmap ("in-place").</summary>
            <param name="bitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be transformed. Result of the transform will be saved to the same bitmap (in other word, transform is applied "in-place").</param>
            <overloads><summary>Transforms given bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ApplyTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces transformed copy of given bitmap (which remains unchanged).</summary>
            <param name="srcBitmap">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the transform algorithm.</param>
            <param name="destBitmap">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ApplyTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)">
            <summary>Produces bitmap which contains transformed copy of given bitmap data (<see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance). The bitmap data remains unchanged.</summary>
            <param name="srcBitmapData">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the transform algorithm.</param>
            <param name="destBitmap">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After transform algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundColor">
            <summary>Gets/sets a background color used when alpha channel is flatten.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying a background color.</value>
            <remarks><para>
This property makes sense only when you convert from pixel format which supports alpha channel to pixel format which does not. If you do not want to flatten alpha in such cases, and just want to discard it without re-calculating of the color channels, you should set property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundEnabled" /> to <b>false</b>.
</para><para>
Default value is white color.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundEnabled">
            <summary>Gets/sets value that specifies if it is necessary to use <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundColor" /> value to flatten alpha channel when converting from pixel format with alpha to pixel format without it.</summary>
            <value>Value that specifies if it is necessary to use <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BackgroundColor" /> value to flatten alpha channel.</value>
            <remarks>Default value is <b>false</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BuildAdaptivePaletteWithAlpha">
            <summary>Gets/sets a value which specifies whether the alpha channel should be taken into account when building an adaptive palette.</summary>
            <value>Value which specifies whether the alpha channel should be taken into account. If <b>true</b>, alpha channel will be added to the palette if necessary.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile">
            <summary>Gets/sets an output color profile which is used to convert bitmap to CMYK color space.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output CMYK color profile.</value>
            <remarks><para>
This color profile must support CMYK color space. If you try to set profile for another color space, exception will be raised.
</para><para>
  If color management is disabled (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />) color profiles are ignored. Instead of that approximate algorithm will be used to get convert image between color spaces.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" draft="yes">
            <summary>Gets/sets color management engine (module) which will be used during image transformation. Graphics Mill for .NET supports the following engines: LittleCMS and Adobe CMM. The property also allows to disable color management and perform transformation without color matching.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorManagementEngine" /> value specifying color management engine.</value>
            <remarks><para>Color management will be applied during transformation of image between color formats in case if all the following conditions are met:</para><list type="number"><item><description>This property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.LittleCms" /> or
<see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.AdobeCmm" />.</description></item><item><description><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which needs to be transformed has <see cref="P:Aurigma.GraphicsMill.Bitmap.ColorProfile" /> initialized with correct color profile (e.g. it is embedded color profile loaded from image file, or this property was initialized after the image has been loaded).</description></item><item><description>An output color profile is also initialized. Depending on color space use <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" />, or <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile" /> properties. For example, if you need to translate image to CMYK color space, you need to set <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" /> up with appropriate CMYK profile; if destination color space is RGB, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" /> property should be initialized etc.</description></item></list><para>If you do not need to apply color management during image transformation, set this property to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />.</para></remarks>
            <seealso href="ConvertingColorswiththeColorManagement.htm" />
<seealso href="UsingAdobeCMMwithGraphicsMill.htm" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorQuantizationAlgorithm">
            <summary>Gets/sets a color quantiztion algorithm used to reduce colors.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorQuantizationAlgorithm" /> value specifying the quantiztion algorithm used during color reduction.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertArray(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat)">
            <summary>Converts several colors into another pixel format. These colors are represented by array. Color management is not applied.</summary>
            <param name="array"><para>Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. Array with this format is returned from <see cref="M:Aurigma.GraphicsMill.Bitmap.Export" /> method of <see cref="T:Aurigma.GraphicsMill.Bitmap" /> and <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</para><note type="caution">Array channel number (third dimension) must conform pixel format specified by <i>format</i> argument.</note></param>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that describes pixel format for the pixels in the specified array.</param>
            <returns>An array of integers in the same format as input <i>array</i>. Pixel format that describes an order of channels is stored at <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</returns>
            <remarks><para>The destination pixel format is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</para><para>If you need to apply color management during conversion, you should use <see cref="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertArray(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorProfile)">an overload which takes a color profile as an argument</see>. </para></remarks>
            <overloads><summary>Converts several colors into another color space. These colors are represented by array.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertArray(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorPalette)">
            <summary>Converts several colors into another pixel format. These colors are represented by array. Here you can pass a palette for converting colors to indexed format. Color management is not applied.</summary>
            <param name="array"><para>Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. Array with this format is returned from <see cref="M:Aurigma.GraphicsMill.Bitmap.Export" /> method of <see cref="T:Aurigma.GraphicsMill.Bitmap" /> and <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</para><note type="caution">Array channel number (third dimension) must conform pixel format specified by <i>format</i> argument.</note></param>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that describes pixel format for the pixels in the specified array.</param>
            <param name="palette"><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance that is used for conversion into indexe pixel format.</param>
            <returns>An array of integers in the same format as input <i>array</i>. Pixel format that describes an order of channels is stored at <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</returns>
            <remarks><para>The destination pixel format is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertArray(System.Int32[0:,0:,0:],Aurigma.GraphicsMill.PixelFormat,Aurigma.GraphicsMill.ColorProfile)">
            <summary>Converts several colors into another pixel format. These colors are represented by array. Color management is applied.</summary>
            <param name="array"><para>Array of image pixels should have the following format: first dimension is bitmap columns, second dimension is a bitmap rows, third dimension is a pixels channels. Array with this format is returned from <see cref="M:Aurigma.GraphicsMill.Bitmap.Export" /> method of <see cref="T:Aurigma.GraphicsMill.Bitmap" /> and <see cref="T:Aurigma.GraphicsMill.BitmapData" />.</para><note type="caution">Array channel number (third dimension) must conform pixel format specified by <i>format</i> argument.</note></param>
            <param name="format"><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that describes pixel format for the pixels in the specified array.</param>
            <param name="profile"><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance that is used as an input profile.</param>
            <returns>An array of integers in the same format as input <i>array</i>. Pixel format that describes an order of channels is stored at <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</returns>
            <remarks><para>The destination pixel format is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property.</para><para>During conversion with this method, the color management will be applied. Argument <i>profile</i> will be used as an input profile, output profiles are specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile" /> properties. Property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TargetColorProfile" /> will be used as well.</para><note>If output profile is not specified or <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />, color management is disabled.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color)">
            <summary>Converts <see cref="T:Aurigma.GraphicsMill.Color" /> value into another color space. Color management is not applied.</summary>
            <param name="color"><see cref="T:Aurigma.GraphicsMill.Color" /> to convert to another color space.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Color" /> converted to another color space.</returns>
            <remarks><para>The destination color space is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property. The color space of this pixel format is a destination color space. </para><para>If you want to apply color management during conversion of this color, use <see cref="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.ColorProfile)">an overload which takes a color profile as a parameter</see>. This profile will be used as an input profile, output profiles are specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile" /> properties. Property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TargetColorProfile" /> will be used as well.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ConvertColor(Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.ColorProfile)">
            <summary>Converts <see cref="T:Aurigma.GraphicsMill.Color" /> value into another color space. Color management is applied.</summary>
            <param name="color"><see cref="T:Aurigma.GraphicsMill.Color" /> to convert to another color space.</param>
            <param name="profile"><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance that is used as an input profile.</param>
            <returns><see cref="T:Aurigma.GraphicsMill.Color" /> converted to another color space.</returns>
            <remarks><para>The destination color space is specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> property. The color space of this pixel format is a destination color space. </para><para>During conversion with this method, the color management will be applied. Argument <i>profile</i> will be used as an input profile, output profiles are specified by <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CmykColorProfile" />, <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile" /> properties. Property <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TargetColorProfile" /> will be used as well.</para><note>
                If output profile is not specified or <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />, color management is disabled.
              </note></remarks>
            <overloads><summary>
                Converts <see cref="T:Aurigma.GraphicsMill.Color" /> value into another color space.
              </summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CustomPalette">
            <summary>Gets/sets a custom palette used during conversion to indexed pixel formats.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPalette" /> class instance specifying custom palette used when <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> is one of indexed formats and <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteType" /> is <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Custom" />.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat">
            <summary>Gets/sets a destination pixel format.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.PixelFormat" /> value that specifies pixel format to convert bitmap to.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Dithering">
            <summary>Gets/sets dithering algorithm used when performing conversion to indexed pixel format.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.DitheringType" /> value that specifies dithering algorithm used when <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> is an indexed one.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.DitheringType.FloydSteinberg" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DitheringIntensity">
            <summary>Gets/sets dithering intensity used when performing conversion to indexed pixel format.</summary>
            <value>Value in range [0, 1] specifying dithering intensity.</value>
            <remarks><para>
Small values of dithering intensity makes dithering less visible (if it is 0, the result is the same as for <see cref="F:Aurigma.GraphicsMill.Transforms.DitheringType.None" /> dithering type).
</para><para>
Default value is 1.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.GrayScaleColorProfile">
            <summary>Gets/sets an output color profile which is used to convert bitmap to grayscale color space.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output grayscale color profile.</value>
            <remarks><para>
This color profile must support grayscale color space. If you try to set profile for another color space, exception will be raised.
</para><para>
If color management is disabled (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />) color profiles are ignored. Instead of that approximate algorithm will be used to get convert image between color spaces.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.PixelFormatConverter" /> class instance.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.Opacity">
            <summary>Gets/sets a value which will initialize alpha channel when converting from pixel format which does not support alpha to pixel format which does.</summary>
            <value>A number in range [0, 1] specifying total opacity of the image. If 0, image is completely transparent, if 1, image is completely opaque.</value>
            <remarks>Default value is 1.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteAlphaThreshold">
            <summary>Gets/sets a value which specifies the alpha threshold.</summary>
            <value>Threshold value.</value>
            <remarks><para>When building a palette during color reduction for an image which should be saved to GIF, you need to have only one transparent color. However during color reduction you may get a number of colors with a different level of transparency. To avoid this, use this property. All alpha channel values which are greater or equal to this value will be changed to 255 (fully opaque), otherwise it will be 0.
</para><note>If the <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteAlphaThresholdUsed" /> property is <b>false</b>, alpha threshold is not used, and therefore the palette may contain more than one transparent or semitransparent entry. Also, this value is disregarded if the <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BuildAdaptivePaletteWithAlpha" /> property is set to <b>false</b> (i.e. alpha channel is ignored during color reduction).</note></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteAlphaThresholdUsed">
            <summary>Gets/sets a value which specifies whether the alpha threshold should be used when building an adaptive palette.</summary>
            <value>Value which specifies whether to apply alpha channel threshold.</value>
            <remarks><para>If the value of this property is <b>true</b>, and the value of the <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.BuildAdaptivePaletteWithAlpha" /> property is also <b>true</b>, then all alpha channel values will come to 0 or 255 depending on the <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteAlphaThreshold" /> property value.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteEntryCount">
            <summary>Gets/sets the maximum number of colors in palette that should be used when performing conversion to an indexed pixel format.</summary>
            <value>A value that specifies the maximum number of entries in palette used when performing conversion to an indexed pixel format. If this value is 0, the algorithm automatically uses the maximum possible value for the target pixel format (see the <b>Remarks</b> section).</value>
            <remarks><para>When <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppIndexed" />, this value should be equal or less 256. For the <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format4bppIndexed" /> pixel format, 16 or less colors can be used. For <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format1bppIndexed" />, only 2 colors can be specified.</para><para>If you specify more colors than the palette supports, an exception will be raised.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.PaletteType">
            <summary>Gets/sets a value that specifies a palette used when performing conversion to indexed pixel format.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> value that specifies a palette to use when <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.DestinationPixelFormat" /> is indexed.</value>
            <remarks><para>
              The table below classifies palette types supported by Graphics Mill for .NET.
            </para><list type="table"><listheader><term>Palette kind</term><description>Description</description></listheader><item><term>Predefined palettes</term><description>
              These palettes always have fixed values. If you specify entries count less than these palettes support, algorithm will automatically select the most frequent colors from these palettes. Graphics Mill for .NET supports several predefined palettes represented with the following <see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> enumeration members: <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.WebSafe" />, <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Windows" />, <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Mac" />, <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.GrayScale" />, and <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Bicolor" /> (black-and-white palette for 1-bit images). </description></item><item><term>Adaptive palette</term><description>Colors of the adaptive palette are fully dependent from the image which is being converted. Algorithm searches for most frequent colors in the source images and builds the palette from these colors. This palette type is represented with <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Adaptive" /> member of the <see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> enumeration. </description></item><item><term>Custom palette</term><description>This palette is provided by user. It can be taken from another image, or built manually. You must define it using <see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.CustomPalette" /> property. This palette type is represented with <see cref="F:Aurigma.GraphicsMill.ColorPaletteType.Custom" /> member of the <see cref="T:Aurigma.GraphicsMill.ColorPaletteType" /> enumeration. </description></item></list></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.QuantizationTo8bBitsUsed">
            <summary>Gets/sets the number of bits which are in fact used for this channel.</summary>
            <value>Number of bits used for the channel.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.QuantizationTo8bOffset">
            <summary>Gets/sets the offset on which intensity of a pixel will be calculated.</summary>
            <value>Offset on which intensity of a pixel will be calculated.</value>
            <remarks><para>Any pixel intensity that is below the offset value is set to black. Any pixel intensity that is above <c>(<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bOffset" /> + (2^<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bScale" />))</c> is set to white. All remaining pixels therefore lie within the range 0 to 2^scale.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.QuantizationTo8bScale">
            <summary>Gets/sets the range in which pixel intensity values will vary.</summary>
            <value>Scale which specifies the range of available pixel intensity values.</value>
            <remarks><para>Any pixel intensity that is below the offset value is set to black. Any pixel intensity that is above <c>(<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bOffset" /> + (2^<see cref="P:Aurigma.GraphicsMill.ColorManagementProvider.QuantizationTo8bScale" />))</c> is set to white. All remaining pixels therefore lie within the range 0 to 2^scale.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile">
            <summary>Gets/sets an output color profile which is used to convert bitmap to RGB color space.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying output RGB color profile.</value>
            <remarks><para>
This color profile must support RGB color space. If you try to set profile for another color space, exception will be raised.
</para><para>
  If color management is disabled (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />) color profiles are ignored. Instead of that approximate algorithm will be used to get convert image between color spaces.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TargetColorProfile">
            <summary>Gets/sets target device profile used for chain transformations.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.ColorProfile" /> class instance specifying color profile of the target device.</value>
            <remarks><para>
This profile is used to preview on one device how the image will be looking at another one. For example, let's assume you want to display on the screen how the image will be looking after being printed by specific printer. In this case set:
</para><list type="number"><item><term>Output profile (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.RgbColorProfile" /> property)</term><description>to monitor profile.</description></item><item><term>Target device profile (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TargetColorProfile" /> property)</term><description>to printer profile.</description></item></list><para>If color management is disabled (<see cref="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ColorManagementEngine" /> property is set to <see cref="F:Aurigma.GraphicsMill.Transforms.ColorManagementEngine.None" />) color profiles are ignored. Instead of that approximate algorithm will be used to get convert image between color spaces.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.PixelFormatConverter.TransformationIntent">
            <summary>Gets/sets rendering intent used during color management.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent" /> value specifying required rendering intent.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.ColorTransformationIntent.Perceptual" />.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.RedEyeBlob" draft="yes">
            <summary>This class describes red eye blobs (i.e. areas which correspond to the red eye in the original image).</summary>
            <remarks><para>Red eye blobs objects cannot be created directly. They are returned through the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Blobs" /> property of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeMask" /> class. </para><para>Red eye blob is described by two parameters: <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeBlob.Center" /> point and <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeBlob.BoundingRectangle" /> box. All value are given in coordinates of the red eye mask this blob object is returned from.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeBlob.BoundingRectangle" draft="yes">
            <summary>Gets the bounding rectangle of the red eye blob.</summary>
            <value>A <see cref="T:System.Drawing.Rectangle" /> which stores the bounding box of the red eye blob.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeBlob.Center" draft="yes">
            <summary>Gets the center of the red eye blob.</summary>
            <value>A <see cref="T:System.Drawing.Point" /> value which stores the center of the red eye blob.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.RedEyeMask" draft="yes">
            <summary>This class represents a red eye mask calculated during red eye effect removal.</summary>
            <remarks><para>When the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> transform is working, it builds a mask which contains information about red eyes found in the image. You can get this mask through the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mask" /> property. Of course, you can do it only after the algorithm completes.</para><para>This mask is a common grayscale bitmap where white areas correspond to red eyes and black ones - all the rest. You can get this bitmap using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.BinaryMask" /> property.</para><para>White areas of the mask are called <i>red eye blobs</i>. The add-on finds them and calculates its center and bounding box. You can get blobs of the mask using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Blobs" /> property which returns an array of <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeBlob" /> objects.</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.BinaryMask" draft="yes">
            <summary>Gets the grayscale bitmap which represents the red eye mask.</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which represents a red eye mask.</value>
            <remarks><para>A pixel format of this bitmap is always <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format8bppGrayScale" />. White areas corresponds to portions of the source image which are recognized as red eyes (i.e. <i>red eye blobs</i>). If you need to get coordinates of the red eye blobs, use the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Blobs" /> property. It will return an array of <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeBlob" /> object.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Blobs" draft="yes">
            <summary>Gets an array of red eye blobs found in the mask (i.e. areas which correspond to red eyes).</summary>
            <value>An array of <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeBlob" /> objects which represent an area of image which corresponds to a red eye.</value>
            <remarks><para>Use this property to determine where the algorithm has found the red eyes. This way you can display to the user what portions of image are about to be modified. If the algorithm finds it incorrectly, the user can fix blobs coordinates and proceed with <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Height">
            <summary>Gets the height of the red eye mask.</summary>
            <value>An integer value which specifies the height of the mask. Its dimensions are always the same as the face selection rectangle.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Mask" draft="yes">
            <summary>Gets two-dimensional array of <see cref="T:System.Single" /> values which represents a mask.</summary>
            <value>Two-dimensional array of <see cref="T:System.Single" /> values which represents a mask.</value>
            <remarks><para>To get the same as a bitmap, use the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.BinaryMask" /> value instead.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Width">
            <summary>Gets the width of the red eye mask.</summary>
            <value>An integer value which specifies the width of the mask. Its dimensions are always the same as the face selection rectangle.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" draft="yes">
            <summary>This class represents red eye effect removal transform.</summary>
            <remarks><para>Using this class you can add red eye effect removal into your application. It supports two modes: <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> and <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" />. You specify the mode using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property.</para><para>When you use the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode, the user removes red eyes effect in two steps:   </para><list type="number"><item><description>Select the face of the person whose eyes should be processed. The selection should be specified by the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property.             </description></item><item><description>Specify red eyes coordinates on the selected face (e.g. by mouse click). It is specified by the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.EyePoint" /> property.</description></item></list><para>The <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode also requires the user to select a face. However it automatically searches red eyes on the selected face. When this mode is used, you can get the coordinates of red eyes found by the algorithm with a help of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mask" /> property. This way if the algorithm mistakes, you can display the user what was found and possible give them an opportunity to fix it manually. See the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeMask" /> and <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeBlob" /> classes description for more details on this.</para><para>If you are not happy with results, you can play with sensitivity of the algorithm. Try to reduce the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.RedChannelThreshold" /> property slightly. In the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode you can play with additional property, namely <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Sensitivity" />.</para><note>Both modes analyzes facial features when deciding what red pixels should be suppressed and what ones shold not. This way the algorithm reduces probability of malfunction (i.e. mistake reddish areas of the face or background for red eyes). The more precise the user selects the face, the more accurate red eye effect removal will be. Also, if the user works in the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode, they need try to click inside the red area of an eye. If the user clicks, say, white area of the flash reflection, the algorithm will not be able to fix red eye effect.</note></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.{dtor}" draft="yes">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.EyePoint" draft="yes">
            <summary>Gets/sets the point inside the eye where the red eye effect should be removed.</summary>
            <value>A <see cref="T:System.Drawing.PointF" /> which specify the point inside the red eye. Coordinates should be specified relatively left-top corner of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" />.</value>
            <remarks><para>This property makes sense only when the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property equals to <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" />. Typically the user clicks the red eye position with a mouse button. You should recalculate these coordinates relatively the face selection (specified by the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property).</para><note type="implementnotes">You should not specify the point outside of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> rectangle. Otherwise the transform will fail.</note></remarks>
            <seealso cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" />
<seealso cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" draft="yes">
            <summary>Gets/sets the rectangle which selects the person's face you want to remove the red eye effect from.</summary>
            <value>A <see cref="T:System.Drawing.RectangleF" /> which specifies the face region.</value>
            <remarks><para>When the Red Eye Removal works, it analyzes the facial features. It helps to reduce probability of malfunction. To make the red eye effect removal process as precise as possible, you should have the user to select the person's face as accurate as possible.</para><para>Users should select the face even if they use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode. The eye they select should be inside this rectangle.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mask" draft="yes">
            <summary>Gets the mask built during red eye effect removal process.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeMask" /> class instance which represents a mask generated during red eye removal process.</value>
            <remarks><para>You can use this property when you apply the red eye effect removal in <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode to determine what image elements were recognized as red eyes. To do it, use the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.Blobs" /> property of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeMask" /> class. If you need to get this mask as a bitmap, use the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeMask.BinaryMask" /> property.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" draft="yes">
            <summary>Gets/sets the red eye effect removal mode (manual or automatic).</summary>
            <value>A <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode" /> value which specify the mode of the red eye removal algorithm.</value>
            <remarks><para>When you use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode, the user should click the eye manually. When <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode is used, eyes are searched automatically. However in both cases the user should select the face which contains red eyes.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.#ctor" draft="yes">
            <summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class.</summary>
            <overloads><summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.#ctor(System.Drawing.Rectangle)" draft="yes">
            <summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class. You can pass the face rectangle into this constructor. It is convenient for the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode.</summary>
            <param name="faceRegion">A <see cref="T:System.Drawing.Rectangle" /> which specifies the face region. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property.</param>
            <remarks><para>When the Red Eye Removal works, it analyzes the facial features. It helps to reduce probability of malfunction. To make the red eye effect removal process as precise as possible, you should have the user to select the person's face as accurate as possible.</para><para>Users should select the face even if they use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode. The eye they select should be inside this rectangl.</para><para>When you use this constructor, the default value of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.#ctor(System.Drawing.Rectangle,System.Drawing.Point,System.Single)" draft="yes">
            <summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class. Use this constructor to pass all values for the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode.</summary>
            <param name="faceRegion">A <see cref="T:System.Drawing.Rectangle" /> which specifies the face region. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property.</param>
            <param name="startPoint">A <see cref="T:System.Drawing.Point" /> which specify the point inside the red eye. Coordinates should be specified relatively left-top corner of the <i>faceRegion</i>. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.EyePoint" /> property.</param>
            <param name="sensitivity">A float value in range [0,1] which specifies a sensivity of the red eye effect removal algorithm. The smaller value you specify, more pixels are affected. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Sensitivity" /> property.</param>
            <remarks><para>When the Red Eye Removal works, it analyzes the facial features. It helps to reduce probability of malfunction. To make the red eye effect removal process as precise as possible, you should have the user to select the person's face as accurate as possible.</para><para>Users should select the face even if they use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode. The eye they select should be inside this rectangle.
</para><para>When you use this constructor, the default value of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.#ctor(System.Drawing.RectangleF)" draft="yes">
            <summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class. You can pass the face rectangle into this constructor. It is convenient for the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode.</summary>
            <param name="faceRegion">A <see cref="T:System.Drawing.RectangleF" /> which specifies the face region. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property.</param>
            <remarks><para>When the Red Eye Removal works, it analyzes the facial features. It helps to reduce probability of malfunction. To make the red eye effect removal process as precise as possible, you should have the user to select the person's face as accurate as possible.</para><para>Users should select the face even if they use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode. The eye they select should be inside this rectangle.</para><para>When you use this constructor, the default value of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.#ctor(System.Drawing.RectangleF,System.Drawing.PointF,System.Single)" draft="yes">
            <summary>Creates and initializes new instance of the <see cref="T:Aurigma.GraphicsMill.Transforms.RedEyeRemoval" /> class. Use this constructor to pass all values for the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode.</summary>
            <param name="faceRegion">A <see cref="T:System.Drawing.RectangleF" /> which specifies the face region. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.FaceRegion" /> property.</param>
            <param name="startPoint">A <see cref="T:System.Drawing.PointF" /> which specify the point inside the red eye. Coordinates should be specified relatively left-top corner of the <i>faceRegion</i>. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.EyePoint" /> property.</param>
            <param name="sensitivity">A float value in range [0,1] which specifies a sensivity of the red eye effect removal algorithm. The smaller value you specify, more pixels are affected. You can change it later using the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Sensitivity" /> property.</param>
            <remarks><para>When the Red Eye Removal works, it analyzes the facial features. It helps to reduce probability of malfunction. To make the red eye effect removal process as precise as possible, you should have the user to select the person's face as accurate as possible.</para><para>Users should select the face even if they use <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode. The eye they select should be inside this rectangle.
</para><para>When you use this constructor, the default value of the <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Mode" /> property is <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" />.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.OnTransforming">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.RedChannelThreshold" draft="yes">
            <summary>Gets/sets the red channel threshold value used when removing the red eyes effect.</summary>
            <value>A float value in range [0,1] which specifies the red channel threshold.</value>
            <remarks><para>When you use values which are close to 0, the algorithm will capture a lot of pixels (even those which are unlikely to be red). It will highly reduce the performance and increase a number of false recognitions. Too high values may lead to reducing of probability of red eye removal. It is highly recommended to use default value of this property and adjust it only if it is actually necessary. </para><para>This property affects both for <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> and <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.Sensitivity" draft="yes">
            <summary>Gets/sets sensitivity value of the algorithm in the <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" /> mode.</summary>
            <value>A float value in range [0,1] which specifies a sensivity of the red eye effect removal algorithm. The smaller value you specify, more pixels are affected.</value>
            <remarks><para>This value is ignored in <see cref="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" /> mode (unlike <see cref="P:Aurigma.GraphicsMill.Transforms.RedEyeRemoval.RedChannelThreshold" /> property value).</para><para>It is recommended to use the default value of this property. However if you are not happy with the result, you can try to adjust it. </para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode" draft="yes">
            <summary>Contains red eye effect removal modes of this add-on.</summary>
            <remarks><para>Both modes analyzes facial features when deciding what red pixels should be suppressed and what ones shold not. This way the algorithm reduces probability of malfunction (i.e. mistake reddish areas of the face or background for red eyes). The more precise the user selects the face, the more accurate red eye effect removal will be.</para></remarks>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Manual" draft="yes">
            <summary>Manual mode. The user selects a face and click red eyes inside it. It makes sense to warn the user to click inside the red area of an eye. If the user clicks, say, white area of the flash reflection, the algorithm will not be able to fix red eye effect.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.RedEyeRemovalMode.Semiautomatic" draft="yes">
            <summary>Semi-automatic mode. The user selects a face and the algorithm automatically searches eyes on the face.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Resize" draft="yes">
            <summary>This class enables you to resize a bitmap.</summary>
            <remarks><para>
Using this class you may resample the bitmap: specify <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> properties, then apply the transform, and it will return resized bitmap. If you set some of these properties to 0, this property is automatically calculated to preserve the aspect ratio of the image. 
</para><para>
Essential parameter of all the geometric Transforms (including resizing) is an interpolation algorithm. It specifies how to calculate intermediate points. Different algorithms produces different quality, but as usual the higher quality it produces, the slower algorithm works. You can select interpolation algorithm with <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode" /> property.
</para><para>
This class provides interesting feature - you can resize not only entire bitmap, but even a portion of this bitmap. This way you can avoid edge effects (which will arise if you first crop and then resize the bitmap). It is important when you need to stitch several resized portions seamlessly (for example, during optimized drawing). To enable this feature, set <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.CropEnabled" /> property to <b>true</b> and fill <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.CropRectangle" /> with necessary values.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.ApplyTransform(Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Resizes given <see cref="T:Aurigma.GraphicsMill.Bitmap" /> ("in-place").</summary>
            <remarks><see cref="T:Aurigma.GraphicsMill.Bitmap" /> which should be resized. Result of the resize will be saved to the same bitmap (in other word, transform is applied "in-place").</remarks>
            <overloads><summary>Resizes given <see cref="T:Aurigma.GraphicsMill.Bitmap" /></summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.ApplyTransform(Aurigma.GraphicsMill.Bitmap,Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Produces resized copy of given <see cref="T:Aurigma.GraphicsMill.Bitmap" /> (which remains unchanged).</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It is not modified with the resize algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After resize algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.ApplyTransform(Aurigma.GraphicsMill.BitmapData,Aurigma.GraphicsMill.Bitmap)" draft="yes">
            <summary>Produces bitmap which contains resized copy of given bitmap data (<see cref="T:Aurigma.GraphicsMill.BitmapData" /> class instance). The bitmap data remains unchanged.</summary>
            <param name="source">Input <see cref="T:Aurigma.GraphicsMill.BitmapData" />. It is not modified with the resize algorithm.</param>
            <param name="destination">Output <see cref="T:Aurigma.GraphicsMill.Bitmap" />. It should be instantiated before passing to this method. After resize algorithm completes, all data loaded to this bitmap is discarded and result is copied here.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.CalculateProportionalDimensions(Aurigma.GraphicsMill.Bitmap,System.Int32@,System.Int32@,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Calculates parameters for resize which preserve aspect ratio of the specified bitmap.</summary>
            <param name="srcBitmap"><see cref="T:Aurigma.GraphicsMill.Bitmap" /> class instance which aspect ratio you should to preserve.</param>
            <param name="destWidth">Width value you need to recalculate. This value may be changed depending on the <i>mode</i> argument value.</param>
            <param name="destHeight">Height value you need to recalculate. This value may be changed depending on the <i>mode</i> argument value.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> value which specifies how to interpret <i>destWidth</i> and <i>destHeight</i> value.</param>
            <remarks><para>Use this method if you need to get the exact dimensions of the bitmap after proportional resize. This method recalculates specified width and height to preserve the aspect ratio of the input bitmap respecting the specified <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" />. Note, <i>destWidth</i> and <i>destHeight</i> are both <b>in</b> and <b>out</b>, and these values are changed by the method.</para><para>For example, you need to make sure that the bitmap after resize will fit 640x480 rectangle. In this case you should pass the following values: </para><list type="bullet"><item><term>srcBitmap</term><description>An instance of the bitmap which you are going to resize.</description></item><item><term>destWidth</term><description>An integer variable which is equal to 640.</description></item><item><term>destHeight</term><description>An integer variable which is equal to 480</description></item><item><term>mode</term><description><see cref="F:Aurigma.GraphicsMill.Transforms.ResizeMode.Fit" /></description></item></list><para>After you run this method, variables you pass as <i>destWidth</i> and <i>destHeight</i> will store recalculated dimensions.</para></remarks>
            <overloads><summary>Calculates parameters for resize which preserve specified aspect ratio.</summary><remarks><para>Use this method if you need to get the exact dimensions of the bitmap after proportional resize. </para></remarks></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.CalculateProportionalDimensions(System.Int32,System.Int32,System.Int32@,System.Int32@,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Calculates parameters for resize which preserve the aspect ratio of specified dimensions.</summary>
            <param name="srcWidth">Input width.</param>
            <param name="srcHeight">Input height.</param>
            <param name="destWidth">Width value you need to recalculate. This value may be changed depending on the <i>mode</i> argument value.</param>
            <param name="destHeight">Height value you need to recalculate. This value may be changed depending on the <i>mode</i> argument value.</param>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> value which specifies how to interpret <i>destWidth</i> and <i>destHeight</i> value.</param>
            <remarks><para>Use this method if you need to get the exact dimensions of the bitmap after proportional resize. This method recalculates specified width and height to preserve the specified aspect ratio respecting the specified <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" />. Note, <i>destWidth</i> and <i>destHeight</i> are both <b>in</b> and <b>out</b>, and these values are changed by the method.</para><para>For example, you need to make sure that the bitmap after resize will fit 640x480 rectangle. In this case you should pass the following values: </para><list type="bullet"><item><term>srcWidth</term><description>Width of the bitmap which you are going to resize.</description></item><item><term>srcBitmap</term><description>Height of the bitmap which you are going to resize.</description></item><item><term>destWidth</term><description>An integer variable which is equal to 640.</description></item><item><term>destHeight</term><description>An integer variable which is equal to 480</description></item><item><term>mode</term><description><see cref="F:Aurigma.GraphicsMill.Transforms.ResizeMode.Fit" /></description></item></list><para>After you run this method, variables you pass as <i>destWidth</i> and <i>destHeight</i> will store recalculated dimensions.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.CropEnabled">
            <summary>Gets/sets a value which enables or disables crop-before-resize feature.</summary>
            <value>Value which enables or disables crop-before-resize feature.</value>
            <remarks><para>
If you enable cropping before resize, you need also initialize <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.CropRectangle" /> parameter. When it is enabled, the transform takes pixels from this rectangle when resizing. Unlike situation when you first crop the image with <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> transform and then apply <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" />, this mode takes into account pixels neighbour to the rectangle boundary (but out of the rectangle) and this way it avoids edge effects.
</para><para>
Default value is <b>false</b> (disabled).
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.CropRectangle">
            <summary>Gets/sets a rectangle used for crop-before-resize feature.</summary>
            <value><see cref="T:System.Drawing.RectangleF" /> structure specifying cropping rectangle.</value>
            <remarks><para>
This property is used when <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.CropEnabled" /> is set to <b>true</b>. When it is enabled, the transform takes pixels from this rectangle when resizing. Unlike situation when you first crop the image with <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> transform and then apply <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" />, this mode takes into account pixels neighbour to the rectangle boundary (but out of the rectangle) and this way it avoids edge effects.
</para><note type="caution">
Draw attention, this transform does not support "outer crop". It means you cannot specify cropping rectangle which is out of the bitmap. This way you should make sure that the rectangle specified with this property is completely included into bitmap.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.Height">
            <summary>Gets/sets a height of resized bitmap.</summary>
            <value>Height of resized bitmap.</value>
            <remarks><para>
If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> cannot be set to 0 at the same time.
</para><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during resizing.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor" draft="yes">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance, and specify new width/height.</summary>
            <param name="width">Width of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> property.</param>
            <param name="height">Height of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance. You can specify here new width/height, and interpolation algorithm.</summary>
            <param name="width">Width of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> property.</param>
            <param name="height">Height of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance, and specify new width/height.</summary>
            <param name="width">Width of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> property.</param>
            <param name="height">Height of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance. You can specify here new width/height, and interpolation algorithm.</summary>
            <param name="width">Width of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> property.</param>
            <param name="height">Height of resized bitmap. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Drawing.Size)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance, and specify new width/height.</summary>
            <param name="size"><see cref="T:System.Drawing.Size" /> structure containing width and height of resized bitmap. You can change these parameters later using <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance. You can specify here new width/height, and interpolation algorithm.</summary>
            <param name="size"><see cref="T:System.Drawing.Size" /> structure containing width and height of resized bitmap. You can change these parameters later using <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Drawing.SizeF)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance, and specify new width/height.</summary>
            <param name="size"><see cref="T:System.Drawing.SizeF" /> structure containing width and height of resized bitmap. You can change these parameters later using <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.#ctor(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class instance. You can specify here new width/height, and interpolation algorithm.</summary>
            <param name="size"><see cref="T:System.Drawing.SizeF" /> structure containing width and height of resized bitmap. You can change these parameters later using <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.InterpolationMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.ResizeMode">
            <summary>Gets/sets a value which specifies how to interpret resize dimensions (<see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> properties).</summary>
            <value>A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Resize.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Resize.Width">
            <summary>Gets/sets a width of resized bitmap.</summary>
            <value>Width of resized bitmap.</value>
            <remarks><para>
If this value is set to 0, it is calculated automatically to preserve bitmap aspect ratio. <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Width" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Resize.Height" /> cannot be set to 0 at the same time.
</para><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.ResizeMode">
            <summary>Contains values for the resize modes (how the resize parameters should be intepreted).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ResizeMode.Fit">
            <summary>The resize width and height specify the rectangle the image should be inscribed to (image proportions should be preserved).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ResizeMode.Resize">
            <summary>The resize width and height specify dimensions of the image after resize. Proportions are not preserved.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.ResizeMode.Shrink">
            <summary>The same as <b>Fit</b>, but the resize occurs only if resize dimensions are smaller than image dimensions.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Rotate">
            <summary>This class enables you to rotate the bitmap on arbitrary angle.</summary>
            <remarks><para>
Main parameter of this transform is an <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.Angle" /> specifying how much degrees to rotate the image on. You can also select interpolation algorithm with <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.InterpolationMode" /> property. It specifies how to calculate intermediate points. Different algorithms produces different quality, but as usual the higher quality it produces, the slower algorithm works. 
</para><para>
If you need to rotate on 90, 180, or 270 degrees, you should consider using <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> transform instead of this one as it works noticeable faster.
</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Rotate5Transform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Rotate5Transform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Rotate.Angle">
            <summary>Gets/sets an angle (in degrees) to rotate on.</summary>
            <value>An angle (in degrees) to rotate on.</value>
            <remarks><para>
Image is rotated clockwise. To rotate it counter-clockwise, specify negative angle.
</para><para>Default value is 0.</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Rotate.BackgroundColor">
            <summary>Gets/sets the background color for the rotated image.</summary>
            <value>Value specifying the background color for the rotated image.</value>
            <remarks>Default value is a transparent white.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Rotate.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during rotation.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during rotation.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.#ctor(System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> class instance. Rotation angle is specified here.</summary>
            <param name="angle">An angle (in degrees) to rotate on. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.Angle" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.#ctor(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> class instance. All rotation parameters are specified here.</summary>
            <param name="angle">An angle (in degrees) to rotate on. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.Angle" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the rotated image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during rotation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Rotate.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Rotate.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip">
            <summary>This class enables you to flip the bitmap or rotate it on angle divisible on 90 degrees.</summary>
            <remarks>This transform has the single parameter <see cref="P:Aurigma.GraphicsMill.Transforms.RotateAndFlip.Mode" />. It enables all combination of rotation on angle divisible on 90 degree and flipping by both axes. Rotation made by this transform works faster than one made by <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> (which enables you to do rotate on arbitrary angle).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Rotate90Transform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Rotate90Transform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RotateAndFlip.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RotateAndFlip.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.RotateAndFlip.Mode">
            <summary>Gets/sets flip/rotate mode.</summary>
            <value><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode.</value>
            <remarks>Default value is <see cref="F:System.Drawing.RotateFlipType.RotateNoneFlipNone" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RotateAndFlip.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> class instance.</summary>
            <remarks>If you create a <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> instance with this constructor, do not forget to initialize <see cref="P:Aurigma.GraphicsMill.Transforms.RotateAndFlip.Mode" /> property later. As its default value is <see cref="F:System.Drawing.RotateFlipType.RotateNoneFlipNone" />, no effect will be applied if you run it without initializing this property.</remarks>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.RotateAndFlip.#ctor(System.Drawing.RotateFlipType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> class instance.</summary>
            <param name="flipMode"><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode. It is accessible later via <see cref="P:Aurigma.GraphicsMill.Transforms.RotateAndFlip.Mode" /> property.</param>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Shadow">
            <summary>This class allows you making opaque objects on the image to cast shadow.</summary>
            <remarks><para>
When you apply this effect, the image begins drop shadow with specified parameters (taking into account transparent areas of the image). This effect is ideal for creating artistic texts, logos, etc.  
</para><para>
You can specify a number of shadow parameters. <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.HorizontalOffset" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.VerticalOffset" /> specify offset of the shadow relatively the image. <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.ShadowColor" /> means the shadow color. To make shadow looking more realistic, it is blurred. You can set blur <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.Radius" /> (amount of the shadow fuzziness). Property <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.EnlargeToFit" /> can be used to specify if the transform should increase size of the image to fit the shadow or it should truncate the shadow which is out of the original image (makes sense to set it to <b>true</b> when you create artistic thumbnails).
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Shadow.EnlargeToFit">
            <summary>Gets/sets value that specifies whether to enlarge the image to fit entire shadow or put it to the image of the same size (in this case shadow which is out of the image will be cut off).</summary>
            <value>Value that specifies whether to enlarge the image to fit entire shadow.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Shadow.HorizontalOffset">
            <summary>Gets/sets horizontal offset of the shadow.</summary>
            <value>Value that specifies horizontal offset of the shadow.</value>
            <remarks>Default value is 10.0f.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.#ctor(Aurigma.GraphicsMill.Color,System.Single,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class instance. You can set main shadow parameters (color and offset) here.</summary>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies shadow color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.ShadowColor" /> property.</param>
            <param name="horizontalOffset">Value that specifies horizontal offset of the shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.HorizontalOffset" /> property.</param>
            <param name="verticalOffset">Value that specifies vertical offset of the shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.VerticalOffset" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.#ctor(Aurigma.GraphicsMill.Color,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class instance. You can set all the shadow parameters here.</summary>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies shadow color. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.ShadowColor" /> property.</param>
            <param name="horizontalOffset">Value that specifies horizontal offset of the shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.HorizontalOffset" /> property.</param>
            <param name="verticalOffset">Value that specifies vertical offset of the shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.VerticalOffset" /> property.</param>
            <param name="radius">Value that specifies a blur radius used to blur the shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.Radius" /> property.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire shadow. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Shadow.EnlargeToFit" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Shadow.Radius">
            <summary>Gets/sets a blur radius used to blur the shadow.</summary>
            <value>Value that specifies a blur radius used to blur the shadow.</value>
            <remarks><para>
This parameter works in the same way as <see cref="P:Aurigma.GraphicsMill.Transforms.Blur.Radius" /> of the <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> transform.
</para><para>
Default value is 5.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Shadow.ShadowColor">
            <summary>Gets/sets shadow color.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value that specifies shadow color.</value>
            <remarks>Default value is a dark gray color.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Shadow.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Shadow.VerticalOffset">
            <summary>Gets/sets vertical offset of the shadow.</summary>
            <value>Value that specifies vertical offset of the shadow.</value>
            <remarks>Default value is 10.0f.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Sharpen">
            <summary>This class provides simple sharpening algorithm.</summary>
            <remarks>Sharpen algorithm provided by this class is quite simple and has a single parameter <see cref="P:Aurigma.GraphicsMill.Transforms.Sharpen.Strength" />. You can also use more advanced sharpening algorithm - <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" />, however it is harder to use.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Sharpen.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Sharpen.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Sharpen.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Sharpen.#ctor(System.Int32)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> class instance. You can specify the single parameter of this transform here.</summary>
            <param name="strength">Value in range [0, 100] specifying sharpening strength. Minimum value makes no changes, maximum value produces maximum sharpening effect. This value can be changed later using <see cref="P:Aurigma.GraphicsMill.Transforms.Sharpen.Strength" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Sharpen.Strength">
            <summary>Gets/sets a value specifying strength of this algorithm.</summary>
            <value>Value in range [0, 100] specifying sharpening strength. Minimum value makes no changes, maximum value produces maximum sharpening effect.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Solarize">
            <summary>This class enables you to apply solarize effect.</summary>
            <remarks>This class has no parameters.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Solarize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Solarize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Solarize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Solarize" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Solarize.#ctor">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.Transforms.Solarize" /> class instance.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Spray">
            <summary>This class enables you to add spray effect on the image.</summary>
            <remarks>Spray effect lies in spreading pixels randomly.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.Amount">
            <summary>Gets/sets random number variance (used as offset of pixel when it is being spreading).</summary>
            <value>Value specifying the amount of the effect (variance of the random number generated by the transform).</value>
            <remarks>Default value is 5.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.BackgroundColor">
            <summary>Gets/sets background value used to replace pixels which should be taken outside of the image (actual on image edges when distance to the image edge is less than ).</summary>
            <value>Default value is a transparent white.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.FadeType">
            <summary>Gets/sets fade type for the spray effect (how does it change from image edges to center).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies fade type for the spray effect.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.FadeType.Linear" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.FillWithBackground">
            <summary>Gets/sets value that specifies how fill areas where no pixels felt: whether to use background color (see <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.BackgroundColor" /> property) or use original pixels of the bitmap.</summary>
            <value>Value that is <b>true</b> if <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.BackgroundColor" /> property is used, <b>false</b> when source bitmap pixels are taken.</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.FrameWidth">
            <summary>Gets/sets a width of the frame for which the effect should be applied.</summary>
            <value>Width of the frame for which the effect should be applied.</value>
            <remarks><para>
If this property is set to 0, effect is applied to entire image.
</para><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.#ctor(System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class instance. You can set spray amount here.</summary>
            <param name="amount">Value specifying the amount of the effect (variance of the random number generated by the transform). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.Amount" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.#ctor(System.Int32,System.Single,Aurigma.GraphicsMill.Transforms.FadeType,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class instance. You can set all spray parameters here.</summary>
            <param name="amount">Value specifying the amount of the effect (variance of the random number generated by the transform). You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.Amount" /> property.</param>
            <param name="frameWidth">Width of the frame for which the effect should be applied. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.FrameWidth" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies fade type for the spray effect. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.FadeType" /> property.</param>
            <param name="seed">An integer value specifying seed for random generator. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.Seed" /> property (or reinitialize it with <see cref="M:Aurigma.GraphicsMill.Transforms.Spray.Randomize" /> method).</param>
            <param name="backgroundColor">Default value is a transparent white. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.BackgroundColor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.Randomize">
            <summary>Initializes <see cref="P:Aurigma.GraphicsMill.Transforms.Spray.Seed" /> property with random value.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Spray.Seed">
            <summary>Gets/sets seed value for random generator.</summary>
            <value>An integer value specifying seed for random generator.</value>
            <remarks><para>
Set of random numbers is always the same for the same seed. So if you need to have the same result for multiple execution of this transform, specify some fixed seed. If you want to have different result each time you run this transform, set this property randomly (for example, from system clock or some other unpredictable value). You can also use special method <see cref="M:Aurigma.GraphicsMill.Transforms.Spray.Randomize" /> which automatically set this property to random value.
</para><para>
Default value is 0.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Spray.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.SwapChannels">
            <summary>This class allows you to swap bitmap channels.</summary>
            <remarks>To specify what channels to swap, you should initialize <see cref="P:Aurigma.GraphicsMill.Transforms.SwapChannels.ChannelsOrder" /> array which specifies how to rearrange channel indices. E.g. if you need to swap blue and green channel in RGB bitmap, this array will be looking like this: (1, 0, 2).</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.SwapChannels.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.SwapChannels.ChannelsOrder">
            <summary>Gets/sets array specifying how to rearrange channel indices.</summary>
            <value>An array of channel indices sorted in the necessary order. E.g. if you need to swap blue and green channel in RGB bitmap, this array will be looking in the following way: (1, 0, 2). If this array entries are sorted in ascending order, transform will do nothing.</value>
            <remarks>If number of indices is less than number of channels in the target bitmap, the rest channels will be unchanged. If there are more indices than target bitmap provides, all extra indices will be ignored.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.SwapChannels.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.SwapChannels.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.SwapChannels.#ctor(System.Int32[])">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.SwapChannels" /> class instance.</summary>
            <param name="channels">An array of channel indices sorted in the necessary order. E.g. if you need to swap blue and green channel in RGB bitmap, this array will be looking in the following way: (1, 0, 2). If this array entries are sorted in ascending order, transform will do nothing. You can change it later through <see cref="P:Aurigma.GraphicsMill.Transforms.SwapChannels.ChannelsOrder" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.SwapChannels.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Swirl">
            <summary>This class enables you to apply swirl transform.</summary>
            <remarks><para>
For swirl transform you can specify the center of the swirl (using the <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property) and swirl strength (<see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property).
</para><para>
Essential parameter of all the geometric Transforms (including swirl) is an interpolation algorithm. It specifies how to calculate intermediate points. Different algorithms produces different quality, but as usual the higher quality it produces, the slower algorithm works. You can select interpolation algorithm with <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode" /> property.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Swirl.BackgroundColor">
            <summary>Gets/sets background color for the swirled image.</summary>
            <value>Value specifying background color for the swirled image.</value>
            <remarks>Default value is transparent white.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Swirl.Center">
            <summary>Gets/sets swirl center point.</summary>
            <value><see cref="T:System.Drawing.PointF" /> structure specifying center point for the swirl.</value>
            <remarks>Default swirl center is in point (0,0).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during swirling.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set here center point and scale factor of the swirl transform.</summary>
            <param name="x">X-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="y">Y-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Int32,System.Int32,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set all swirl transform parameters here.</summary>
            <param name="x">X-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="y">Y-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set here center point and scale factor of the swirl transform.</summary>
            <param name="x">X-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="y">Y-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set all swirl transform parameters here.</summary>
            <param name="x">X-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="y">Y-coordinate of the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Drawing.Point,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set here center point and scale factor of the swirl transform.</summary>
            <param name="center">Point specifying the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Drawing.Point,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set all swirl transform parameters here.</summary>
            <param name="center">Point specifying the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Drawing.PointF,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set here center point and scale factor of the swirl transform.</summary>
            <param name="center">Point specifying the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.#ctor(System.Drawing.PointF,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class instance. You can set all swirl transform parameters here.</summary>
            <param name="center">Point specifying the swirl center. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.Center" /> property.</param>
            <param name="scaleFactor">Swirl scale factor. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling. Can be modified later through <see cref="P:Aurigma.GraphicsMill.Transforms.Swirl.InterpolationMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Swirl.ScaleFactor">
            <summary>Gets/sets swirl scale factor.</summary>
            <value>Swirl scale factor.</value>
            <remarks>Default value is 5.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Swirl.ThreadProc">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Texturize">
            <summary>This class enables you to create texture from the image by reducing its size and "gluing" it with its copies seamlessly.</summary>
            <remarks>To apply texturizing you can set <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.ColumnsAmount" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.RowsAmount" /> properties to specify how much image copies should be horizontally and vertically. Then you specify parameters which affects to edges processing such as <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.FadeType" />, <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.HorizontalIntersection" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.VerticalIntersection" />. Property <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.FadeType" /> can be used to make images rotated one relatively each other.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Texturize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.ColumnsAmount">
            <summary>Gets/sets columns number (how much images will be put horizontally).</summary>
            <value>Columns number.</value>
            <remarks>Default value is 4.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Texturize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.FadeType">
            <summary>Gets/sets value that specifies how to fade out edges to eliminate seams.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies how to fade out edges to eliminate seams.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.FadeType.Linear" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.FlipMode">
            <summary>Gets/sets value that specifies how to flip/rotate the images one relatively other.</summary>
            <value><see cref="T:System.Drawing.RotateFlipType" /> value that specifies how to flip/rotate the images one relatively other.</value>
            <remarks>Default value is <see cref="F:System.Drawing.RotateFlipType.RotateNoneFlipNone" />.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.HorizontalIntersection">
            <summary>Gets/sets how much percents of image are overlapped horizontally (at single side).</summary>
            <value>Value that specifies how much percents of image are overlapped horizontally (at single side).</value>
            <remarks><para>
Valid values for this property are in range [0, 50].
<para></para>
Default value is 20.
</para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during resizing.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Texturize.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Texturize.#ctor(System.Int32,System.Int32)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class instance. You can set number of rows and columns in this constructor.</summary>
            <param name="columnsAmount">Columns number. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.ColumnsAmount" /> property.</param>
            <param name="rowsAmount">Rows number. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.RowsAmount" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Texturize.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.RotateFlipType,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class instance. You can specify all the parameters of this transforms here.</summary>
            <param name="columnsAmount">Columns number. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.ColumnsAmount" /> property.</param>
            <param name="rowsAmount">Rows number. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.RowsAmount" /> property.</param>
            <param name="horizontalIntersection">Value that specifies how much percents of image are overlapped horizontally (at single side). Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.HorizontalIntersection" /> property.</param>
            <param name="verticalIntersection">Value that specifies how much percents of image are overlapped vertically (at single side). Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.VerticalIntersection" /> property.</param>
            <param name="flipMode"><see cref="T:System.Drawing.RotateFlipType" /> value that specifies how to flip/rotate the images one relatively other. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.FlipMode" /> property.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies how to fade out edges to eliminate seams. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.FadeType" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing. Can be changed later via <see cref="P:Aurigma.GraphicsMill.Transforms.Texturize.InterpolationMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.RowsAmount">
            <summary>Gets/sets rows number (how much images will be put vertically).</summary>
            <value>Rows number.</value>
            <remarks>Default value is 4.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Texturize.VerticalIntersection">
            <summary>Gets/sets how much percents of image are overlapped vertically (at single side).</summary>
            <value>Value that specifies how much percents of image are overlapped vertically (at single side).</value>
            <remarks><para>
Valid values for this property are in range [0, 50].
<para></para>
Default value is 20.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Transparentize">
            <summary>This class enables you to set alpha values of pixels with specified colors (and tolerant ones) to transparent.</summary>
            <remarks>This transform is very useful when you need to blend two images and "upper" image does not have alpha channel, but it has a background color. For example, you draw a logo placed in the center of the image on white background. In this case you set <see cref="P:Aurigma.GraphicsMill.Transforms.Transparentize.TransparentColor" /> to white color. You can also adjust a <see cref="P:Aurigma.GraphicsMill.Transforms.Transparentize.Tolerance" /> parameter to make colors close to white color be semi-transparent (to get smooth colors). Besides of that <see cref="P:Aurigma.GraphicsMill.Transforms.Transparentize.Tolerance" /> is useful when background color is not completely uniform (for example, you loaded JPEG file with low quality).</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Transparentize.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Transparentize.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Transparentize.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Transparentize.#ctor(Aurigma.GraphicsMill.Color,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Transparentize" /> class instance. You can set all transparentize parameters here.</summary>
            <param name="transparentColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying a color to transparentize. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Transparentize.TransparentColor" /> property.</param>
            <param name="tolerance">Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and transparent color. Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.Transparentize.Tolerance" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Transparentize.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Transparentize.Tolerance">
            <summary>Gets/sets a value that specifies admissible tolerance (distance between colors in color space) when comparing current color and transparent color.</summary>
            <value>Value in range [0, 1] specifying admissible tolerance (distance between colors in color space) when comparing current color and transparent color. Minimum value (0) means exact match of the colors, maximum value (1) means that any color matches.</value>
            <remarks>Default value is 0.1f.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Transparentize.TransparentColor">
            <summary>Gets/sets value specifying the color to transparentize.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Color" /> value specifying a color to transparentize.</value>
            <remarks>Default value is white.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.UnsharpMask">
            <summary>This class enables you to increase image sharpness by using <i>unsharp mask</i> technique.</summary>
            <remarks><para><i>Unsharp mask</i> is a wide-spread technique used by photographers to increase image sharpness even in precomputer times. The idea is to combine the image with the unfocused (blurred) version. This class provides <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.BlurType" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Radius" /> to specify blur settings. During combining the algorithm calculates the difference between corresponding pixels of original and blurred image. If this difference is greater than value specified with <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Threshold" /> property, algorithm adds this N percents of this difference to original pixel (N is set by <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Amount" /> property). Otherwise no changes to original pixel is done. As blurred image differs from original ones mainly on the object edges, sharpening effect is achieved.  
</para><para>
Using this technique is quite difficult to untrained user as it requires to supply three non-intuitive parameters (amount, radius, and threshold). That's why if you want to provide user easy way to manipulate image sharpness, you can use <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> transform which is less flexible, but much more easy-to-use.
</para></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#UnsharpMaskTransform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#UnsharpMaskTransform"></code></example>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.UnsharpMask.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Amount">
            <summary>Gets/sets unsharp mask amount (the difference between blurred and original image).</summary>
            <value>Value that specifies unsharp mask amount. Amount*100 means the percentage of the difference between blurred and original image. Min value is 0.</value>
            <remarks>Default value is 1.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.BlurType">
            <summary>Gets/sets blur type used to produce unfocused version of the image (necessary for unsharp mask algorithm).</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> value specifying a blur type used to produce unfocused version of the image.</value>
            <remarks><para>
Using this property you can select between algorithm speed and precision.
</para><para>
Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.BlurType.Fast" />.
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.UnsharpMask.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.UnsharpMask.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.UnsharpMask.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class instance. You can set all three unsharp mask main values here.</summary>
            <param name="amount">Value that specifies unsharp mask amount. Amount*100 means the percentage of the difference between blurred and original image. Min value is 0.  You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Amount" /> property.</param>
            <param name="radius">Value that specifies blur radius used to produce unfocused version of the image. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Radius" /> property.</param>
            <param name="threshold">Value in range [0, 1] specifying threshold value for the unsharp mask. Minimum value (0) means that all pixels are affected with unsharp mask, maximum value means that no pixels are affected. To calculate threshold in pixel luminosity levels, multiply it on 255 for non-extended (8 bit per channel) images, or 65535 for extended (16 bit per channel) images. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Threshold" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.UnsharpMask.#ctor(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.BlurType)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class instance. You can set all parameters of the  unsharp mask transform here.</summary>
            <param name="amount">Value that specifies unsharp mask amount. Amount*100 means the percentage of the difference between blurred and original image. Min value is 0.  You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Amount" /> property.</param>
            <param name="radius">Value that specifies blur radius used to produce unfocused version of the image. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Radius" /> property.</param>
            <param name="threshold">Value in range [0, 1] specifying threshold value for the unsharp mask. Minimum value (0) means that all pixels are affected with unsharp mask, maximum value means that no pixels are affected. To calculate threshold in pixel luminosity levels, multiply it on 255 for non-extended (8 bit per channel) images, or 65535 for extended (16 bit per channel) images. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Threshold" /> property.</param>
            <param name="blurType"><see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> value specifying a blur type used to produce unfocused version of the image. You can change it later using <see cref="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.BlurType" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Radius">
            <summary>Gets/sets blur radius used to produce unfocused version of the image (necessary for unsharp mask algorithm).</summary>
            <value>Value that specifies blur radius used to produce unfocused version of the image.</value>
            <remarks>Default value is 2.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.UnsharpMask.Threshold">
            <summary>Gets/sets threshold value for the unsharp mask.</summary>
            <value><para>
Value in range [0, 1] specifying threshold value for the unsharp mask. Minimum value (0) means that all pixels are affected with unsharp mask, maximum value means that no pixels are affected. To calculate threshold in pixel luminosity levels, multiply it on 255 for non-extended (8 bit per channel) images, or 65535 for extended (16 bit per channel) images.
</para><para>
Default value is 0.1.
</para></value>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Waddle">
            <summary>This class enables you to apply waddle effect.</summary>
            <remarks>Waddle is a special kind of blur which makes the image looking detuned. You can specify two parameters - waddle <see cref="P:Aurigma.GraphicsMill.Transforms.Waddle.Direction" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Waddle.Radius" />.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Waddle.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Waddle.Direction">
            <summary>Gets/sets a waddle direction.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying a direction of the waddle.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.Direction.Down" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Waddle.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Waddle.#ctor">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class instance.</summary>
            <overloads><summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Waddle.#ctor(System.Single)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class instance. You can set waddle radius here.</summary>
            <param name="radius">Value that specifies waddle radius. You can change it later through the <see cref="P:Aurigma.GraphicsMill.Transforms.Waddle.Radius" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Waddle.#ctor(System.Single,Aurigma.GraphicsMill.Transforms.Direction)">
            <summary>Creates and initializes new <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class instance. You can set both waddle radius and direction here.</summary>
            <param name="radius">Value that specifies waddle radius. You can change it later through the <see cref="P:Aurigma.GraphicsMill.Transforms.Waddle.Radius" /> property.</param>
            <param name="direction">Value that specifies waddle direction. You can change it later through the <see cref="P:Aurigma.GraphicsMill.Transforms.Waddle.Direction" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Waddle.Radius">
            <summary>Gets/sets a waddle raduis.</summary>
            <value>Value that specifies waddle radius.</value>
            <remarks><para>
Unlike <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> and any other filters, radius of the <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> does not affect the performance at all. 
</para><para>
Minimum value for the waddle radius is 3.
</para><para>
Default value is 5.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.WaterDrop">
            <summary>This class enables you to apply water drop effect (ripples on the water).</summary>
            <remarks><para>
To produce effect of the ripples on the water, you can specify such parameters as a <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> point ("epicenter" of ripples), ripple <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" />, <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" />, and <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" />.
</para><para>
Essential parameter of all the geometric Transforms (including water drop transform) is an interpolation algorithm. It specifies how to calculate intermediate points. Different algorithms produces different quality, but as usual the higher quality it produces, the slower algorithm works. You can select interpolation algorithm with <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode" /> property.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude">
            <summary>Gets/sets an amplitude of the ripples.</summary>
            <value>An amplitude of the ripple.</value>
            <remarks>Default value is 30.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.BackgroundColor">
            <summary>Gets/sets background color for the distorted image.</summary>
            <value>Value specifying background color for the distorted image.</value>
            <remarks>Default value is transparent white.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center">
            <summary>Gets/sets water drop center point ("epicenter" of the ripples).</summary>
            <value><see cref="T:System.Drawing.PointF" /> structure specifying water drop center point.</value>
            <remarks>By default water drop center is set to point (0, 0).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during water drop transformation.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance.</summary>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify main water drop settings here.</summary>
            <param name="x">X-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="y">Y-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Int32,System.Int32,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify all water drop settings here.</summary>
            <param name="x">X-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="y">Y-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify main water drop settings here.</summary>
            <param name="x">X-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="y">Y-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify all water drop settings here.</summary>
            <param name="x">X-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="y">Y-coordinate of the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Drawing.Point,System.Single,System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify main water drop settings here.</summary>
            <param name="center"><see cref="T:System.Drawing.Point" /> structure that specifies the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Drawing.Point,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify all water drop settings here.</summary>
            <param name="center"><see cref="T:System.Drawing.Point" /> structure that specifies the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Drawing.PointF,System.Single,System.Single,System.Single)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify main water drop settings here.</summary>
            <param name="center"><see cref="T:System.Drawing.PointF" /> structure that specifies the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.#ctor(System.Drawing.PointF,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class instance. You can specify all water drop settings here.</summary>
            <param name="center"><see cref="T:System.Drawing.Point" /> structure that specifies the center point of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Center" /> property.</param>
            <param name="radius">Radius of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius" /> property.</param>
            <param name="amplitude">Amplitude of the water drop. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Amplitude" /> property.</param>
            <param name="wavelength">A wave length of the ripples. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.WaterDrop.InterpolationMode" /> property.</param>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Radius">
            <summary>Gets/sets a radius of the ripples.</summary>
            <value>A radius of the ripple.</value>
            <remarks>Default value is 50.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.WaterDrop.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.WaterDrop.Wavelength">
            <summary>Gets/sets a wave length of the ripples.</summary>
            <value>A wave length of the ripples.</value>
            <remarks>Default value is 10.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.Wave">
            <summary>This class enables you to apply wave transform.</summary>
            <remarks><para>
Using this class you can make the image distorted to repeat specified wave form. Wave can be both horizontal and vertical. You can specify such wave parameters as amplitude (<see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalAmplitude" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalAmplitude" /> properties), start phase (<see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalStartPhase" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalStartPhase" /> properties), and length (<see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalWavelength" /> and <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalWavelength" /> properties). Wave form is specified with <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.WaveType" /> property. 
</para><para>
Essential parameter of all the geometric Transforms (including wave transform) is an interpolation algorithm. It specifies how to calculate intermediate points. Different algorithms produces different quality, but as usual the higher quality it produces, the slower algorithm works. You can select interpolation algorithm with <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.InterpolationMode" /> property.
</para><para>
All the coordinates and sizes are measured in units specified with <see cref="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit" /> property.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.BackgroundColor">
            <summary>Gets/sets background color for the distorted image.</summary>
            <value>Value specifying background color for the distorted image.</value>
            <remarks>Default value is transparent white.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" />.</summary></overloads>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.EnlargeToFit">
            <summary>Gets/sets value that specifies whether to enlarge the image to fit entire distorted image (including wave peaks) or put it to the image of the same size (in this case wave peaks will be cut off).</summary>
            <value>Value that specifies whether to enlarge the image to fit entire distorted image.</value>
            <remarks>Default value is <b>true</b>.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalAmplitude">
            <summary>Gets/sets an amplitude for horizontal wave.</summary>
            <value>An amplitude for horizontal wave.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalStartPhase">
            <summary>Gets/sets horizontal wave start phase (in degrees).</summary>
            <value>Horizontal wave start phase (in degrees).</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalWavelength">
            <summary>Gets/sets length of the horizontal wave.</summary>
            <value>Length of the horizontal wave.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.InterpolationMode">
            <summary>Gets/sets interpolation algorithm used during wave transformation.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during wave transformation.</value>
            <remarks>Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.InterpolationMode.MediumQuality" />.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.#ctor">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class instance.</summary>
            <remarks>If you create <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> instance with this constructor, do not forget to initialize wave settings as by default they are set to neutral values (no effect will be applied with default values).</remarks>
            <overloads><summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class instance.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.#ctor(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class instance. You can set wave settings here.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalAmplitude" /> property.</param>
            <param name="horizontalWavelength">Length of the horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalWavelength" /> property.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalStartPhase" /> property.</param>
            <param name="verticalAmplitude">Amplitude for vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalAmplitude" /> property.</param>
            <param name="verticalWavelength">Length of the vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalWavelength" /> property.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalStartPhase" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.#ctor(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32,Aurigma.GraphicsMill.Transforms.WaveType)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class instance. You can set wave settings and wave form here.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalAmplitude" /> property.</param>
            <param name="horizontalWavelength">Length of the horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalWavelength" /> property.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalStartPhase" /> property.</param>
            <param name="verticalAmplitude">Amplitude for vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalAmplitude" /> property.</param>
            <param name="verticalWavelength">Length of the vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalWavelength" /> property.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalStartPhase" /> property.</param>
            <param name="waveType"><see cref="T:Aurigma.GraphicsMill.Transforms.WaveType" /> value that specifies a form of the wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.WaveType" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.#ctor(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32,Aurigma.GraphicsMill.Transforms.WaveType,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode,System.Boolean)">
            <summary>Creates and initializes <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class instance. You can set all parameters of this transforms here.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalAmplitude" /> property.</param>
            <param name="horizontalWavelength">Length of the horizontal wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalWavelength" /> property.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.HorizontalStartPhase" /> property.</param>
            <param name="verticalAmplitude">Amplitude for vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalAmplitude" /> property.</param>
            <param name="verticalWavelength">Length of the vertical wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalWavelength" /> property.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees). You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalStartPhase" /> property.</param>
            <param name="waveType"><see cref="T:Aurigma.GraphicsMill.Transforms.WaveType" /> value that specifies a form of the wave. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.WaveType" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.BackgroundColor" /> property.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during wave transformation. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.InterpolationMode" /> property.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire distorted image. You can change it later via <see cref="P:Aurigma.GraphicsMill.Transforms.Wave.EnlargeToFit" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Transforms.Wave.ThreadProc">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalAmplitude">
            <summary>Gets/sets an amplitude for vertical wave.</summary>
            <value>An amplitude for vertical wave.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalStartPhase">
            <summary>Gets/sets vertical wave start phase (in degrees).</summary>
            <value>Vertical wave start phase (in degrees).</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.VerticalWavelength">
            <summary>Gets/sets length of the vertical wave.</summary>
            <value>Length of the vertical wave.</value>
            <remarks>Default value is 0.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.Transforms.Wave.WaveType">
            <summary>Gets/sets a form of the wave.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Transforms.WaveType" /> value that specifies a form of the wave.</value>
            <remarks><para>
This parameter specifies wave form for both horizontal and vertical waves. You cannot specify different wave forms for horizontal and vertical wave.
</para><para>
Default value is <see cref="F:Aurigma.GraphicsMill.Transforms.WaveType.Sine" />.
</para></remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.Transforms.WaveType">
            <summary>Contains wave types for Wave transform.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.WaveType.LeftSaw">
            <summary>Saw wave skewed to left.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.WaveType.RightSaw">
            <summary>Saw wave skewed to right.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.WaveType.Sine">
            <summary>Sine wave.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.WaveType.Square">
            <summary>Square wave.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Transforms.WaveType.Triangle">
            <summary>Triangle wave.</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.TransformsProvider">
            <summary>This class contains methods used by <see cref="T:Aurigma.GraphicsMill.Bitmap" /> to apply various effects on the bitmap.</summary>
            <remarks><para>
This class enables you to apply effects and transforms (except ones used for tone and color correction) on the bitmap without creating appropriate transform object (contained in <see cref="N:Aurigma.GraphicsMill.Transforms" /> namespace). Therefore you can write only single line of code to run the transform. For example, instead of this code:
</para><code language="VB" source="ApplyingEffectsVB/form1.vb#Resize3Bitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Resize3Bitmap"></code><para>you can just use this code:</para><code language="VB" source="ApplyingEffectsVB/form1.vb#Resize3Transform"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Resize3Transform"></code><para>
The only drawback of this short syntax is that you can run transforms and effects through this class only in synchronous mode. If you need to use asynchronous mode, you should create transform class instances and set up the asynchronous mode settings for them.
</para><para>
Another difference of using of this class instead of transform objects is event handling. Unlike transform objects, you should assign event handlers directly to the <see cref="T:Aurigma.GraphicsMill.Bitmap" /> class.
</para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Boolean[],System.Single)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
            <overloads><summary>Puts an additive noise on the image by adding random number to each pixel.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Boolean[],System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Boolean[],System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean,System.Int32)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="channels">Array of flags specifying what channels to apply effect at. If array item is <b>true</b>, transform will be applied at channel with appropriate index. Otherwise this channel is skipped.</param>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise.</param>
            <param name="seed">An integer value specifying seed for random generator.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Single)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#AddNoise"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AddNoise"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.AddNoise(System.Single,Aurigma.GraphicsMill.Transforms.DistributionKind,System.Boolean,System.Int32)">
            <summary>Puts an additive noise on the image by adding random number to each pixel.</summary>
            <param name="amount">Noise amount value varying in range [-1, 1].</param>
            <param name="distributionKind">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.DistributionKind" /> enumeration specifying noise distribution law.</param>
            <param name="grayNoise">A value specifying if to generate gray or color noise.</param>
            <param name="seed">An integer value specifying seed for random generator.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.AddNoise" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.ApplyMatrixTransform(Aurigma.GraphicsMill.Transforms.Matrix)">
            <summary>Applies a linear transformation of the bitmap (based on specified matrix).</summary>
            <param name="transform"><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which specifies a matrix of the linear transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class to apply this effect.</remarks>
            <example><para>Here is an example how to apply skew transform using the affine matrix:</para><code language="VB" source="ApplyingEffectsVB/form1.vb#AffineMatrix"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#AffineMatrix"></code><para>Here is an example of the skew transform using points:</para><code language="VB" source="ApplyingEffectsVB/form1.vb#Skew"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Skew"></code><para>Here are examples with projective matrix:</para><code language="VB" source="ApplyingEffectsVB/form1.vb#ProjectiveMatrix"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ProjectiveMatrix"></code><code language="VB" source="ApplyingEffectsVB/form1.vb#ProjectivePoints"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#ProjectivePoints"></code></example>
            <overloads><summary>Applies a linear transformation of the bitmap (based on specified matrix).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.ApplyMatrixTransform(Aurigma.GraphicsMill.Transforms.Matrix,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies a linear transformation of the bitmap (based on specified matrix).</summary>
            <param name="transform"><see cref="T:Aurigma.GraphicsMill.Transforms.Matrix" /> class instance which specifies a matrix of the linear transformation.</param>
            <param name="backgroundColor">Value which specifies the background color for the transformed image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value which specifies interpolation algorithm used during transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.ApplyMatrixTransform" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Blur(System.Single)">
            <summary>Applies blur filter on the bitmap.</summary>
            <param name="radius">A positive value which specifies blur radius.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Blur"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Blur"></code></example>
            <overloads><summary>Applies blur filter on the bitmap.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Blur(System.Single,Aurigma.GraphicsMill.Transforms.BlurType)">
            <summary>Applies blur filter on the bitmap.</summary>
            <param name="radius">A positive value which specifies blur radius.</param>
            <param name="type">A member of <see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> enumeration specifying blur type.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Blur" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
            <overloads><summary>Applies buttonize effect on the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw highlighted edges.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw shadowed edges.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Buttonize"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Buttonize"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw highlighted edges.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw shadowed edges.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,System.Boolean,System.Boolean)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges.</param>
            <param name="horizontalBorder">Value specifying whether to show horizontal border.</param>
            <param name="verticalBorder">Value specifying whether to show vertical border.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Buttonize(System.Single,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.Direction,System.Boolean,System.Boolean,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies buttonize effect on the image.</summary>
            <param name="borderWidth">Border (button edge) width.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value specifying a fade type used to draw button edges.</param>
            <param name="direction"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> value specifying lightning direction used to draw button edges.</param>
            <param name="horizontalBorder">Value specifying whether to show horizontal border.</param>
            <param name="verticalBorder">Value specifying whether to show vertical border.</param>
            <param name="lightColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw highlighted edges.</param>
            <param name="shadowColor"><see cref="T:Aurigma.GraphicsMill.Color" /> value used to draw shadowed edges.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Buttonize" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="x">X-coordinate of the cropping rectangle.</param>
            <param name="y">Y-coordinate of the cropping rectangle.</param>
            <param name="width">Width of the cropping rectangle.</param>
            <param name="height">Height of the cropping rectangle.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Crop"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Crop"></code></example>
            <overloads><summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Int32,System.Int32,System.Int32,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="x">X-coordinate of the cropping rectangle.</param>
            <param name="y">Y-coordinate of the cropping rectangle.</param>
            <param name="width">Width of the cropping rectangle.</param>
            <param name="height">Height of the cropping rectangle.</param>
            <param name="backgroundColor">Background color which is used when cropping rectangle takes pixels which are out of the image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Vignette2"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Vignette2"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Single,System.Single,System.Single,System.Single)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="x">X-coordinate of the cropping rectangle.</param>
            <param name="y">Y-coordinate of the cropping rectangle.</param>
            <param name="width">Width of the cropping rectangle.</param>
            <param name="height">Height of the cropping rectangle.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="x">X-coordinate of the cropping rectangle.</param>
            <param name="y">Y-coordinate of the cropping rectangle.</param>
            <param name="width">Width of the cropping rectangle.</param>
            <param name="height">Height of the cropping rectangle.</param>
            <param name="backgroundColor">Background color which is used when cropping rectangle takes pixels which are out of the image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Drawing.Rectangle)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="rect">Cropping rectangle.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Drawing.Rectangle,Aurigma.GraphicsMill.Color)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="rect">Cropping rectangle.</param>
            <param name="backgroundColor">Background color which is used when cropping rectangle takes pixels which are out of the image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Drawing.RectangleF)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="rect">Cropping rectangle.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Crop(System.Drawing.RectangleF,Aurigma.GraphicsMill.Color)">
            <summary>Crops the image using specified rectangle (which is not obligatory totally inside the bitmap).</summary>
            <param name="rect">Cropping rectangle.</param>
            <param name="backgroundColor">Background color which is used when cropping rectangle takes pixels which are out of the image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Crop" /> class to crop the image.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Cylindrize"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Cylindrize"></code></example>
            <overloads><summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <param name="cylinderColor">Cylinder color value.</param>
            <param name="backgroundColor">Background color value.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single,System.Single,System.Single)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken.</param>
            <param name="cylinderColor">Cylinder color value.</param>
            <param name="backgroundColor">Background color value.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken.</param>
            <param name="horizontalOffset">Horizontal offset of the bitmap on the cylinder.</param>
            <param name="verticalOffset">Vertical offset of the bitmap on the cylinder.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Cylindrize(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies cylindrize transform (image is looking like bended on mug or any other cylindric surface).</summary>
            <param name="slopeAngle">Slope angle of the cylinder.</param>
            <param name="cylinderHalfPerimeter">Positive number specifying half-perimeter of the cylinder. You can also specify -1. In this case width of the bitmap will be taken.</param>
            <param name="cylinderHeight">Positive number specifying height of the cylinder. You can also specify -1. In this case height of the bitmap will be taken.</param>
            <param name="horizontalOffset">Horizontal offset of the bitmap on the cylinder.</param>
            <param name="verticalOffset">Vertical offset of the bitmap on the cylinder.</param>
            <param name="cylinderColor">Cylinder color value.</param>
            <param name="backgroundColor">Background color value.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used in the transform.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Cylindrize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Dispose" draft="yes">
            <summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.TransformsProvider" />.</summary>
            <overloads><summary>Releases all resources used by this <see cref="T:Aurigma.GraphicsMill.TransformsProvider" />.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Dispose(System.Boolean)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.EdgeDetect(Aurigma.GraphicsMill.Transforms.EdgeDetectMode)">
            <summary>Detects edges on the image.</summary>
            <param name="mode"><see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetectMode" /> value specifying edge detector.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.EdgeDetect" /> class to detect edges.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Emboss">
            <summary>Applies emboss effect on the image.</summary>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Emboss"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Emboss"></code></example>
            <overloads><summary>Applies emboss effect on the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Emboss(System.Single,System.Int32,System.Int32)">
            <summary>Applies emboss effect on the image.</summary>
            <param name="angle">Emboss angle (in degrees).</param>
            <param name="height">Value specifying embossed image height (in pixels).</param>
            <param name="amount">Value specifying emboss amount ("strength" of embossing). It is specified in percents - values below 100 will reduce contrast, values above 100 will increase contrast.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Emboss(System.Single,System.Int32,System.Int32,System.Single)">
            <summary>Applies emboss effect on the image.</summary>
            <param name="angle">Emboss angle (in degrees).</param>
            <param name="height">Value specifying embossed image height (in pixels).</param>
            <param name="amount">Value specifying emboss amount ("strength" of embossing). It is specified in percents - values below 100 will reduce contrast, values above 100 will increase contrast.</param>
            <param name="brightness">Value in range [-1, 1] specifying embossed image brightness.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Emboss" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Glow(Aurigma.GraphicsMill.Color)">
            <summary>Applies glow effect.</summary>
            <param name="glowColor">Glow color.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class to apply this effect.</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Glow"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Glow"></code></example>
            <overloads><summary>Applies glow effect.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Glow(Aurigma.GraphicsMill.Color,System.Single,System.Single,System.Boolean)">
            <summary>Applies glow effect.</summary>
            <param name="glowColor">Glow color.</param>
            <param name="intensity">Positive <see cref="T:System.Single" /> value that specifies glow intensity. Small values (about 1.0 or below) provide hardly visible glow. In the same time, large values (say, about 50) provide too heavy glow.</param>
            <param name="radius">Value that specifies a blur radius used to blur the glow.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire glow.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Glow" /> class to apply this effect.</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.MaximumFilter(System.Int32)">
            <summary>Applies maximum filter on the image.</summary>
            <param name="radius">Filter radius.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.MaximumFilter" /> class to apply this filter.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#MaximumFilter"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#MaximumFilter"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.MedianFilter(System.Int32)">
            <summary>Applies median filter on the image.</summary>
            <param name="radius">Filter radius.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.MedianFilter" /> class to apply this filter.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#MedianFilter"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#MedianFilter"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.MinimumFilter(System.Int32)">
            <summary>Applies minimum filter on the image.</summary>
            <param name="radius">Filter radius.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.MinimumFilter" /> class to apply this filter.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#MinimumFilter"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#MinimumFilter"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Mosaic(System.Int32,System.Int32)">
            <summary>Applies mosaic effect.</summary>
            <param name="cellWidth">Mosaic cell width.</param>
            <param name="cellHeight">Mosaic cell height.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Mosaic"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Mosaic"></code></example>
            <overloads><summary>Applies mosaic effect.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Mosaic(System.Single,System.Single)">
            <summary>Applies mosaic effect.</summary>
            <param name="cellWidth">Mosaic cell width.</param>
            <param name="cellHeight">Mosaic cell height.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Mosaic(System.Drawing.Size)">
            <summary>Applies mosaic effect.</summary>
            <param name="cellSize">Mosaic cell size.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Mosaic(System.Drawing.SizeF)">
            <summary>Applies mosaic effect.</summary>
            <param name="cellSize">Mosaic cell size.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Mosaic" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Int32,System.Int32)">
            <summary>Applies page curl effect.</summary>
            <param name="width">Width of the page corner to curl.</param>
            <param name="height">Height of the page corner to curl.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#PageCurl"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#PageCurl"></code></example>
            <overloads><summary>Applies page curl effect.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies page curl effect.</summary>
            <param name="width">Width of the page corner to curl.</param>
            <param name="height">Height of the page corner to curl.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Single,System.Single)">
            <summary>Applies page curl effect.</summary>
            <param name="width">Width of the page corner to curl.</param>
            <param name="height">Height of the page corner to curl.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies page curl effect.</summary>
            <param name="width">Width of the page corner to curl.</param>
            <param name="height">Height of the page corner to curl.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Drawing.Size)">
            <summary>Applies page curl effect.</summary>
            <param name="size">Size of the page corner to curl.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies page curl effect.</summary>
            <param name="size">Size of the page corner to curl.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Drawing.SizeF)">
            <summary>Applies page curl effect.</summary>
            <param name="size">Size of the page corner to curl.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.PageCurl(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.Direction,Aurigma.GraphicsMill.Transforms.Orientation,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Color)">
            <summary>Applies page curl effect.</summary>
            <param name="size">Size of the page corner to curl.</param>
            <param name="corner"><see cref="T:Aurigma.GraphicsMill.Transforms.Direction" /> specifying a corner of the image to curl.</param>
            <param name="orientation"><see cref="T:Aurigma.GraphicsMill.Transforms.Orientation" /> value that specifies orientation of the curl. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.Orientation" /> property.</param>
            <param name="curlColor">Value specifying a curl color. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.CurlColor" /> property.</param>
            <param name="backgroundColor">Value specifying background color for the curled image. You can change this value later using <see cref="P:Aurigma.GraphicsMill.Transforms.PageCurl.BackgroundColor" /> property.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.PageCurl" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Int32,System.Int32)">
            <summary>Resizes the image.</summary>
            <param name="width">Width of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">Height of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Resize1Bitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Resize1Bitmap"></code></example>
            <overloads><summary>Resizes the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="width">Width of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">Height of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Resize2"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Resize2"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Resizes the image.</summary>
            <param name="width">A width of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">A height of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than <i>width</i> and <i>height</i> arguments.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Int32,System.Int32,Aurigma.GraphicsMill.Transforms.ResizeMode,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="width">A width of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">A height of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <param name="interpolationMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> enumeration which specifies an interpolation algorithm which used during the resize.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than <i>width</i> and <i>height</i> arguments.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Single,System.Single)">
            <summary>Resizes the image.</summary>
            <param name="width">Width of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">Height of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="width">Width of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">Height of resized bitmap. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Resizes the image.</summary>
            <param name="width">A width of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">A height of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than <i>width</i> and <i>height</i> arguments.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Single,System.Single,Aurigma.GraphicsMill.Transforms.ResizeMode,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="width">A width of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="height">A height of resize transform. If it equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <param name="interpolationMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> enumeration which specifies an interpolation algorithm which used during the resize.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than <i>width</i> and <i>height</i> arguments.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.Size)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than specified in the <i>size</i> argument.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.Size,Aurigma.GraphicsMill.Transforms.ResizeMode,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <param name="interpolationMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> enumeration which specifies an interpolation algorithm which used during the resize.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than specified in the <i>size</i> argument.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.SizeF)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.ResizeMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than specified in the <i>size</i> argument.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Resize(System.Drawing.SizeF,Aurigma.GraphicsMill.Transforms.ResizeMode,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Resizes the image.</summary>
            <param name="size">Dimensions of resized bitmap. If some of dimensions equals to 0, it is calculated automatically to preserve the aspect ratio of the source image. Both <i>width</i> and <i>height</i> cannot be 0 at the same time.</param>
            <param name="resizeMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.ResizeMode" /> enumeration which specifies how to interpret the resize dimensions.</param>
            <param name="interpolationMode">A member of the <see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> enumeration which specifies an interpolation algorithm which used during the resize.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform.</para><note>If certain values of <i>resizeMode</i> are specified, width and height of the result bitmap may be different than specified in the <i>size</i> argument.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Rotate(System.Single)" draft="yes">
            <summary>Rotates an image at arbitrary angle.</summary>
            <param name="angle">Angle to rotate image at (in degrees).</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Resize" /> class to apply this transform. Besides, if you know that you will always rotate the image at 90, 180, or 270 degrees, you can use special optimized <see cref="M:Aurigma.GraphicsMill.TransformsProvider.RotateAndFlip(System.Drawing.RotateFlipType)" /> method (or appropriate <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> transform).</remarks>
            <overloads><summary>Rotates an image at arbitrary angle.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Rotate(System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Rotates an image at arbitrary angle.</summary>
            <param name="angle">Angle to rotate image at (in degrees).</param>
            <param name="backgroundColor">Value specifying background color for the rotated image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during rotation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Rotate" /> class to apply this transform. Besides, if you know that you will always rotate the image at 90, 180, or 270 degrees, you can use special optimized <see cref="M:Aurigma.GraphicsMill.TransformsProvider.RotateAndFlip(System.Drawing.RotateFlipType)" /> method (or appropriate <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> transform).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Rotate5Bitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Rotate5Bitmap"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.RotateAndFlip(System.Drawing.RotateFlipType)">
            <summary>Flips the image and/or rotates it at 90, 180, or 270 degrees (optimized comparing to <see cref="M:Aurigma.GraphicsMill.TransformsProvider.Rotate(System.Single)" /> method).</summary>
            <param name="flipMode"><see cref="T:System.Drawing.RotateFlipType" /> value specifying flip/rotate mode.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> class to apply this transform. Besides, if you know that you will always rotate the image at 90, 180, or 270 degrees, you can use special optimized <see cref="M:Aurigma.GraphicsMill.TransformsProvider.RotateAndFlip(System.Drawing.RotateFlipType)" /> method (or appropriate <see cref="T:Aurigma.GraphicsMill.Transforms.RotateAndFlip" /> transform).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Rotate90Bitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Rotate90Bitmap"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Shadow(Aurigma.GraphicsMill.Color,System.Single,System.Single)">
            <summary>Applies a shadow effect.</summary>
            <param name="shadowColor">Glow color.</param>
            <param name="horizontalOffset">Horizontal offset of the shadow.</param>
            <param name="verticalOffset">Vertical offset of the shadow.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class to apply this effect.</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Shadow"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Shadow"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Shadow(Aurigma.GraphicsMill.Color,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Applies a shadow effect.</summary>
            <param name="shadowColor">Glow color.</param>
            <param name="horizontalOffset">Horizontal offset of the shadow.</param>
            <param name="verticalOffset">Vertical offset of the shadow.</param>
            <param name="radius">Value that specifies a blur radius used to blur the shadow.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire shadow.</param>
            <remarks><para>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Shadow" /> class to apply this effect.</para><note>
If the bitmap does not have an alpha channel (e.g. its pixel format is <see cref="F:Aurigma.GraphicsMill.PixelFormat.Format24bppRgb" />), alpha channel is automatically added. So be aware that pixel format of the output bitmap may differ from the input one.
</note></remarks>
            <overloads><summary>Applies a shadow effect.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Sharpen(System.Int32)">
            <summary>Applies simple sharpen effect on the image.</summary>
            <param name="strength">Value in range [0, 100] specifying sharpening strength. Minimum value makes no changes, maximum value produces maximum sharpening effect.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Sharpen" /> class to apply this effect. Besides, you can use more advanced sharpen algorithm implemented in the <see cref="M:Aurigma.GraphicsMill.TransformsProvider.UnsharpMask(System.Single,System.Single,System.Single)" /> method (and appropriate <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> transform class).</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#SharpenBitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#SharpenBitmap"></code></example>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Spray(System.Int32)">
            <summary>Applies spray effect on the image.</summary>
            <param name="amount">Value specifying the amount of the effect (variance of the random number generated by the transform).</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Spray"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Spray"></code></example>
            <overloads><summary>Applies spray effect on the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Spray(System.Int32,System.Single,Aurigma.GraphicsMill.Transforms.FadeType,System.Int32,Aurigma.GraphicsMill.Color)">
            <summary>Applies spray effect on the image.</summary>
            <param name="amount">Value specifying the amount of the effect (variance of the random number generated by the transform).</param>
            <param name="frameWidth">Width of the frame for which the effect should be applied.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies fade type for the spray effect.</param>
            <param name="seed">An integer value specifying seed for random generator.</param>
            <param name="backgroundColor">Default value is a transparent white.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Spray" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Int32,System.Int32,System.Single)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="x">X-coordinate of the swirl center.</param>
            <param name="y">Y-coordinate of the swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Swirl"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Swirl"></code></example>
            <overloads><summary>Applies swirl transform on the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Int32,System.Int32,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="x">X-coordinate of the swirl center.</param>
            <param name="y">Y-coordinate of the swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Single,System.Single,System.Single)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="x">X-coordinate of the swirl center.</param>
            <param name="y">Y-coordinate of the swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="x">X-coordinate of the swirl center.</param>
            <param name="y">Y-coordinate of the swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Drawing.Point,System.Single)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="center">Point that specifies swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Drawing.Point,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="center">Point that specifies swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Drawing.PointF,System.Single)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="center">Point that specifies swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Swirl(System.Drawing.PointF,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies swirl transform on the image.</summary>
            <param name="center">Point that specifies swirl center.</param>
            <param name="scaleFactor">Swirl scale factor.</param>
            <param name="backgroundColor">Value specifying background color for the swirled image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during swirling.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Swirl" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Texturize(System.Int32,System.Int32)">
            <summary>Create texture from the image by reducing its size and "gluing" it with its copies seamlessly.</summary>
            <param name="columnsAmount">Columns number.</param>
            <param name="rowsAmount">Rows number.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Texturize"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Texturize"></code></example>
            <overloads><summary>Create texture from the image by reducing its size and "gluing" it with its copies seamlessly.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Texturize(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.RotateFlipType,Aurigma.GraphicsMill.Transforms.FadeType,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Create texture from the image by reducing its size and "gluing" it with its copies seamlessly.</summary>
            <param name="columnsAmount">Columns number.</param>
            <param name="rowsAmount">Rows number.</param>
            <param name="horizontalIntersection">Value that specifies how much percents of image are overlapped horizontally (at single side).</param>
            <param name="verticalIntersection">Value that specifies how much percents of image are overlapped vertically (at single side).</param>
            <param name="flipMode"><see cref="T:System.Drawing.RotateFlipType" /> value that specifies how to flip/rotate the images one relatively other.</param>
            <param name="fadeType"><see cref="T:Aurigma.GraphicsMill.Transforms.FadeType" /> value that specifies how to fade out edges to eliminate seams.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during resizing.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Texturize" /> class to apply this effect.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.TransformsProvider.Timeout">
            <summary>Gets/sets value specifying maximum time for which object can be locked.</summary>
            <value>Value specifying maximum time for which object can be locked. You can set -1 for infinite timeout.</value>
            <remarks><para>
When the object is locked for more time than specified with this property, the object is automatically unlocked and currently running operation is aborted.
</para><para>
Default value is -1 (infinite value).
</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.UnsharpMask(System.Single,System.Single,System.Single)" draft="yes">
            <summary>Enhances image sharpness using <i>unsharp mask</i> technique.</summary>
            <param name="amount">Value that specifies unsharp mask amount.</param>
            <param name="radius">Value that specifies blur radius used to produce unfocused version of the image.</param>
            <param name="threshold">Value in range [0, 1] specifying threshold value for the unsharp mask. Minimum value (0) means that all pixels are affected with unsharp mask, maximum value means that no pixels are affected. To calculate threshold in pixel luminosity levels, multiply it on 255 for non-extended (8 bit per channel) images, or 65535 for extended (16 bit per channel) images.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#UnsharpMaskBitmap"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#UnsharpMaskBitmap"></code></example>
            <overloads><summary>Enhances image sharpness using <i>unsharp mask</i> technique.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.UnsharpMask(System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Transforms.BlurType)">
            <summary>Enhances image sharpness using <i>unsharp mask</i> technique.</summary>
            <param name="amount">Value that specifies unsharp mask amount.</param>
            <param name="radius">Value that specifies blur radius used to produce unfocused version of the image.</param>
            <param name="threshold">Value in range [0, 1] specifying threshold value for the unsharp mask. Minimum value (0) means that all pixels are affected with unsharp mask, maximum value means that no pixels are affected. To calculate threshold in pixel luminosity levels, multiply it on 255 for non-extended (8 bit per channel) images, or 65535 for extended (16 bit per channel) images.</param>
            <param name="blurType"><see cref="T:Aurigma.GraphicsMill.Transforms.BlurType" /> value specifying a blur type used to produce unfocused version of the image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.UnsharpMask" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Waddle(System.Single)">
            <summary>Applies waddle effect.</summary>
            <param name="radius">Waddle radius.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class to apply this effect.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Waddle"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Waddle"></code></example>
            <overloads><summary>Applies waddle effect.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Waddle(System.Single,Aurigma.GraphicsMill.Transforms.Direction)">
            <summary>Applies waddle effect.</summary>
            <param name="radius">Waddle radius.</param>
            <param name="direction">Waddle direction.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Waddle" /> class to apply this effect.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="x">X-coordinate of the center point of the water drop.</param>
            <param name="y">Y-coordinate of the center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#WaterDrop"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#WaterDrop"></code></example>
            <overloads><summary>Applies water drop transform (effect of ripples on the water).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Int32,System.Int32,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="x">X-coordinate of the center point of the water drop.</param>
            <param name="y">Y-coordinate of the center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="x">X-coordinate of the center point of the water drop.</param>
            <param name="y">Y-coordinate of the center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Single,System.Single,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="x">X-coordinate of the center point of the water drop.</param>
            <param name="y">Y-coordinate of the center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Drawing.Point,System.Single,System.Single,System.Single)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="center">Center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Drawing.Point,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="center">Center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Drawing.PointF,System.Single,System.Single,System.Single)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="center">Center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.WaterDrop(System.Drawing.PointF,System.Single,System.Single,System.Single,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode)">
            <summary>Applies water drop transform (effect of ripples on the water).</summary>
            <param name="center">Center point of the water drop.</param>
            <param name="radius">Radius of the water drop.</param>
            <param name="amplitude">Amplitude of the water drop.</param>
            <param name="wavelength">Wave length of the ripples.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during water drop transformation.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.WaterDrop" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Wave(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>Applies a wave transform on the image.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave.</param>
            <param name="horizontalWavelength">Length of the horizontal wave.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees).</param>
            <param name="verticalAmplitude">Amplitude for vertical wave.</param>
            <param name="verticalWavelength">Length of the vertical wave.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees).</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class to apply this transform.</remarks>
            <example><code language="VB" source="ApplyingEffectsVB/form1.vb#Wave"></code><code language="CS" source="ApplyingEffectsCS/form1.cs#Wave"></code></example>
            <overloads><summary>Applies a wave transform on the image.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Wave(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32,Aurigma.GraphicsMill.Transforms.WaveType)">
            <summary>Applies a wave transform on the image.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave.</param>
            <param name="horizontalWavelength">Length of the horizontal wave.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees).</param>
            <param name="verticalAmplitude">Amplitude for vertical wave.</param>
            <param name="verticalWavelength">Length of the vertical wave.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees).</param>
            <param name="waveType"><see cref="T:Aurigma.GraphicsMill.Transforms.WaveType" /> value that specifies a form of the wave.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class to apply this transform.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TransformsProvider.Wave(System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32,Aurigma.GraphicsMill.Transforms.WaveType,Aurigma.GraphicsMill.Color,Aurigma.GraphicsMill.Transforms.InterpolationMode,System.Boolean)">
            <summary>Applies a wave transform on the image.</summary>
            <param name="horizontalAmplitude">Amplitude for horizontal wave.</param>
            <param name="horizontalWavelength">Length of the horizontal wave.</param>
            <param name="horizontalStartPhase">Horizontal wave start phase (in degrees).</param>
            <param name="verticalAmplitude">Amplitude for vertical wave.</param>
            <param name="verticalWavelength">Length of the vertical wave.</param>
            <param name="verticalStartPhase">Vertical wave start phase (in degrees).</param>
            <param name="waveType"><see cref="T:Aurigma.GraphicsMill.Transforms.WaveType" /> value that specifies a form of the wave.</param>
            <param name="backgroundColor">Value specifying background color for the distorted image.</param>
            <param name="interpolationMode"><see cref="T:Aurigma.GraphicsMill.Transforms.InterpolationMode" /> value specifying interpolation algorithm used during wave transformation.</param>
            <param name="enlargeToFit">Value that specifies whether to enlarge the image to fit entire distorted image.</param>
            <remarks>You can also use <see cref="T:Aurigma.GraphicsMill.Transforms.Wave" /> class to apply this transform.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.TrialPeriodTimeException">
            <summary>The exception which fires when the trial version has been expired.</summary>
            <remarks><para>
              Graphics Mill for .NET add-ons has limited trial period. When it expires, this exception is thrown.
            </para><note>The core of Graphics Mill for .NET does not have a trial period. It just displays the trial text on each image you save with Graphics Mill for .NET.</note></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.TrialPeriodTimeException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.TrialPeriodTimeException" /> class.</summary>
            <overloads><summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.TrialPeriodTimeException" /> class.</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.TrialPeriodTimeException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.TrialPeriodTimeException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.TrialPeriodTimeException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.TrialPeriodTimeException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.TrialPeriodTimeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.UnexpectedException" draft="yes">
            <summary>The exception which is thrown when Graphics Mill for .NET has encountered an unexpected problem (mostly caused by some internal bug).</summary>
            <remarks>If you get this exception, it is likely you have discovered some Graphics Mill for .NET bug. In this case it would be greatly appreciated if you create <a href="http://www.aurigma.com/MyAurigma/CreateCase.aspx">support case</a>. Please provide as much details as possible (code snippet which causes a problem, loaded image, system details, etc).</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnexpectedException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.UnexpectedException" /> class.</summary>
            <overloads><summary>
                Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.UnexpectedException" /> class.
              </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnexpectedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.UnexpectedException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnexpectedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.UnexpectedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnexpectedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Unit">
            <summary>Contains unit types. It can be either device-dependent unit (pixel) or device-independent (inches, points, etc).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Cm">
            <summary>Centimeter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Column">
            <summary>Column (100/263 of inch).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Document">
            <summary>Document unit (1/300 of inch).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Inch">
            <summary>Inch.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.M">
            <summary>Meter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Mm">
            <summary>Millimeter.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Pica">
            <summary>Pica (1/6 of inch).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Pixel">
            <summary>Pixel.</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Point">
            <summary>Point (1/72 of inch).</summary>
        </member>
        <member name="F:Aurigma.GraphicsMill.Unit.Twip">
            <summary>Twip (1/20 of point).</summary>
        </member>
        <member name="T:Aurigma.GraphicsMill.UnitConverter">
            <summary>This class can be used to convert values from one spatial units to another.</summary>
            <remarks><para>This class provides three static methods which enables you to convert:</para><list type="bullet"><item><description>
                    Device-dependent units (pixels) -&gt; device-independent units (like inches, centimeters, etc). See the method <see cref="M:Aurigma.GraphicsMill.UnitConverter.ConvertPixelsToUnits(System.Single,System.Int32,Aurigma.GraphicsMill.Unit)" />.
                  </description></item><item><description>
                    Device-independent units -&gt; device-dependent units. See the method <see cref="M:Aurigma.GraphicsMill.UnitConverter.ConvertUnitsToPixels(System.Single,System.Single,Aurigma.GraphicsMill.Unit)" />.
                  </description></item><item><description>
                    One device-independent units -&gt; another device-independent units. See the method <see cref="M:Aurigma.GraphicsMill.UnitConverter.ConvertUnitsToUnits(System.Single,System.Single,Aurigma.GraphicsMill.Unit,Aurigma.GraphicsMill.Unit)" />.
                  </description></item></list><para>All these method require a parameter called resolution - a number of pixels in one inch (dots per pixel - DPI). Typically this parameter depends on the resolution you are going to get when printing the image (e.g. 300 or 600 DPI). Also, it can be a screen resolution (as usual, 96 DPI). </para></remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverter.ConvertPixelsToUnits(System.Single,System.Int32,Aurigma.GraphicsMill.Unit)">
            <summary>Converts a value measured in pixels (device-dependent units) to specified device-independent unit.</summary>
            <param name="resolution">A resolution in DPI used to convert pixels to <i>destinationUnit</i>.</param>
            <param name="sourceValue">A value in pixels which should be converted to <i>destinationUnit</i>.</param>
            <param name="destinationUnit">A destination unit.</param>
            <returns>A value converted to <i>destinationUnit</i>.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverter.ConvertUnitsToPixels(System.Single,System.Single,Aurigma.GraphicsMill.Unit)">
            <summary>Converts a value measured in specified device-independent unit to pixels.</summary>
            <param name="resolution">A resolution in DPI used to convert <i>sourceUnit</i> to pixels.</param>
            <param name="sourceValue">A value measured in <i>sourceUnit</i> which should be converted to pixels.</param>
            <param name="sourceUnit">A source unit.</param>
            <returns>A value converted to pixels.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverter.ConvertUnitsToUnits(System.Single,System.Single,Aurigma.GraphicsMill.Unit,Aurigma.GraphicsMill.Unit)">
            <summary>Converts a value measured in one device-independent unit to another one.</summary>
            <param name="resolution">A resolution in DPI.</param>
            <param name="sourceValue">A value measured in <i>sourceUnit</i> which should be converted to <i>destinationUnit</i>.</param>
            <param name="sourceUnit">A source unit.</param>
            <param name="destinationUnit">A destination unit.</param>
            <returns>A converted value.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.UnitConverterHandler">
            <summary>This class contains partial implementation of <see cref="T:Aurigma.GraphicsMill.IUnitConverter" /> interface and used by all classes representing asynchronous operations.</summary>
            <remarks>Typically from this class derived such transforms that work with spatial units, e.g. that specify width, height, etc.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterHandler.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterHandler.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterHandler.GetVerticalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterHandler.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterHandler.#ctor(Aurigma.GraphicsMill.Unit)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.UnitConverterHandler.Unit">
            <summary>Gets/sets unit used to measure all the coordinates, sizes and other spatial values.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Unit" /> enumeration member which specifies unit to measure the coordinates and sizes.</value>
        </member>
        <member name="T:Aurigma.GraphicsMill.UnitConverterHandlerProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.UnitConverterObject">
            <summary>This class implements functionality of converting different space units of the measurement (e.g. inches, points, pixels, millimeters, etc) between each other.</summary>
            <remarks>This class is abstract, so you cannot instantiate it. It is used in inheritance tree of such classes as <see cref="T:Aurigma.GraphicsMill.Bitmap" /> or <see cref="T:Aurigma.GraphicsMill.Drawing.GdiGraphics" /> to provide support of different units in method parameters.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.{dtor}">
            <summary>Enables using delete operator in C++ applications. It is strongly not recommended to use it directly.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.GetHorizontalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.GetVerticalResolution">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.HorizontalPixelsToUnits(System.Int32)">
            <summary>Converts horizontal value from pixels to unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</summary>
            <param name="pixels">Horizontal value in pixels.</param>
            <returns>Horizontal value converted into necessary unit.</returns>
            <remarks>Examples of vertical values are image width, X-coordinate, etc.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.UnitConverterObject.HorizontalResolution">
            <summary>Specifies horizontal resolution of the image (also known as DPI, dots per inch).</summary>
            <value>Horizontal resolution of the current bitmap.</value>
            <remarks>This property is necessary to convert horizontal value between pixels and other units properly (using <see cref="M:Aurigma.GraphicsMill.UnitConverterObject.HorizontalUnitsToPixels(System.Single)" /> and <see cref="M:Aurigma.GraphicsMill.UnitConverterObject.HorizontalPixelsToUnits(System.Int32)" /> methods). Examples of vertical values are image width, X-coordinate, etc.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.HorizontalUnitsToPixels(System.Single)">
            <summary>Converts horizontal value from unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property to pixels.</summary>
            <param name="units">Horizontal value in unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</param>
            <returns>Horizontal value converted to pixels.</returns>
            <remarks>Examples of vertical values are image width, X-coordinate, etc.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.#ctor">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.#ctor(Aurigma.GraphicsMill.Unit)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.SetHorizontalResolution(System.Single)">
            <exclude />
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.SetVerticalResolution(System.Single)">
            <exclude />
        </member>
        <member name="P:Aurigma.GraphicsMill.UnitConverterObject.Unit">
            <summary>Gets/sets unit to convert from/to.</summary>
            <value><see cref="T:Aurigma.GraphicsMill.Unit" /> value, specifying target unit.</value>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.VerticalPixelsToUnits(System.Int32)">
            <summary>Converts vertical value from pixels to unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</summary>
            <param name="pixels">Vertical value in pixels.</param>
            <returns>Vertical value converted into necessary unit.</returns>
            <remarks>Examples of horizontal values are image height, Y-coordinate, etc.</remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.UnitConverterObject.VerticalResolution">
            <summary>Specifies vertical resolution (also known as DPI, dots per inch).</summary>
            <value>Vertical resolution of the current bitmap.</value>
            <remarks>This property is necessary to convert vertical value between pixels and other units properly (using <see cref="M:Aurigma.GraphicsMill.UnitConverterObject.VerticalUnitsToPixels(System.Single)" /> and <see cref="M:Aurigma.GraphicsMill.UnitConverterObject.VerticalPixelsToUnits(System.Int32)" /> methods). Examples of vertical values are image height, Y-coordinate, etc.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnitConverterObject.VerticalUnitsToPixels(System.Single)">
            <summary>Converts vertical value from unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property to pixels.</summary>
            <param name="units">Vertical value in unit specified in <see cref="P:Aurigma.GraphicsMill.UnitConverterObject.Unit" /> property.</param>
            <returns>Vertical value converted to pixels.</returns>
            <remarks>Examples of horizontal values are image height, Y-coordinate, etc.</remarks>
        </member>
        <member name="T:Aurigma.GraphicsMill.UnitConverterObjectProxy">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.UnsignedRational">
            <summary>This class represents unsigned rational numbers.</summary>
            <remarks><para>
                Rational number is a number which may be represented as a division of two natural numbers.For example, 3/4, 2/1, 1/6, etc. Not all fractional numbers are rational. For example, a Pi number is <i>irrational</i> (i.e. cannot be represented as a division of two natural numbers).
              </para><para>
                This class provides an access to <see cref="P:Aurigma.GraphicsMill.Rational.Dividend" /> and <see cref="P:Aurigma.GraphicsMill.Rational.Divider" />. A <see cref="P:Aurigma.GraphicsMill.Rational.Divider" /> cannot be zero.
              </para></remarks>
        </member>
        <member name="P:Aurigma.GraphicsMill.UnsignedRational.Dividend">
            <summary>Gets/sets dividend of the rational number.</summary>
            <value>Value that specifies dividend of the rational number (i.e. if represent rational number as <i>p/q</i>, dividend is <i>p</i>).</value>
        </member>
        <member name="P:Aurigma.GraphicsMill.UnsignedRational.Divider">
            <summary>Gets/sets divider of the rational number.</summary>
            <value>Value that specifies divider of the rational number (i.e. if represent rational number as <i>p/q</i>, divider is <i>q</i>).</value>
            <remarks>Divider cannot equal to zero.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.Equals(System.Object)">
            <summary>Compares this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> with specified object.</summary>
            <param name="object">The <see cref="T:System.Object" /> to compare with the current <see cref="T:Aurigma.GraphicsMill.UnsignedRational" />. If actual type of this argument is other than <see cref="T:Aurigma.GraphicsMill.UnsignedRational" />, exception will be raised.</param>
            <returns>Value specifying whether given object represents the same value as this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" />.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.GetHashCode">
            <summary>Returns a hash code for this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class.</summary>
            <returns>An integer value that specifies the hash code for this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.#ctor" draft="yes">
            <summary>Creates empty <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> instance.</summary>
            <overloads><summary>
                Creates empty <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> instance.
              </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.#ctor(System.UInt32,System.UInt32)">
            <summary>Creates new <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> instance with specified dividend and divider.</summary>
            <param name="dividend">Value that specifies dividend of the rational number (i.e. if represent rational number as <i>p/q</i>, dividend is <i>p</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.UnsignedRational.Dividend" /> property.</param>
            <param name="divider">Value that specifies divider of the rational number (i.e. if represent rational number as <i>p/q</i>, divider is <i>q</i>). You can change it later using <see cref="P:Aurigma.GraphicsMill.UnsignedRational.Divider" /> property.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.op_Equality(Aurigma.GraphicsMill.UnsignedRational,Aurigma.GraphicsMill.UnsignedRational)">
            <summary>Compares <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> values for equality.</summary>
            <param name="object1">First <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> value.</param>
            <param name="object2">Second <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> value.</param>
            <returns>Value that is <b>true</b> when numbers are equal, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.op_Implicit(Aurigma.GraphicsMill.UnsignedRational)~System.Single">
            <summary>Converts this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class instance into <see cref="T:System.Single" /> value.</summary>
            <param name="object"><see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class instance which should be converted into <see cref="T:System.Single" />.</param>
            <returns><see cref="T:System.Single" /> converted from this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class instance.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.op_Inequality(Aurigma.GraphicsMill.UnsignedRational,Aurigma.GraphicsMill.UnsignedRational)">
            <summary>Compares <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> values for inequality.</summary>
            <param name="object1">First <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> value.</param>
            <param name="object2">Second <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> value.</param>
            <returns>Value that is <b>true</b> when numbers are inequal, <b>false</b> otherwise.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsignedRational.ToString">
            <summary>Returns string representation of this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class instance.</summary>
            <returns>A string representation of this <see cref="T:Aurigma.GraphicsMill.UnsignedRational" /> class instance.</returns>
        </member>
        <member name="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException">
            <summary>The exception which is thrown when you try to apply some operation on the bitmap, and this operation cannot handle pixel format of this bitmap.</summary>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsupportedPixelFormatException.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> class.</summary>
            <overloads><summary>
                Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> class.
              </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsupportedPixelFormatException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsupportedPixelFormatException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.UnsupportedPixelFormatException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.UnsupportedPixelFormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.Win32Exception">
            <summary>The exception occurred when some WinAPI error returned.</summary>
            <remarks>This exception can be met during file operations, working with GDI, and other system-related problems.</remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.Win32Exception.#ctor" draft="yes">
            <summary>Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Win32Exception" /> class.</summary>
            <overloads><summary>
                Initializes a new instance of <see cref="T:Aurigma.GraphicsMill.Win32Exception" /> class.
              </summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.Win32Exception.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Win32Exception" /> class with a specified error message.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Win32Exception.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:Aurigma.GraphicsMill.Win32Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the <i>innerException</i> parameter is not a null reference, the current exception is raised in a <b>catch</b> block that handles the inner exception.</param>
        </member>
        <member name="M:Aurigma.GraphicsMill.Win32Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude />
        </member>
        <member name="T:Aurigma.GraphicsMill.ZipCompressor">
            <summary>This class is intended to compress binary data with the deflate algorithm (also known as ZIP).</summary>
            <remarks>This class is used by Graphics Mill for .NET for internal data compression. However you can use it to compress your data as well. It exposes two static method: <see cref="M:Aurigma.GraphicsMill.ZipCompressor.Compress(System.Byte[])" /> and <see cref="M:Aurigma.GraphicsMill.ZipCompressor.Decompress(System.Byte[])" />. Simply pass an array as argument and get an array containing compressed or decompressed data.</remarks>
            <threadsafety static="true" instance="true" />
        </member>
        <member name="M:Aurigma.GraphicsMill.ZipCompressor.Compress(System.Byte[])" draft="yes">
            <summary>Compresses a byte array with the deflate algorithm (ZIP).</summary>
            <param name="originalData">An array of data which you need to compress.</param>
            <returns>An array of bytes which contains compressed data.</returns>
            <overloads><summary>Compresses a byte array with the deflate algorithm (ZIP).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ZipCompressor.Compress(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>Compresses a byte array with the deflate algorithm (ZIP).</summary>
            <param name="originData">The pointer to unmanaged byte array which stores the data you need to compress.</param>
            <param name="originDataSize">The integer value which specifies the length of the input buffer.</param>
            <param name="compressedData">The pointer to the unmanaged byte array which will get the compressed data. The memory should be allocated by caller.</param>
            <param name="compressedDataSize">The integer value which specifies the lenght of the output buffer.</param>
            <returns>The integer value which specifies how many bytes were actually allocated during compression.</returns>
            <remarks><para>You should guaranty that the length of the output buffer enough to hold the result of compression.</para></remarks>
        </member>
        <member name="M:Aurigma.GraphicsMill.ZipCompressor.Decompress(System.Byte[])" draft="yes">
            <summary>Decompresses given array which contains data compressed with the deflate algorithm (ZIP).</summary>
            <param name="compressedData">A byte array which contains compressed data.</param>
            <returns>A byte array which contains decompressed data.</returns>
            <overloads><summary>Decompresses given array which contains data compressed with the deflate algorithm (ZIP).</summary></overloads>
        </member>
        <member name="M:Aurigma.GraphicsMill.ZipCompressor.Decompress(System.Byte[],System.Int32)">
            <summary>Decompresses given array which contains data compressed with the deflate algorithm (ZIP). Use this overload if you know the size of decompressed data to optimize a performance.</summary>
            <param name="compressedData">A byte array which contains compressed data.</param>
            <param name="decompressedSize">A size of decompressed data. If you specify this parameter, Graphics Mill for .NET will be able to decompress the data in more memory-friendly way.</param>
            <returns>A byte array which contains decompressed data.</returns>
        </member>
        <member name="M:Aurigma.GraphicsMill.ZipCompressor.Decompress(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>Decompresses given array which contains data compressed with the deflate algorithm (ZIP).</summary>
            <param name="compressedData">The pointer to unmanaged byte array which stores the ZIP-compressed data.</param>
            <param name="compressedDataSize">The integer value which specifies the length of the input buffer.</param>
            <param name="decompressedData">The pointer to the unmanaged byte array which will get the decompressed data. The memory should be allocated by caller.</param>
            <param name="decompressedDataSize">The integer value which specifies the lenght of the output buffer.</param>
            <returns>The integer value which specifies how many bytes were actually allocated during decompression.</returns>
            <remarks><para>You should guaranty that the length of the output buffer enough to hold the result of decompression.</para></remarks>
        </member>
    </members>
</doc>
